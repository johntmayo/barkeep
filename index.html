<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Barkeep">
  <meta name="theme-color" content="#0c0a09">
  <title>Barkeep</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230c0a09' width='100' height='100'/><text y='65' x='50%' text-anchor='middle' font-size='40' font-family='Georgia' fill='%23d4a574'>B</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            ink: {
              950: '#0c0a09',
              900: '#1c1917',
              850: '#231f1e',
              800: '#292524',
              700: '#44403c',
              600: '#57534e',
              500: '#78716c',
              400: '#a8a29e',
              300: '#d6d3d1',
              200: '#e7e5e4',
              100: '#f5f5f4',
            },
            copper: {
              DEFAULT: '#d4a574',
              light: '#e8c9a8',
              dark: '#b8956a',
              muted: '#a08060',
            },
            cream: {
              DEFAULT: '#faf8f5',
              dark: '#f0ebe4',
            }
          },
          fontFamily: {
            'display': ['"Cormorant Garamond"', 'Georgia', 'serif'],
            'body': ['Inter', 'system-ui', 'sans-serif'],
          },
          fontSize: {
            '2xs': '0.65rem',
          }
        }
      }
    }
  </script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background-color: #0c0a09;
      color: #d6d3d1;
      font-weight: 300;
      overscroll-behavior: none;
    }
    .font-display { font-family: 'Cormorant Garamond', Georgia, serif; }
    
    /* Subtle texture */
    .paper-texture::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.012;
      pointer-events: none;
      z-index: 9999;
    }
    
    /* Cards */
    .card {
      background: linear-gradient(145deg, #1c1917 0%, #171412 100%);
      border: 1px solid rgba(255,255,255,0.03);
    }
    .card-elevated {
      background: linear-gradient(145deg, #231f1e 0%, #1c1917 100%);
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #44403c; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #57534e; }
    .hide-scrollbar::-webkit-scrollbar { display: none; }
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes scaleIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .animate-fade-in { animation: fadeIn 0.2s ease; }
    .animate-slide-up { animation: slideUp 0.3s ease; }
    .animate-slide-down { animation: slideDown 0.3s ease; }
    .animate-scale-in { animation: scaleIn 0.2s ease; }
    .animate-pulse { animation: pulse 2s ease infinite; }
    
    /* Staggered grid animation */
    .stagger-item { opacity: 0; animation: slideUp 0.4s ease forwards; }
    .stagger-item:nth-child(1) { animation-delay: 0ms; }
    .stagger-item:nth-child(2) { animation-delay: 30ms; }
    .stagger-item:nth-child(3) { animation-delay: 60ms; }
    .stagger-item:nth-child(4) { animation-delay: 90ms; }
    .stagger-item:nth-child(5) { animation-delay: 120ms; }
    .stagger-item:nth-child(6) { animation-delay: 150ms; }
    .stagger-item:nth-child(7) { animation-delay: 180ms; }
    .stagger-item:nth-child(8) { animation-delay: 210ms; }
    .stagger-item:nth-child(9) { animation-delay: 240ms; }
    .stagger-item:nth-child(n+10) { animation-delay: 270ms; }
    
    /* Focus & inputs */
    input:focus, textarea:focus, select:focus, button:focus-visible { outline: none; }
    .input-field {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      transition: all 0.2s ease;
    }
    .input-field:focus {
      background: rgba(255,255,255,0.04);
      border-color: rgba(212, 165, 116, 0.3);
    }
    .input-field::placeholder { color: #57534e; }
    
    /* Buttons */
    .btn-ghost:hover { background: rgba(255,255,255,0.04); }
    .btn-copper {
      background: linear-gradient(145deg, #d4a574, #b8956a);
      color: #0c0a09;
      transition: all 0.2s ease;
    }
    .btn-copper:hover { background: linear-gradient(145deg, #e8c9a8, #d4a574); }
    .btn-copper:active { transform: scale(0.98); }
    
    /* Divider */
    .divider { height: 1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.06), transparent); }
    
    /* Star rating */
    .star-rating { display: inline-flex; gap: 1px; }
    .star { cursor: pointer; transition: all 0.15s ease; }
    .star:hover { transform: scale(1.15); }
    
    /* Toast */
    @keyframes toastIn { from { opacity: 0; transform: translateY(100%); } to { opacity: 1; transform: translateY(0); } }
    @keyframes toastOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(100%); } }
    .toast-enter { animation: toastIn 0.3s ease; }
    .toast-exit { animation: toastOut 0.3s ease forwards; }
    
    /* Bottom nav for mobile */
    @media (max-width: 640px) {
      .mobile-bottom-nav {
        padding-bottom: env(safe-area-inset-bottom, 0);
      }
    }
    
    /* iOS standalone */
    @media all and (display-mode: standalone) {
      body { padding-top: env(safe-area-inset-top); }
      .mobile-bottom-nav { padding-bottom: calc(env(safe-area-inset-bottom) + 0.5rem); }
    }
  </style>
</head>
<body class="min-h-screen paper-texture">
  <div id="root"></div>
  
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // New service worker available
                    window.dispatchEvent(new CustomEvent('sw-update', { detail: newWorker }));
                  }
                });
              }
            });
            
            // Check for updates every hour
            setInterval(() => {
              registration.update();
            }, 3600000);
          })
          .catch(e => console.log('SW failed:', e));
      });
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // ============ UTILITIES ============
    
    // Ingredient normalization utility
    let ingredientAliasMap = null;
    let unmatchedIngredients = new Set();
    
    const buildIngredientAliasMap = (ingredientsDb) => {
      if (ingredientAliasMap) return ingredientAliasMap;
      if (!ingredientsDb) return {};
      
      const map = {};
      ingredientsDb.categories?.forEach(cat => {
        cat.subcategories?.forEach(sub => {
          sub.items?.forEach(item => {
            const canonical = item.name.toLowerCase().trim();
            // Map canonical name to itself
            map[canonical] = canonical;
            // Map aliases to canonical name
            if (item.aliases && Array.isArray(item.aliases)) {
              item.aliases.forEach(alias => {
                map[alias.toLowerCase().trim()] = canonical;
              });
            }
          });
        });
      });
      ingredientAliasMap = map;
      return map;
    };
    
    const normalizeIngredient = (name, ingredientsDb) => {
      if (!name || typeof name !== 'string') return name;
      
      // Build alias map if needed
      const aliasMap = buildIngredientAliasMap(ingredientsDb);
      
      // Normalize: lowercase, trim, remove punctuation
      let normalized = name.toLowerCase().trim();
      // Remove common punctuation but keep spaces
      normalized = normalized.replace(/[.,;:!?'"()]/g, '');
      // Normalize multiple spaces to single space
      normalized = normalized.replace(/\s+/g, ' ');
      
      // Look up in alias map
      if (aliasMap[normalized]) {
        return aliasMap[normalized];
      }
      
      // If not found, track for debugging and return normalized version
      unmatchedIngredients.add(name);
      return normalized;
    };
    
    const Icon = ({ name, className = "w-5 h-5" }) => {
      const ref = useRef(null);
      useEffect(() => {
        if (ref.current && lucide.icons[name]) {
          ref.current.innerHTML = '';
          ref.current.appendChild(lucide.createElement(lucide.icons[name]));
        }
      }, [name]);
      return <span ref={ref} className={`inline-flex items-center justify-center ${className}`} />;
    };

    const StarRating = ({ rating = 0, onRate, size = "text-sm", readonly = false }) => {
      const [hover, setHover] = useState(0);
      return (
        <div className="star-rating">
          {[1, 2, 3, 4, 5].map((star) => (
            <span
              key={star}
              className={`star ${size} ${(hover || rating) >= star ? 'text-copper' : 'text-ink-700'} ${readonly ? 'cursor-default' : ''}`}
              onMouseEnter={() => !readonly && setHover(star)}
              onMouseLeave={() => !readonly && setHover(0)}
              onClick={() => !readonly && onRate?.(star)}
            >★</span>
          ))}
        </div>
      );
    };

    const storage = {
      get: (key) => { try { const v = localStorage.getItem(key); return v ? { value: v } : null; } catch { return null; } },
      set: (key, value) => { try { localStorage.setItem(key, value); } catch (e) { console.error(e); } }
    };

    // ============ TOAST SYSTEM ============
    
    const ToastContext = React.createContext();
    
    const ToastProvider = ({ children }) => {
      const [toasts, setToasts] = useState([]);
      
      const addToast = useCallback((message, type = 'default') => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type, exiting: false }]);
        setTimeout(() => {
          setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t));
          setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 300);
        }, 2500);
      }, []);
      
      return (
        <ToastContext.Provider value={addToast}>
          {children}
          <div className="fixed bottom-20 sm:bottom-6 left-4 right-4 sm:left-auto sm:right-6 z-50 flex flex-col gap-2 pointer-events-none">
            {toasts.map(toast => (
              <div
                key={toast.id}
                className={`${toast.exiting ? 'toast-exit' : 'toast-enter'} px-4 py-3 rounded-lg bg-ink-800 border border-white/5 shadow-xl flex items-center gap-3 pointer-events-auto`}
              >
                {toast.type === 'success' && <Icon name="Check" className="w-4 h-4 text-emerald-400" />}
                {toast.type === 'error' && <Icon name="X" className="w-4 h-4 text-red-400" />}
                <span className="text-sm text-ink-200 font-light">{toast.message}</span>
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    };
    
    const useToast = () => React.useContext(ToastContext);

    // ============ CONSTANTS ============
    
    const SPIRIT_CATEGORIES = ['Gin', 'Vodka', 'Whiskey', 'Rum', 'Tequila', 'Brandy', 'Other'];
    const METHOD_OPTIONS = ['Shake', 'Stir', 'Build', 'Muddle', 'Blend'];
    const SORT_OPTIONS = [
      { value: 'name', label: 'A–Z' },
      { value: 'newest', label: 'Newest' },
      { value: 'rating', label: 'Top Rated' },
      { value: 'most-made', label: 'Most Made' },
      { value: 'ingredients', label: 'Fewest Ingredients' },
    ];
    
    // Detect method from instructions
    const detectMethod = (drink) => {
      const instr = (drink.instructions || '').toLowerCase();
      if (instr.includes('shake')) return 'Shake';
      if (instr.includes('stir')) return 'Stir';
      if (instr.includes('muddle')) return 'Muddle';
      if (instr.includes('blend')) return 'Blend';
      if (instr.includes('build') || instr.includes('pour') || instr.includes('top')) return 'Build';
      return null;
    };
    
    const COMMON_INGREDIENTS = [
      'Gin', 'Vodka', 'Rum', 'Tequila', 'Bourbon', 'Rye Whiskey', 'Scotch', 'Cognac', 'Mezcal',
      'Sweet Vermouth', 'Dry Vermouth', 'Campari', 'Aperol', 'Cointreau', 'Green Chartreuse',
      'Maraschino Liqueur', 'Simple Syrup', 'Honey Syrup', 'Agave', 'Angostura Bitters',
      'Orange Bitters', 'Lime Juice', 'Lemon Juice', 'Club Soda', 'Tonic Water'
    ];

    // ============ MAIN APP ============
    
    const App = () => {
      const [view, setView] = useState('browse');
      const [curatedDrinks, setCuratedDrinks] = useState([]);
      const [customDrinks, setCustomDrinks] = useState([]);
      const [barInventory, setBarInventory] = useState([]);
      const [savedDrinks, setSavedDrinks] = useState(new Set());
      const [favorites, setFavorites] = useState(new Set());
      const [wantToTry, setWantToTry] = useState(new Set());
      const [ratings, setRatings] = useState({});
      const [searchTerm, setSearchTerm] = useState('');
      const [loading, setLoading] = useState(true);
      const [selectedDrink, setSelectedDrink] = useState(null);
      const [showAddDrink, setShowAddDrink] = useState(false);
      const [showImportExport, setShowImportExport] = useState(false);
      const [filters, setFilters] = useState({
        spirits: [],
        methods: [],
        glasses: [],
        tags: []
      });
      const [sortBy, setSortBy] = useState('name');
      const [madeCounts, setMadeCounts] = useState({}); // Track how many times each recipe was made
      const [showConfirmDelete, setShowConfirmDelete] = useState(null);
      const [ingredientsDb, setIngredientsDb] = useState(null);
      const [showRecipesHub, setShowRecipesHub] = useState(false);
      const [showSettings, setShowSettings] = useState(false);
      const [showImportShared, setShowImportShared] = useState(false);
      const [sharedRecipeData, setSharedRecipeData] = useState(null);
      const [collections, setCollections] = useState([]);
      const [showShoppingList, setShowShoppingList] = useState(null);
      const [updateAvailable, setUpdateAvailable] = useState(false);
      const [waitingWorker, setWaitingWorker] = useState(null);
      const mainRef = useRef(null);
      const toast = useToast();

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape') {
            if (showConfirmDelete) setShowConfirmDelete(null);
            else if (selectedDrink) setSelectedDrink(null);
            else if (showAddDrink) setShowAddDrink(false);
            else if (showImportExport) setShowImportExport(false);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedDrink, showAddDrink, showImportExport, showConfirmDelete]);

      // Scroll to top on view change
      useEffect(() => {
        mainRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }, [view]);
      
      // Handle service worker updates
      useEffect(() => {
        const handleUpdate = (e) => {
          setWaitingWorker(e.detail);
          setUpdateAvailable(true);
        };
        
        window.addEventListener('sw-update', handleUpdate);
        
        // Check if there's a waiting worker on load
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.ready.then(registration => {
            if (registration.waiting) {
              setWaitingWorker(registration.waiting);
              setUpdateAvailable(true);
            }
          });
        }
        
        return () => window.removeEventListener('sw-update', handleUpdate);
      }, []);
      
      const reloadForUpdate = () => {
        if (waitingWorker) {
          waitingWorker.postMessage({ type: 'SKIP_WAITING' });
          waitingWorker.addEventListener('statechange', () => {
            if (waitingWorker.state === 'activated') {
              window.location.reload();
            }
          });
        } else {
          window.location.reload();
        }
      };

      // Load data
      useEffect(() => {
        loadCuratedCocktails();
        loadIngredientsDb();
        loadUserData();
      }, []);

      const loadCuratedCocktails = async () => {
        try {
          const response = await fetch('./cocktails.json');
          const data = await response.json();
          setCuratedDrinks(data);
        } catch (error) {
          console.error('Failed to load cocktails:', error);
        }
        setLoading(false);
      };

      const loadIngredientsDb = async () => {
        try {
          const response = await fetch('./ingredients.json');
          const data = await response.json();
          setIngredientsDb(data);
          // Build alias map when ingredients DB loads
          buildIngredientAliasMap(data);
        } catch (error) {
          console.error('Failed to load ingredients:', error);
        }
      };

      const loadUserData = () => {
        try {
          const custom = storage.get('custom-drinks');
          const inv = storage.get('bar-inventory');
          const saved = storage.get('saved-drinks');
          const fav = storage.get('favorites');
          const tryList = storage.get('want-to-try');
          const rate = storage.get('ratings');
          const coll = storage.get('collections');
          const made = storage.get('made-counts');
          if (custom?.value) setCustomDrinks(JSON.parse(custom.value));
          if (inv?.value) {
            const inventory = JSON.parse(inv.value);
            setBarInventory(inventory);
          }
          if (saved?.value) setSavedDrinks(new Set(JSON.parse(saved.value)));
          if (fav?.value) setFavorites(new Set(JSON.parse(fav.value)));
          if (tryList?.value) setWantToTry(new Set(JSON.parse(tryList.value)));
          if (rate?.value) setRatings(JSON.parse(rate.value));
          if (coll?.value) {
            // Only load personal collections (curated are system-defined)
            const loaded = JSON.parse(coll.value);
            setCollections(loaded.filter(c => !c.collectionType || c.collectionType === 'personal'));
          }
          if (made?.value) setMadeCounts(JSON.parse(made.value));
        } catch { }
      };
      
      // Save filters and sort per view
      useEffect(() => {
        if (view && (view === 'browse' || view === 'saved' || view === 'favorites' || view === 'canMake' || view === 'almostMake' || view === 'custom')) {
          storage.set(`filters-${view}`, JSON.stringify(filters));
          storage.set(`sort-${view}`, sortBy);
        }
      }, [filters, sortBy, view]);

      const saveData = (key, data) => storage.set(key, JSON.stringify(data));

      // Automatic daily backup
      const performAutomaticBackup = () => {
        try {
          const backup = {
            schema: 'barkeep-v1',
            version: '1.0.0',
            exportDate: new Date().toISOString(),
            data: {
              customDrinks,
              barInventory,
              savedDrinks: Array.from(savedDrinks),
              favorites: Array.from(favorites),
              wantToTry: Array.from(wantToTry),
              ratings,
              collections,
              madeCounts
            }
          };
          
          const backups = JSON.parse(storage.get('auto-backups')?.value || '[]');
          backups.push(backup);
          
          // Keep only last 7 backups
          const trimmed = backups.slice(-7);
          
          storage.set('auto-backups', JSON.stringify(trimmed));
          storage.set('last-backup-date', new Date().toISOString().split('T')[0]);
        } catch (err) {
          console.error('Auto backup failed:', err);
        }
      };
      
      // Check if backup is needed (daily) - run after data loads
      useEffect(() => {
        if (loading) return; // Wait for data to load
        
        const today = new Date().toISOString().split('T')[0];
        const lastBackup = storage.get('last-backup-date')?.value;
        
        if (lastBackup !== today) {
          // Perform backup after a short delay to ensure all data is loaded
          const timer = setTimeout(() => {
            performAutomaticBackup();
          }, 3000);
          return () => clearTimeout(timer);
        }
      }, [loading]); // Run when data finishes loading
      
      // Export everything
      const exportEverything = () => {
        const data = {
          schema: 'barkeep-v1',
          version: '1.0.0',
          exportDate: new Date().toISOString(),
          data: {
            customDrinks,
            barInventory,
            savedDrinks: Array.from(savedDrinks),
            favorites: Array.from(favorites),
            wantToTry: Array.from(wantToTry),
            ratings,
            collections,
            madeCounts
          }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `barkeep-full-backup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        toast('Full backup downloaded', 'success');
      };

      const importEverything = (event, mergeMode = false) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            
            // Handle both old format and new format
            const data = imported.data || imported;
            
            if (mergeMode) {
              // Merge mode: combine with existing data
              if (data.customDrinks) {
                const merged = [...customDrinks, ...data.customDrinks.filter(d => !customDrinks.some(existing => existing.id === d.id))];
                setCustomDrinks(merged);
                saveData('custom-drinks', merged);
              }
              if (data.barInventory) {
                const existingIds = new Set(barInventory.map(i => i.id));
                const merged = [...barInventory, ...data.barInventory.filter(i => !existingIds.has(i.id))];
                setBarInventory(merged);
                saveData('bar-inventory', merged);
              }
              if (data.savedDrinks) {
                const merged = new Set([...savedDrinks, ...data.savedDrinks]);
                setSavedDrinks(merged);
                saveData('saved-drinks', Array.from(merged));
              }
              if (data.favorites) {
                const merged = new Set([...favorites, ...data.favorites]);
                setFavorites(merged);
                saveData('favorites', Array.from(merged));
              }
              if (data.wantToTry) {
                const merged = new Set([...wantToTry, ...data.wantToTry]);
                setWantToTry(merged);
                saveData('want-to-try', Array.from(merged));
              }
              if (data.ratings) {
                const merged = { ...ratings, ...data.ratings };
                setRatings(merged);
                saveData('ratings', merged);
              }
              if (data.collections) {
                const merged = [...collections, ...data.collections.filter(c => !collections.some(existing => existing.id === c.id))];
                setCollections(merged);
                saveData('collections', merged);
              }
              if (data.madeCounts) {
                const merged = { ...madeCounts, ...data.madeCounts };
                setMadeCounts(merged);
                saveData('made-counts', merged);
              }
              toast('Data merged successfully', 'success');
            } else {
              // Replace mode: overwrite existing data
              if (data.customDrinks) { setCustomDrinks(data.customDrinks); saveData('custom-drinks', data.customDrinks); }
              if (data.barInventory) { setBarInventory(data.barInventory); saveData('bar-inventory', data.barInventory); }
              if (data.savedDrinks) { setSavedDrinks(new Set(data.savedDrinks)); saveData('saved-drinks', data.savedDrinks); }
              if (data.favorites) { setFavorites(new Set(data.favorites)); saveData('favorites', data.favorites); }
              if (data.wantToTry) { setWantToTry(new Set(data.wantToTry)); saveData('want-to-try', data.wantToTry); }
              if (data.ratings) { setRatings(data.ratings); saveData('ratings', data.ratings); }
              if (data.collections) { setCollections(data.collections); saveData('collections', data.collections); }
              if (data.madeCounts) { setMadeCounts(data.madeCounts); saveData('made-counts', data.madeCounts); }
              toast('Data replaced successfully', 'success');
            }
            
            // Reload to refresh UI
            loadUserData();
          } catch (err) {
            console.error('Import error:', err);
            toast('Failed to import data', 'error');
          }
        };
        reader.readAsText(file);
      };

      // Helpers
      const getAllDrinks = () => [...curatedDrinks.map(d => ({...d, source: 'curated'})), ...customDrinks.map(d => ({...d, source: 'custom'}))];

      const detectSpirit = (drink) => {
        const ings = drink.ingredients?.map(i => i.name.toLowerCase()).join(' ') || '';
        if (ings.includes('gin')) return 'Gin';
        if (ings.includes('vodka')) return 'Vodka';
        if (ings.match(/whiskey|whisky|bourbon|rye|scotch/)) return 'Whiskey';
        if (ings.includes('rum')) return 'Rum';
        if (ings.match(/tequila|mezcal/)) return 'Tequila';
        if (ings.match(/brandy|cognac/)) return 'Brandy';
        return 'Other';
      };

      const canMakeDrink = (drink) => {
        if (!drink.ingredients?.length) return false;
        const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
        return drink.ingredients.every(ing => {
          const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
          return invCanonical.has(ingCanonical);
        });
      };

      const getMissingCount = (drink) => {
        if (!drink.ingredients?.length) return 0;
        const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
        return drink.ingredients.filter(ing => {
          const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
          return !invCanonical.has(ingCanonical);
        }).length;
      };

      const getMakeableDrinks = () => getAllDrinks().filter(canMakeDrink);

      // Actions with toast feedback
      const toggle = (set, setFn, key, id, addMsg, removeMsg) => {
        const newSet = new Set(set);
        const wasAdded = !newSet.has(id);
        wasAdded ? newSet.add(id) : newSet.delete(id);
        setFn(newSet);
        saveData(key, Array.from(newSet));
        if (addMsg && removeMsg) toast(wasAdded ? addMsg : removeMsg, 'success');
      };

      const rateDrink = (id, r) => {
        const newRatings = { ...ratings, [id]: r };
        setRatings(newRatings);
        saveData('ratings', newRatings);
      };

      const addCustomDrink = (drink) => {
        const newDrink = { id: `custom-${Date.now()}`, ...drink, dateAdded: new Date().toISOString() };
        const updated = [...customDrinks, newDrink];
        setCustomDrinks(updated);
        saveData('custom-drinks', updated);
        setShowAddDrink(false);
        toast('Recipe saved', 'success');
      };

      const deleteCustomDrink = (id) => {
        const updated = customDrinks.filter(d => d.id !== id);
        setCustomDrinks(updated);
        saveData('custom-drinks', updated);
        // Remove from collections
        const updatedCollections = collections.map(coll => ({
          ...coll,
          recipeIds: coll.recipeIds.filter(rid => rid !== id)
        }));
        setCollections(updatedCollections);
        saveData('collections', updatedCollections);
        setSelectedDrink(null);
        setShowConfirmDelete(null);
        toast('Recipe deleted', 'success');
      };

      // Share recipe
      const shareRecipe = async (drink) => {
        const sharePayload = {
          schema: 'barkeep-recipe-v1',
          createdAt: new Date().toISOString(),
          recipe: {
            id: drink.id,
            name: drink.name,
            category: drink.category,
            glass: drink.glass,
            ingredients: drink.ingredients,
            instructions: drink.instructions,
            notes: drink.notes,
            image: drink.image,
            source: drink.source,
            // Origin fields (optional)
            originTitle: drink.originTitle,
            originAuthor: drink.originAuthor,
            originSourceType: drink.originSourceType,
            originUrl: drink.originUrl,
            originYear: drink.originYear,
            originNotes: drink.originNotes
          }
        };
        
        const shareText = `${drink.name}\n\nIngredients:\n${drink.ingredients?.map(i => `• ${i.measure} ${i.name}`).join('\n')}\n\n${drink.instructions || ''}\n\n---\nShared from Barkeep\n\n${JSON.stringify(sharePayload, null, 2)}`;
        
        // Try Web Share API first
        if (navigator.share) {
          try {
            await navigator.share({
              title: drink.name,
              text: shareText,
              url: window.location.href
            });
            toast('Recipe shared', 'success');
            return;
          } catch (err) {
            if (err.name !== 'AbortError') {
              // Fall through to clipboard
            }
          }
        }
        
        // Fallback to clipboard
        try {
          await navigator.clipboard.writeText(shareText);
          toast('Recipe copied to clipboard', 'success');
        } catch (err) {
          // Final fallback: show data for manual copy
          setSharedRecipeData(sharePayload);
          toast('Share data prepared', 'success');
        }
      };

      // Import shared recipe
      const importSharedRecipe = (sharedData, dedupeMode = 'new') => {
        try {
          if (!sharedData.recipe) {
            toast('Invalid recipe data', 'error');
            return;
          }
          
          const recipe = sharedData.recipe;
          const existingIndex = customDrinks.findIndex(d => d.id === recipe.id);
          
          // Preserve origin fields if they exist
          const recipeWithOrigin = {
            ...recipe,
            originTitle: recipe.originTitle,
            originAuthor: recipe.originAuthor,
            originSourceType: recipe.originSourceType,
            originUrl: recipe.originUrl,
            originYear: recipe.originYear,
            originNotes: recipe.originNotes
          };
          
          if (existingIndex !== -1 && dedupeMode === 'replace') {
            // Replace existing
            const updated = [...customDrinks];
            updated[existingIndex] = { ...recipeWithOrigin, dateAdded: customDrinks[existingIndex].dateAdded || new Date().toISOString() };
            setCustomDrinks(updated);
            saveData('custom-drinks', updated);
            toast('Recipe replaced', 'success');
          } else {
            // Add as new (or if doesn't exist)
            const newId = existingIndex !== -1 ? `custom-${Date.now()}` : recipe.id;
            const newDrink = { ...recipeWithOrigin, id: newId, dateAdded: new Date().toISOString(), source: 'custom' };
            const updated = [...customDrinks, newDrink];
            setCustomDrinks(updated);
            saveData('custom-drinks', updated);
            toast('Recipe imported', 'success');
          }
          
          setShowImportShared(false);
          setSharedRecipeData(null);
        } catch (err) {
          toast('Failed to import recipe', 'error');
        }
      };

      // Curated collections (rule-based, system collections)
      const CURATED_COLLECTIONS = [
        {
          id: 'curated-classics',
          name: 'Classics',
          description: 'Time-tested cocktails that every bartender should know',
          collectionType: 'curated',
          rules: {
            style: ['spirit-forward', 'sour']
          }
        },
        {
          id: 'curated-no-citrus',
          name: 'No Citrus',
          description: 'Cocktails without lemon, lime, or other citrus',
          collectionType: 'curated',
          rules: {
            hasCitrus: false
          }
        },
        {
          id: 'curated-stirred',
          name: 'Stirred',
          description: 'Cocktails that are stirred, not shaken',
          collectionType: 'curated',
          rules: {
            method: ['Stir']
          }
        },
        {
          id: 'curated-shaken',
          name: 'Shaken',
          description: 'Cocktails that are shaken',
          collectionType: 'curated',
          rules: {
            method: ['Shake']
          }
        },
        {
          id: 'curated-gin',
          name: 'Gin Cocktails',
          description: 'All cocktails featuring gin',
          collectionType: 'curated',
          rules: {
            baseSpirit: ['Gin']
          }
        },
        {
          id: 'curated-whiskey',
          name: 'Whiskey Cocktails',
          description: 'All cocktails featuring whiskey',
          collectionType: 'curated',
          rules: {
            baseSpirit: ['Whiskey']
          }
        },
        {
          id: 'curated-tiki',
          name: 'Tiki',
          description: 'Tropical and tiki-style cocktails',
          collectionType: 'curated',
          rules: {
            category: ['Tiki']
          }
        },
        {
          id: 'curated-coupes',
          name: 'Coupes & Cocktail Glasses',
          description: 'Cocktails served in coupes or cocktail glasses',
          collectionType: 'curated',
          rules: {
            glass: ['Coupe', 'Cocktail glass']
          }
        }
      ];

      // Evaluate if a drink matches curated collection rules
      const matchesCuratedCollection = (drink, collection) => {
        if (!collection.rules) return false;
        const rules = collection.rules;
        
        // Base spirit rule
        if (rules.baseSpirit && rules.baseSpirit.length > 0) {
          const spirit = detectSpirit(drink);
          if (!rules.baseSpirit.includes(spirit)) return false;
        }
        
        // Method rule
        if (rules.method && rules.method.length > 0) {
          const method = detectMethod(drink);
          if (!method || !rules.method.includes(method)) return false;
        }
        
        // Glass rule
        if (rules.glass && rules.glass.length > 0) {
          if (!drink.glass || !rules.glass.includes(drink.glass)) return false;
        }
        
        // Style rule
        if (rules.style && rules.style.length > 0) {
          const drinkStyle = drink.style?.toLowerCase();
          if (!drinkStyle || !rules.style.some(s => drinkStyle.includes(s.toLowerCase()))) return false;
        }
        
        // Category rule
        if (rules.category && rules.category.length > 0) {
          if (!drink.category || !rules.category.includes(drink.category)) return false;
        }
        
        // Has citrus rule
        if (rules.hasCitrus !== undefined) {
          const hasCitrus = drink.ingredients?.some(ing => {
            const name = ing.name.toLowerCase();
            return name.includes('lemon') || name.includes('lime') || name.includes('orange') || 
                   name.includes('grapefruit') || name.includes('citrus') || name.includes('juice');
          });
          if (rules.hasCitrus !== hasCitrus) return false;
        }
        
        // Tags rule (check if drink has any of the specified tags)
        if (rules.tags && rules.tags.length > 0) {
          // For now, tags rule is optional - if drink has tags, check them
          // Otherwise, skip this check (allows drinks without tags to match)
          const drinkTags = drink.tags || [];
          if (drinkTags.length > 0) {
            const hasMatchingTag = rules.tags.some(tag => drinkTags.includes(tag));
            if (!hasMatchingTag) return false;
          }
        }
        
        return true;
      };

      // Get all collections (curated + personal)
      const getAllCollections = useMemo(() => {
        const personal = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
        return [...CURATED_COLLECTIONS, ...personal];
      }, [collections]);

      // Get recipes for a collection (rule-based for curated, recipeIds for personal)
      const getCollectionRecipes = useMemo(() => {
        return (collection) => {
          if (collection.collectionType === 'curated') {
            // Evaluate rules live
            return getAllDrinks().filter(drink => matchesCuratedCollection(drink, collection));
          } else {
            // Personal collection - use recipeIds
            return getAllDrinks().filter(d => collection.recipeIds?.includes(d.id));
          }
        };
      }, [curatedDrinks, customDrinks]);

      // Collections CRUD
      const addCollection = (name, description = '') => {
        const newCollection = {
          id: `collection-${Date.now()}`,
          name,
          description,
          recipeIds: [],
          collectionType: 'personal',
          createdAt: new Date().toISOString()
        };
        const updated = [...collections, newCollection];
        setCollections(updated);
        saveData('collections', updated);
        toast('Collection created', 'success');
      };

      const updateCollection = (id, updates) => {
        const updated = collections.map(c => c.id === id ? { ...c, ...updates } : c);
        setCollections(updated);
        saveData('collections', updated);
      };

      const deleteCollection = (id) => {
        // Don't allow deleting curated collections
        const collection = collections.find(c => c.id === id);
        if (collection?.collectionType === 'curated') {
          toast('Cannot delete curated collections', 'error');
          return;
        }
        const updated = collections.filter(c => c.id !== id);
        setCollections(updated);
        saveData('collections', updated);
        toast('Collection deleted', 'success');
      };

      const addRecipeToCollection = (recipeId, collectionId) => {
        // Don't allow adding to curated collections manually
        const collection = collections.find(c => c.id === collectionId) || CURATED_COLLECTIONS.find(c => c.id === collectionId);
        if (collection?.collectionType === 'curated') {
          toast('Curated collections update automatically', 'error');
          return;
        }
        const updated = collections.map(c => {
          if (c.id === collectionId && !c.recipeIds.includes(recipeId)) {
            return { ...c, recipeIds: [...c.recipeIds, recipeId] };
          }
          return c;
        });
        setCollections(updated);
        saveData('collections', updated);
        toast('Added to collection', 'success');
      };

      const removeRecipeFromCollection = (recipeId, collectionId) => {
        const updated = collections.map(c => {
          if (c.id === collectionId) {
            return { ...c, recipeIds: c.recipeIds.filter(id => id !== recipeId) };
          }
          return c;
        });
        setCollections(updated);
        saveData('collections', updated);
        toast('Removed from collection', 'success');
      };

      const addToInventory = (item) => {
        const canonicalName = normalizeIngredient(item, ingredientsDb);
        if (barInventory.some(i => normalizeIngredient(i.name, ingredientsDb) === canonicalName)) {
          toast('Already in your bar', 'error');
          return;
        }
        // Store with original casing for display, but matching uses canonical name
        const updated = [...barInventory, { id: Date.now(), name: item }];
        setBarInventory(updated);
        saveData('bar-inventory', updated);
        toast(`Added ${item}`, 'success');
      };

      const removeFromInventory = (id) => {
        const updated = barInventory.filter(i => i.id !== id);
        setBarInventory(updated);
        saveData('bar-inventory', updated);
      };

      // Random cocktail
      const pickRandom = () => {
        const drinks = displayDrinks;
        if (drinks.length === 0) return;
        const random = drinks[Math.floor(Math.random() * drinks.length)];
        setSelectedDrink(random);
      };

      // Filtered & sorted drinks
      const displayDrinks = useMemo(() => {
        let drinks = getAllDrinks();
        
        if (view === 'saved') drinks = drinks.filter(d => savedDrinks.has(d.id));
        else if (view === 'favorites') drinks = drinks.filter(d => favorites.has(d.id));
        else if (view === 'wantToTry') drinks = drinks.filter(d => wantToTry.has(d.id));
        else if (view === 'canMake') drinks = drinks.filter(d => canMakeDrink(d));
        else if (view === 'almostMake') drinks = drinks.filter(d => {
          const missing = getMissingCount(d);
          return missing > 0 && missing <= 2 && !canMakeDrink(d);
        });
        else if (view === 'custom') drinks = drinks.filter(d => d.source === 'custom');
        
        if (searchTerm.trim()) {
          const term = searchTerm.toLowerCase();
          drinks = drinks.filter(d => d.name.toLowerCase().includes(term) || d.ingredients?.some(i => i.name.toLowerCase().includes(term)));
        }
        
        // Apply multi-filters
        if (filters.spirits.length > 0) {
          drinks = drinks.filter(d => filters.spirits.includes(detectSpirit(d)));
        }
        
        if (filters.methods.length > 0) {
          drinks = drinks.filter(d => {
            const method = detectMethod(d);
            return method && filters.methods.includes(method);
          });
        }
        
        if (filters.glasses.length > 0) {
          drinks = drinks.filter(d => d.glass && filters.glasses.includes(d.glass));
        }
        
        if (filters.tags.includes('canMake')) {
          drinks = drinks.filter(d => canMakeDrink(d));
        }
        if (filters.tags.includes('almostMake')) {
          drinks = drinks.filter(d => {
            const missing = getMissingCount(d);
            return missing > 0 && missing <= 2 && !canMakeDrink(d);
          });
        }
        
        // Sort
        drinks = [...drinks].sort((a, b) => {
          if (sortBy === 'rating') return (ratings[b.id] || 0) - (ratings[a.id] || 0);
          if (sortBy === 'newest') {
            const aDate = a.dateAdded ? new Date(a.dateAdded) : new Date(0);
            const bDate = b.dateAdded ? new Date(b.dateAdded) : new Date(0);
            return bDate - aDate;
          }
          if (sortBy === 'most-made') {
            return (madeCounts[b.id] || 0) - (madeCounts[a.id] || 0);
          }
          if (sortBy === 'ingredients') return (a.ingredients?.length || 0) - (b.ingredients?.length || 0);
          return a.name.localeCompare(b.name);
        });
        
        return drinks;
      }, [view, curatedDrinks, customDrinks, savedDrinks, favorites, wantToTry, barInventory, ingredientsDb, searchTerm, filters, sortBy, ratings, madeCounts]);
      
      const toggleFilter = (category, value) => {
        setFilters(prev => {
          const newFilters = { ...prev };
          if (newFilters[category].includes(value)) {
            newFilters[category] = newFilters[category].filter(v => v !== value);
          } else {
            newFilters[category] = [...newFilters[category], value];
          }
          return newFilters;
        });
      };
      
      const clearFilters = () => {
        setFilters({ spirits: [], methods: [], glasses: [], tags: [] });
        setSearchTerm('');
      };
      
      const hasActiveFilters = filters.spirits.length > 0 || filters.methods.length > 0 || filters.glasses.length > 0 || filters.tags.length > 0 || searchTerm.trim();
      
      // Get unique glass types from all drinks
      const availableGlasses = useMemo(() => {
        const glassesSet = new Set();
        const allDrinks = [...curatedDrinks.map(d => ({...d, source: 'curated'})), ...customDrinks.map(d => ({...d, source: 'custom'}))];
        allDrinks.forEach(drink => {
          if (drink.glass) glassesSet.add(drink.glass);
        });
        return Array.from(glassesSet).sort();
      }, [curatedDrinks, customDrinks]);

      const getAlmostMakeCount = () => {
        return getAllDrinks().filter(d => {
          const missing = getMissingCount(d);
          return missing > 0 && missing <= 2 && !canMakeDrink(d);
        }).length;
      };

      const navItems = [
        { id: 'recipes', label: 'Recipes', icon: 'LayoutGrid' },
        { id: 'inventory', label: 'Bar', icon: 'Wine', count: barInventory.length },
        { id: 'search', label: 'Search', icon: 'Search' },
        { id: 'settings', label: 'Settings', icon: 'Settings' },
      ];

      return (
        <div className="min-h-screen flex flex-col pb-16 sm:pb-0">
          {/* Desktop Header */}
          <header className="hidden sm:block sticky top-0 z-40 bg-ink-950/95 backdrop-blur-sm border-b border-white/[0.03]">
            <div className="max-w-6xl mx-auto px-6">
              <div className="flex items-center justify-between h-16">
                <h1 className="font-display text-2xl font-light tracking-wide text-cream">Barkeep</h1>
                <div className="flex items-center gap-1">
                  {(view === 'browse' || view === 'saved' || view === 'favorites' || view === 'canMake' || view === 'almostMake' || view === 'wantToTry' || view === 'custom') && (
                    <button onClick={() => setShowAddDrink(true)} className="p-2.5 text-ink-500 hover:text-copper btn-ghost rounded-lg" title="New Recipe">
                      <Icon name="Plus" className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </div>
              {(view !== 'recipesHub' && view !== 'settings') && (
                <nav className="flex gap-1 pb-3">
                  {navItems.map(item => (
                    <button
                      key={item.id}
                      onClick={() => {
                        if (item.id === 'recipes') {
                          setView('recipesHub');
                          setShowRecipesHub(true);
                        } else if (item.id === 'search') {
                          setView('browse');
                          setSearchTerm('');
                          setShowRecipesHub(false);
                        } else {
                          setView(item.id);
                          setShowRecipesHub(false);
                        }
                      }}
                      className={`flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-light transition-all ${
                        (view === item.id || (item.id === 'recipes' && showRecipesHub) || (item.id === 'search' && view === 'browse')) ? 'bg-white/[0.05] text-cream' : 'text-ink-500 hover:text-ink-300 hover:bg-white/[0.02]'
                      }`}
                    >
                      <Icon name={item.icon} className="w-4 h-4" />
                      <span>{item.label}</span>
                      {item.count > 0 && (
                        <span className={`text-2xs px-1.5 py-0.5 rounded-full ${view === item.id ? 'bg-copper/20 text-copper' : 'bg-white/5 text-ink-500'}`}>
                          {item.count}
                        </span>
                      )}
                    </button>
                  ))}
                </nav>
              )}
            </div>
          </header>

          {/* Mobile Header */}
          <header className="sm:hidden sticky top-0 z-40 bg-ink-950/95 backdrop-blur-sm border-b border-white/[0.03]">
            <div className="flex items-center justify-between px-4 h-14">
              {(view === 'recipesHub' || view === 'settings' || view === 'inventory') ? (
                <h1 className="font-display text-xl font-light text-cream">Barkeep</h1>
              ) : (
                <button onClick={() => {
                  setView('recipesHub');
                  setShowRecipesHub(true);
                }} className="flex items-center gap-2 text-cream">
                  <Icon name="ArrowLeft" className="w-5 h-5" />
                  <span className="font-display text-xl font-light">Recipes</span>
                </button>
              )}
              <div className="flex items-center gap-1">
                {(view === 'browse' || view === 'saved' || view === 'favorites' || view === 'canMake' || view === 'almostMake' || view === 'wantToTry' || view === 'custom') && (
                  <button onClick={() => setShowAddDrink(true)} className="p-2 text-copper">
                    <Icon name="Plus" className="w-5 h-5" />
                  </button>
                )}
              </div>
            </div>
          </header>

          {/* Main Content */}
          <main ref={mainRef} className="flex-1 max-w-6xl mx-auto w-full px-4 sm:px-6 py-4 sm:py-6">
            {view === 'recipesHub' || (view === 'recipes' && showRecipesHub) ? (
              <RecipesHub
                savedCount={savedDrinks.size}
                favoritesCount={favorites.size}
                canMakeCount={getMakeableDrinks().length}
                almostMakeCount={getAlmostMakeCount()}
                wantToTryCount={wantToTry.size}
                customCount={customDrinks.length}
                allCount={getAllDrinks().length}
                collectionsCount={getAllCollections.length}
                onNavigate={(viewId) => {
                  setView(viewId);
                  setShowRecipesHub(false);
                }}
              />
            ) : view === 'inventory' ? (
              <InventoryView inventory={barInventory} onAdd={addToInventory} onRemove={removeFromInventory} ingredientsDb={ingredientsDb} />
            ) : view === 'settings' ? (
              <SettingsView
                onClose={() => setView('browse')}
                onExport={exportEverything}
                onImport={importEverything}
                unmatchedIngredients={Array.from(unmatchedIngredients)}
                onImportShared={() => setShowImportShared(true)}
              />
            ) : view === 'collections' ? (
              <CollectionsView
                collections={getAllCollections}
                allDrinks={getAllDrinks()}
                getCollectionRecipes={getCollectionRecipes}
                onAddCollection={addCollection}
                onUpdateCollection={updateCollection}
                onDeleteCollection={deleteCollection}
                onRemoveRecipe={removeRecipeFromCollection}
                onNavigate={(collectionId) => setView(`collection-${collectionId}`)}
                onNavigateToRecipe={(drink) => setSelectedDrink(drink)}
              />
            ) : view?.startsWith('collection-') ? (
              <CollectionDetailView
                collection={getAllCollections.find(c => c.id === view.replace('collection-', ''))}
                allDrinks={getAllDrinks()}
                getCollectionRecipes={getCollectionRecipes}
                onNavigateBack={() => setView('collections')}
                onNavigateToRecipe={(drink) => setSelectedDrink(drink)}
                onRemoveRecipe={removeRecipeFromCollection}
              />
            ) : (
              <>
                {/* Search & Filters */}
                <div className="flex flex-col gap-3 mb-5">
                  <div className="flex gap-2">
                    <div className="flex-1 relative">
                      <Icon name="Search" className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-ink-600" />
                      <input
                        type="text"
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        placeholder="Search recipes or ingredients..."
                        className="w-full pl-10 pr-10 py-3 input-field rounded-lg text-sm text-ink-200 font-light"
                      />
                      {searchTerm && (
                        <button onClick={() => setSearchTerm('')} className="absolute right-3 top-1/2 -translate-y-1/2 text-ink-600 hover:text-ink-400">
                          <Icon name="X" className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                    <button
                      onClick={pickRandom}
                      className="px-3 py-3 input-field rounded-lg text-ink-500 hover:text-copper hover:border-copper/30 transition-colors"
                      title="Random cocktail"
                    >
                      <Icon name="Shuffle" className="w-4 h-4" />
                    </button>
                  </div>
                  
                  {/* Filter Chips */}
                  <div className="space-y-3">
                    {/* Spirits */}
                    <div className="flex flex-wrap gap-1.5">
                      <span className="text-2xs text-ink-600 uppercase tracking-wider self-center mr-1">Spirit:</span>
                      {SPIRIT_CATEGORIES.map(spirit => (
                        <button
                          key={spirit}
                          onClick={() => toggleFilter('spirits', spirit)}
                          className={`px-3 py-1.5 rounded-lg text-xs font-light transition-colors whitespace-nowrap ${
                            filters.spirits.includes(spirit)
                              ? 'bg-copper/20 text-copper border border-copper/30'
                              : 'bg-white/[0.02] text-ink-400 hover:bg-white/[0.05] border border-white/[0.06]'
                          }`}
                        >
                          {spirit}
                        </button>
                      ))}
                    </div>
                    
                    {/* Methods */}
                    <div className="flex flex-wrap gap-1.5">
                      <span className="text-2xs text-ink-600 uppercase tracking-wider self-center mr-1">Method:</span>
                      {METHOD_OPTIONS.map(method => (
                        <button
                          key={method}
                          onClick={() => toggleFilter('methods', method)}
                          className={`px-3 py-1.5 rounded-lg text-xs font-light transition-colors whitespace-nowrap ${
                            filters.methods.includes(method)
                              ? 'bg-copper/20 text-copper border border-copper/30'
                              : 'bg-white/[0.02] text-ink-400 hover:bg-white/[0.05] border border-white/[0.06]'
                          }`}
                        >
                          {method}
                        </button>
                      ))}
                    </div>
                    
                    {/* Glasses */}
                    {availableGlasses.length > 0 && (
                      <div className="flex flex-wrap gap-1.5">
                        <span className="text-2xs text-ink-600 uppercase tracking-wider self-center mr-1">Glass:</span>
                        {availableGlasses.slice(0, 8).map(glass => (
                          <button
                            key={glass}
                            onClick={() => toggleFilter('glasses', glass)}
                            className={`px-3 py-1.5 rounded-lg text-xs font-light transition-colors whitespace-nowrap ${
                              filters.glasses.includes(glass)
                                ? 'bg-copper/20 text-copper border border-copper/30'
                                : 'bg-white/[0.02] text-ink-400 hover:bg-white/[0.05] border border-white/[0.06]'
                            }`}
                          >
                            {glass}
                          </button>
                        ))}
                      </div>
                    )}
                    
                    {/* Tags */}
                    {(view === 'browse' || view === 'saved' || view === 'favorites' || view === 'custom') && (
                      <div className="flex flex-wrap gap-1.5">
                        <span className="text-2xs text-ink-600 uppercase tracking-wider self-center mr-1">Tags:</span>
                        <button
                          onClick={() => toggleFilter('tags', 'canMake')}
                          className={`px-3 py-1.5 rounded-lg text-xs font-light transition-colors whitespace-nowrap ${
                            filters.tags.includes('canMake')
                              ? 'bg-emerald-900/30 text-emerald-300 border border-emerald-900/50'
                              : 'bg-white/[0.02] text-ink-400 hover:bg-white/[0.05] border border-white/[0.06]'
                          }`}
                        >
                          Can Make
                        </button>
                        <button
                          onClick={() => toggleFilter('tags', 'almostMake')}
                          className={`px-3 py-1.5 rounded-lg text-xs font-light transition-colors whitespace-nowrap ${
                            filters.tags.includes('almostMake')
                              ? 'bg-amber-900/30 text-amber-300 border border-amber-900/50'
                              : 'bg-white/[0.02] text-ink-400 hover:bg-white/[0.05] border border-white/[0.06]'
                          }`}
                        >
                          Almost Make
                        </button>
                      </div>
                    )}
                    
                    {/* Sort & Clear */}
                    <div className="flex items-center gap-2 flex-wrap">
                      <span className="text-2xs text-ink-600 uppercase tracking-wider">Sort:</span>
                      <select
                        value={sortBy}
                        onChange={(e) => setSortBy(e.target.value)}
                        className="px-3 py-1.5 input-field rounded-lg text-xs text-ink-400 font-light bg-transparent appearance-none cursor-pointer"
                      >
                        {SORT_OPTIONS.map(opt => (
                          <option key={opt.value} value={opt.value} className="bg-ink-900">{opt.label}</option>
                        ))}
                      </select>
                      {hasActiveFilters && (
                        <button
                          onClick={clearFilters}
                          className="px-3 py-1.5 text-xs text-copper hover:text-copper-light whitespace-nowrap"
                        >
                          Clear all
                        </button>
                      )}
                    </div>
                  </div>
                </div>

                {/* Results info */}
                <div className="flex items-center justify-between mb-4">
                  <p className="text-xs text-ink-600 tracking-wide">
                    {displayDrinks.length} {displayDrinks.length === 1 ? 'recipe' : 'recipes'}
                    {hasActiveFilters && (
                      <span className="text-copper ml-1">
                        · {filters.spirits.length + filters.methods.length + filters.glasses.length + filters.tags.length} filter{filters.spirits.length + filters.methods.length + filters.glasses.length + filters.tags.length !== 1 ? 's' : ''}
                      </span>
                    )}
                  </p>
                  {view === 'almostMake' && displayDrinks.length > 0 && (
                    <button
                      onClick={() => {
                        // Create shopping list
                        const ingredientCounts = {};
                        displayDrinks.forEach(drink => {
                          const missing = drink.ingredients?.filter(ing => {
                            const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                            const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
                            return !invCanonical.has(ingCanonical);
                          }) || [];
                          
                          missing.forEach(ing => {
                            const key = normalizeIngredient(ing.name, ingredientsDb);
                            if (!ingredientCounts[key]) {
                              ingredientCounts[key] = { name: ing.name, count: 0, recipes: [] };
                            }
                            if (!ingredientCounts[key].recipes.find(r => r.id === drink.id)) {
                              ingredientCounts[key].count++;
                              ingredientCounts[key].recipes.push({ id: drink.id, name: drink.name });
                            }
                          });
                        });
                        
                        const shoppingList = Object.values(ingredientCounts)
                          .sort((a, b) => b.count - a.count)
                          .map(item => `${item.name} (unlocks ${item.count} ${item.count === 1 ? 'recipe' : 'recipes'})`)
                          .join('\n');
                        
                        // Try clipboard
                        navigator.clipboard.writeText(shoppingList).then(() => {
                          toast('Shopping list copied to clipboard', 'success');
                        }).catch(() => {
                          setShowShoppingList(shoppingList);
                        });
                      }}
                      className="px-4 py-2 btn-copper rounded-lg text-sm font-medium"
                    >
                      <Icon name="ShoppingCart" className="w-4 h-4 inline mr-2" />
                      <span>Create Shopping List</span>
                    </button>
                  )}
                </div>

                {/* Recipe Grid */}
                {loading ? (
                  <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {[...Array(6)].map((_, i) => (
                      <div key={i} className="card rounded-xl overflow-hidden animate-pulse">
                        <div className="h-40 bg-ink-800" />
                        <div className="p-4 space-y-2">
                          <div className="h-5 bg-ink-800 rounded w-3/4" />
                          <div className="h-3 bg-ink-800 rounded w-1/2" />
                        </div>
                      </div>
                    ))}
                  </div>
                ) : displayDrinks.length === 0 ? (
                  <EmptyState view={view} onAction={() => view === 'canMake' ? setView('inventory') : setShowAddDrink(true)} />
                ) : (
                  <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {displayDrinks.map((drink, i) => (
                      <RecipeCard
                        key={drink.id}
                        drink={drink}
                        rating={ratings[drink.id]}
                        isSaved={savedDrinks.has(drink.id)}
                        isFavorite={favorites.has(drink.id)}
                        canMake={canMakeDrink(drink)}
                        missingCount={getMissingCount(drink)}
                        onClick={() => setSelectedDrink(drink)}
                        onToggleSaved={() => toggle(savedDrinks, setSavedDrinks, 'saved-drinks', drink.id, 'Saved', 'Removed from saved')}
                        onToggleFavorite={() => toggle(favorites, setFavorites, 'favorites', drink.id, 'Added to favorites', 'Removed from favorites')}
                        className="stagger-item"
                      />
                    ))}
                  </div>
                )}
              </>
            )}
          </main>

          {/* Mobile Bottom Nav */}
          <nav className="sm:hidden fixed bottom-0 left-0 right-0 bg-ink-950/95 backdrop-blur-sm border-t border-white/[0.03] mobile-bottom-nav z-40">
            <div className="flex justify-around py-2">
              {navItems.map(item => (
                <button
                  key={item.id}
                  onClick={() => {
                    if (item.id === 'recipes') {
                      setView('recipesHub');
                      setShowRecipesHub(true);
                    } else if (item.id === 'search') {
                      setView('browse');
                      setSearchTerm('');
                    } else {
                      setView(item.id);
                      setShowRecipesHub(false);
                    }
                  }}
                  className={`relative flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-colors ${
                    (view === item.id || (item.id === 'recipes' && showRecipesHub) || (item.id === 'search' && view === 'browse')) ? 'text-copper' : 'text-ink-500'
                  }`}
                >
                  <Icon name={item.icon} className="w-5 h-5" />
                  <span className="text-2xs">{item.label}</span>
                  {item.count > 0 && view !== item.id && !showRecipesHub && (
                    <span className="absolute -top-1 right-1 w-1.5 h-1.5 bg-copper rounded-full" />
                  )}
                </button>
              ))}
            </div>
          </nav>
          
          {/* Update Available Banner */}
          {updateAvailable && (
            <div className="fixed bottom-16 sm:bottom-4 left-4 right-4 sm:left-auto sm:right-4 z-50 bg-copper text-ink-950 px-4 py-3 flex items-center justify-between rounded-lg shadow-xl animate-slide-up">
              <div className="flex items-center gap-3">
                <Icon name="RefreshCw" className="w-5 h-5" />
                <span className="text-sm font-medium">Update available</span>
              </div>
              <div className="flex items-center gap-2 ml-4">
                <button
                  onClick={reloadForUpdate}
                  className="px-4 py-2 bg-ink-950 text-cream rounded-lg text-sm font-medium hover:bg-ink-900 transition-colors"
                >
                  Refresh
                </button>
                <button
                  onClick={() => setUpdateAvailable(false)}
                  className="p-2 hover:bg-ink-950/20 rounded-lg transition-colors"
                >
                  <Icon name="X" className="w-4 h-4" />
                </button>
              </div>
            </div>
          )}

          {/* Modals */}
          {selectedDrink && (
            <RecipeDetail
              drink={selectedDrink}
              onClose={() => setSelectedDrink(null)}
              rating={ratings[selectedDrink.id]}
              isSaved={savedDrinks.has(selectedDrink.id)}
              isFavorite={favorites.has(selectedDrink.id)}
              isWantToTry={wantToTry.has(selectedDrink.id)}
              canMake={canMakeDrink(selectedDrink)}
              inventory={barInventory}
              ingredientsDb={ingredientsDb}
              collections={collections}
              onToggleSaved={() => toggle(savedDrinks, setSavedDrinks, 'saved-drinks', selectedDrink.id, 'Saved', 'Removed')}
              onToggleFavorite={() => toggle(favorites, setFavorites, 'favorites', selectedDrink.id, 'Favorited', 'Unfavorited')}
              onToggleWantToTry={() => toggle(wantToTry, setWantToTry, 'want-to-try', selectedDrink.id, 'Added to try list', 'Removed from try list')}
              onRate={(r) => rateDrink(selectedDrink.id, r)}
              onDelete={selectedDrink.source === 'custom' ? () => setShowConfirmDelete(selectedDrink.id) : null}
              onShare={shareRecipe}
              onAddToCollection={addRecipeToCollection}
            />
          )}

          {showAddDrink && <AddRecipeModal onClose={() => setShowAddDrink(false)} onAdd={addCustomDrink} ingredientsDb={ingredientsDb} />}
          
          {showImportShared && (
            <ImportSharedRecipeModal
              sharedData={sharedRecipeData}
              existingRecipes={customDrinks}
              onImport={importSharedRecipe}
              toast={toast}
              onClose={() => {
                setShowImportShared(false);
                setSharedRecipeData(null);
              }}
            />
          )}
          
          {showConfirmDelete && (
            <ConfirmDialog
              title="Delete Recipe"
              message="This will permanently delete this recipe. This cannot be undone."
              onConfirm={() => deleteCustomDrink(showConfirmDelete)}
              onCancel={() => setShowConfirmDelete(null)}
            />
          )}
          
          {showShoppingList && (
            <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in flex items-center justify-center p-4" onClick={() => setShowShoppingList(null)}>
              <div className="max-w-xl w-full card rounded-2xl p-6 animate-scale-in" onClick={e => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="font-display text-xl text-cream font-light">Shopping List</h2>
                  <button onClick={() => setShowShoppingList(null)} className="p-2 text-ink-500 hover:text-ink-300">
                    <Icon name="X" className="w-5 h-5" />
                  </button>
                </div>
                <textarea
                  value={showShoppingList}
                  readOnly
                  className="w-full h-64 px-4 py-3 input-field rounded-lg text-sm text-cream font-light resize-none mb-4 font-mono"
                />
                <div className="flex gap-3">
                  <button
                    onClick={() => {
                      navigator.clipboard.writeText(showShoppingList);
                      toast('Copied to clipboard', 'success');
                    }}
                    className="flex-1 py-3 btn-copper rounded-lg text-sm font-medium"
                  >
                    Copy to Clipboard
                  </button>
                  <button
                    onClick={() => {
                      const blob = new Blob([showShoppingList], { type: 'text/plain' });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = 'shopping-list.txt';
                      a.click();
                      URL.revokeObjectURL(url);
                      toast('Downloaded', 'success');
                    }}
                    className="px-4 py-3 text-ink-500 hover:text-ink-300 border border-white/[0.06] rounded-lg"
                  >
                    <Icon name="Download" className="w-4 h-4" />
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // ============ COMPONENTS ============

    const RecipesHub = ({ savedCount, favoritesCount, canMakeCount, almostMakeCount, wantToTryCount, customCount, allCount, collectionsCount, onNavigate }) => {
      const recipeItems = [
        { id: 'browse', label: 'All Recipes', icon: 'LayoutGrid', count: allCount, description: 'Browse all cocktails' },
        { id: 'canMake', label: 'Can Make', icon: 'Sparkles', count: canMakeCount, description: 'Ready to mix' },
        { id: 'almostMake', label: 'Almost Make', icon: 'Clock', count: almostMakeCount, description: '1–2 ingredients away' },
        { id: 'favorites', label: 'Favorites', icon: 'Heart', count: favoritesCount, description: 'Your favorites' },
        { id: 'saved', label: 'Saved', icon: 'Bookmark', count: savedCount, description: 'Saved recipes' },
        { id: 'wantToTry', label: 'Want to Try', icon: 'Star', count: wantToTryCount, description: 'On your list' },
        { id: 'custom', label: 'My Recipes', icon: 'FlaskConical', count: customCount, description: 'Your custom recipes' },
        { id: 'collections', label: 'Collections', icon: 'Folder', count: collectionsCount, description: 'Organize recipes' },
      ];

      return (
        <div className="animate-fade-in">
          <h2 className="font-display text-2xl text-cream font-light mb-6">Recipes</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
            {recipeItems.map(item => (
              <button
                key={item.id}
                onClick={() => onNavigate(item.id)}
                className="card rounded-xl p-4 text-left hover:border-white/[0.08] transition-all group"
              >
                <div className="flex items-start justify-between mb-2">
                  <div className="flex items-center gap-3">
                    <div className="p-2 rounded-lg bg-white/[0.03] group-hover:bg-copper/10 transition-colors">
                      <Icon name={item.icon} className="w-5 h-5 text-copper" />
                    </div>
                    <div>
                      <h3 className="font-display text-lg text-cream font-normal group-hover:text-copper-light transition-colors">
                        {item.label}
                      </h3>
                      <p className="text-2xs text-ink-500 mt-0.5">{item.description}</p>
                    </div>
                  </div>
                  {item.count > 0 && (
                    <span className="text-2xs px-2 py-1 rounded-full bg-copper/20 text-copper font-medium">
                      {item.count}
                    </span>
                  )}
                </div>
              </button>
            ))}
          </div>
        </div>
      );
    };

    const CollectionPicker = ({ collections, recipeId, onSelect, onClose }) => {
      // Only show personal collections (curated are auto-updating)
      const personalCollections = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
      const recipeCollections = personalCollections.filter(c => c.recipeIds?.includes(recipeId));
      
      return (
        <div className="absolute top-full left-0 right-0 mt-2 p-3 card-elevated rounded-xl z-50 animate-slide-down">
          <div className="flex items-center justify-between mb-3">
            <h4 className="text-sm text-cream font-light">Add to Collection</h4>
            <button onClick={onClose} className="p-1 text-ink-500 hover:text-ink-300">
              <Icon name="X" className="w-4 h-4" />
            </button>
          </div>
          <div className="space-y-1 max-h-48 overflow-y-auto">
            {personalCollections.length === 0 ? (
              <p className="text-xs text-ink-500 text-center py-4">No personal collections yet</p>
            ) : (
              personalCollections.map(coll => {
                const isInCollection = coll.recipeIds?.includes(recipeId);
                return (
                  <button
                    key={coll.id}
                    onClick={() => onSelect(coll.id)}
                    className={`w-full text-left px-3 py-2 rounded-lg transition-colors ${
                      isInCollection ? 'bg-copper/20 text-copper' : 'hover:bg-white/[0.05] text-ink-300'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <span className="text-sm">{coll.name}</span>
                      {isInCollection && <Icon name="Check" className="w-4 h-4" />}
                    </div>
                    {coll.description && (
                      <p className="text-2xs text-ink-500 mt-0.5">{coll.description}</p>
                    )}
                  </button>
                );
              })
            )}
          </div>
        </div>
      );
    };

    const ImportSharedRecipeModal = ({ sharedData, existingRecipes, onImport, onClose, toast }) => {
      const [dedupeMode, setDedupeMode] = useState('new');
      
      if (!sharedData) {
        // Allow pasting
        const [pasteValue, setPasteValue] = useState('');
        
        const handlePaste = () => {
          try {
            const data = JSON.parse(pasteValue);
            if (data.schema && data.recipe) {
              onImport(data, dedupeMode);
            } else {
              toast?.('Invalid recipe format', 'error');
            }
          } catch {
            toast?.('Invalid JSON', 'error');
          }
        };
        
        return (
          <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in flex items-center justify-center p-4" onClick={onClose}>
            <div className="max-w-xl w-full card rounded-2xl p-6 animate-scale-in" onClick={e => e.stopPropagation()}>
              <h2 className="font-display text-xl text-cream font-light mb-4">Import Shared Recipe</h2>
              <textarea
                value={pasteValue}
                onChange={(e) => setPasteValue(e.target.value)}
                placeholder="Paste recipe JSON here..."
                className="w-full h-48 px-4 py-3 input-field rounded-lg text-sm text-cream font-mono resize-none mb-4"
              />
              <div className="flex gap-3">
                <button onClick={handlePaste} className="flex-1 py-3 btn-copper rounded-lg text-sm font-medium">
                  Import Recipe
                </button>
                <button onClick={onClose} className="px-4 py-3 text-ink-500 hover:text-ink-300">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      }
      
      const recipe = sharedData.recipe;
      const existing = existingRecipes.find(r => r.id === recipe.id);
      
      return (
        <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen sm:py-8 sm:px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-2xl mx-auto bg-ink-950 sm:card sm:rounded-2xl animate-slide-up">
              <div className="p-6">
                <h2 className="font-display text-xl text-cream font-light mb-6">Import Recipe</h2>
                
                {/* Preview */}
                <div className="card rounded-xl p-5 mb-6">
                  <h3 className="font-display text-lg text-cream font-normal mb-2">{recipe.name}</h3>
                  {recipe.glass && <p className="text-sm text-ink-400 mb-4">{recipe.glass}</p>}
                  
                  <div className="mb-4">
                    <h4 className="text-2xs text-ink-500 uppercase tracking-widest mb-2">Ingredients</h4>
                    <ul className="space-y-1">
                      {recipe.ingredients?.map((ing, i) => (
                        <li key={i} className="text-sm text-ink-300">
                          {ing.measure} {ing.name}
                        </li>
                      ))}
                    </ul>
                  </div>
                  
                  {recipe.instructions && (
                    <div>
                      <h4 className="text-2xs text-ink-500 uppercase tracking-widest mb-2">Method</h4>
                      <p className="text-sm text-ink-300">{recipe.instructions}</p>
                    </div>
                  )}
                </div>
                
                {/* Dedupe option */}
                {existing && (
                  <div className="mb-6">
                    <p className="text-sm text-ink-400 mb-3">This recipe already exists in your collection:</p>
                    <div className="space-y-2">
                      <label className="flex items-center gap-3 p-3 card rounded-lg cursor-pointer">
                        <input
                          type="radio"
                          name="dedupe"
                          value="new"
                          checked={dedupeMode === 'new'}
                          onChange={(e) => setDedupeMode(e.target.value)}
                          className="text-copper"
                        />
                        <span className="text-sm text-ink-300">Save as new recipe</span>
                      </label>
                      <label className="flex items-center gap-3 p-3 card rounded-lg cursor-pointer">
                        <input
                          type="radio"
                          name="dedupe"
                          value="replace"
                          checked={dedupeMode === 'replace'}
                          onChange={(e) => setDedupeMode(e.target.value)}
                          className="text-copper"
                        />
                        <span className="text-sm text-ink-300">Replace existing recipe</span>
                      </label>
                    </div>
                  </div>
                )}
                
                <div className="flex gap-3">
                  <button
                    onClick={() => onImport(sharedData, dedupeMode)}
                    className="flex-1 py-3 btn-copper rounded-lg text-sm font-medium"
                  >
                    {existing ? (dedupeMode === 'replace' ? 'Replace Recipe' : 'Save as New') : 'Save to My Recipes'}
                  </button>
                  <button onClick={onClose} className="px-4 py-3 text-ink-500 hover:text-ink-300">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const CollectionsView = ({ collections, allDrinks, getCollectionRecipes, onAddCollection, onUpdateCollection, onDeleteCollection, onRemoveRecipe, onNavigate, onNavigateToRecipe }) => {
      const [showAddCollection, setShowAddCollection] = useState(false);
      const [editingId, setEditingId] = useState(null);
      const [newName, setNewName] = useState('');
      const [newDescription, setNewDescription] = useState('');
      
      const handleSave = () => {
        if (!newName.trim()) return;
        if (editingId) {
          onUpdateCollection(editingId, { name: newName, description: newDescription });
        } else {
          onAddCollection(newName, newDescription);
        }
        setShowAddCollection(false);
        setEditingId(null);
        setNewName('');
        setNewDescription('');
      };
      
      const startEdit = (coll) => {
        // Don't allow editing curated collections
        if (coll.collectionType === 'curated') {
          return;
        }
        setEditingId(coll.id);
        setNewName(coll.name);
        setNewDescription(coll.description || '');
        setShowAddCollection(true);
      };
      
      const curatedCollections = collections.filter(c => c.collectionType === 'curated');
      const personalCollections = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
      
      return (
        <div className="animate-fade-in">
          <div className="flex items-center justify-between mb-6">
            <h2 className="font-display text-2xl text-cream font-light">Collections</h2>
            <button
              onClick={() => {
                setEditingId(null);
                setNewName('');
                setNewDescription('');
                setShowAddCollection(true);
              }}
              className="px-4 py-2 btn-copper rounded-lg text-sm font-medium"
            >
              New Collection
            </button>
          </div>
          
          {showAddCollection && (
            <div className="card rounded-xl p-5 mb-6 animate-slide-down">
              <h3 className="font-display text-lg text-cream font-light mb-4">
                {editingId ? 'Edit Collection' : 'New Collection'}
              </h3>
              <div className="space-y-4">
                <div>
                  <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Name *</label>
                  <input
                    type="text"
                    value={newName}
                    onChange={(e) => setNewName(e.target.value)}
                    placeholder="Collection name"
                    className="w-full px-4 py-3 input-field rounded-lg text-cream font-light"
                    autoFocus
                  />
                </div>
                <div>
                  <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Description</label>
                  <textarea
                    value={newDescription}
                    onChange={(e) => setNewDescription(e.target.value)}
                    placeholder="Optional description"
                    rows="2"
                    className="w-full px-4 py-3 input-field rounded-lg text-cream font-light resize-none"
                  />
                </div>
                <div className="flex gap-3">
                  <button onClick={handleSave} className="flex-1 py-3 btn-copper rounded-lg text-sm font-medium">
                    Save
                  </button>
                  <button
                    onClick={() => {
                      setShowAddCollection(false);
                      setEditingId(null);
                      setNewName('');
                      setNewDescription('');
                    }}
                    className="px-4 py-3 text-ink-500 hover:text-ink-300"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* Curated Collections */}
          {curatedCollections.length > 0 && (
            <div className="mb-8">
              <div className="flex items-center gap-2 mb-4">
                <h3 className="text-sm text-ink-500 uppercase tracking-wider">Curated</h3>
                <span className="text-2xs text-ink-600">Auto-updating</span>
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {curatedCollections.map(coll => {
                  const recipeCount = getCollectionRecipes ? getCollectionRecipes(coll).length : 0;
                  return (
                    <div key={coll.id} className="card rounded-xl p-4 hover:border-white/[0.08] transition-all">
                      <div className="flex items-start justify-between mb-3">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <h3
                              className="font-display text-lg text-cream font-normal cursor-pointer hover:text-copper-light transition-colors"
                              onClick={() => onNavigate(coll.id)}
                            >
                              {coll.name}
                            </h3>
                            <span className="text-2xs px-1.5 py-0.5 rounded bg-copper/10 text-copper uppercase tracking-wider">Curated</span>
                          </div>
                          {coll.description && (
                            <p className="text-2xs text-ink-500 mb-2">{coll.description}</p>
                          )}
                          <p className="text-2xs text-ink-600">{recipeCount} {recipeCount === 1 ? 'recipe' : 'recipes'}</p>
                        </div>
                      </div>
                      <button
                        onClick={() => onNavigate(coll.id)}
                        className="w-full mt-3 py-2 text-sm text-copper hover:text-copper-light border border-copper/30 hover:border-copper/50 rounded-lg transition-colors"
                      >
                        View Collection
                      </button>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
          
          {/* Personal Collections */}
          <div>
            {curatedCollections.length > 0 && (
              <div className="flex items-center gap-2 mb-4">
                <h3 className="text-sm text-ink-500 uppercase tracking-wider">Yours</h3>
              </div>
            )}
            {personalCollections.length === 0 && curatedCollections.length === 0 ? (
              <div className="text-center py-16">
                <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-white/[0.02] flex items-center justify-center">
                  <Icon name="Folder" className="w-7 h-7 text-ink-700" />
                </div>
                <p className="text-ink-400 font-light">No collections yet</p>
                <p className="text-ink-600 text-sm mt-1">Create collections to organize your recipes</p>
              </div>
            ) : personalCollections.length === 0 ? (
              <div className="text-center py-8">
                <p className="text-ink-500 text-sm">No personal collections yet</p>
                <p className="text-ink-600 text-2xs mt-1">Create one to get started</p>
              </div>
            ) : (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {personalCollections.map(coll => {
                  const recipeCount = coll.recipeIds?.length || 0;
                  return (
                    <div key={coll.id} className="card rounded-xl p-4 hover:border-white/[0.08] transition-all">
                      <div className="flex items-start justify-between mb-3">
                        <div className="flex-1">
                          <h3
                            className="font-display text-lg text-cream font-normal mb-1 cursor-pointer hover:text-copper-light transition-colors"
                            onClick={() => onNavigate(coll.id)}
                          >
                            {coll.name}
                          </h3>
                          {coll.description && (
                            <p className="text-2xs text-ink-500 mb-2">{coll.description}</p>
                          )}
                          <p className="text-2xs text-ink-600">{recipeCount} {recipeCount === 1 ? 'recipe' : 'recipes'}</p>
                        </div>
                        <div className="flex gap-1">
                          <button
                            onClick={() => startEdit(coll)}
                            className="p-2 text-ink-500 hover:text-ink-300"
                            title="Edit"
                          >
                            <Icon name="Edit" className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => {
                              if (confirm(`Delete collection "${coll.name}"?`)) {
                                onDeleteCollection(coll.id);
                              }
                            }}
                            className="p-2 text-ink-500 hover:text-red-400"
                            title="Delete"
                          >
                            <Icon name="Trash2" className="w-4 h-4" />
                          </button>
                        </div>
                      </div>
                      <button
                        onClick={() => onNavigate(coll.id)}
                        className="w-full mt-3 py-2 text-sm text-copper hover:text-copper-light border border-copper/30 hover:border-copper/50 rounded-lg transition-colors"
                      >
                        View Collection
                      </button>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      );
    };

    const CollectionDetailView = ({ collection, allDrinks, getCollectionRecipes, onNavigateBack, onNavigateToRecipe, onRemoveRecipe }) => {
      if (!collection) {
        return (
          <div className="animate-fade-in">
            <button onClick={onNavigateBack} className="mb-6 flex items-center gap-2 text-ink-400 hover:text-cream">
              <Icon name="ArrowLeft" className="w-4 h-4" />
              <span>Back to Collections</span>
            </button>
            <p className="text-ink-400">Collection not found</p>
          </div>
        );
      }
      
      // Get recipes: rule-based for curated, recipeIds for personal
      const recipes = collection.collectionType === 'curated' 
        ? (getCollectionRecipes ? getCollectionRecipes(collection) : [])
        : allDrinks.filter(d => collection.recipeIds?.includes(d.id));
      
      return (
        <div className="animate-fade-in">
          <div className="flex items-center gap-4 mb-6">
            <button onClick={onNavigateBack} className="p-2 text-ink-400 hover:text-cream">
              <Icon name="ArrowLeft" className="w-5 h-5" />
            </button>
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <h2 className="font-display text-2xl text-cream font-light">{collection.name}</h2>
                {collection.collectionType === 'curated' && (
                  <span className="text-2xs px-2 py-0.5 rounded bg-copper/10 text-copper uppercase tracking-wider">Curated</span>
                )}
              </div>
              {collection.description && (
                <p className="text-sm text-ink-500 mt-1">{collection.description}</p>
              )}
              <div className="flex items-center gap-2 mt-1">
                <p className="text-xs text-ink-600">{recipes.length} {recipes.length === 1 ? 'recipe' : 'recipes'}</p>
                {collection.collectionType === 'curated' && (
                  <span className="text-2xs text-ink-600">• Auto-updating</span>
                )}
              </div>
            </div>
          </div>
          
          {recipes.length === 0 ? (
            <div className="text-center py-16">
              <p className="text-ink-400 font-light">No recipes in this collection</p>
              {collection.collectionType === 'curated' ? (
                <p className="text-ink-600 text-sm mt-1">No recipes match the collection rules</p>
              ) : (
                <p className="text-ink-600 text-sm mt-1">Add recipes from recipe detail view</p>
              )}
            </div>
          ) : (
            <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              {recipes.map(drink => (
                <div key={drink.id} className="card rounded-xl overflow-hidden group cursor-pointer transition-all hover:border-white/[0.06]">
                  <div className="relative h-36 sm:h-44 overflow-hidden bg-ink-900" onClick={() => onNavigateToRecipe(drink)}>
                    {drink.image ? (
                      <img src={drink.image} alt={drink.name} className="w-full h-full object-cover opacity-75 group-hover:opacity-90 transition-opacity" />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-ink-850 to-ink-900">
                        <span className="font-display text-4xl text-ink-700">{drink.name.charAt(0)}</span>
                      </div>
                    )}
                    <div className="absolute inset-0 bg-gradient-to-t from-ink-950 via-ink-950/30 to-transparent" />
                    {collection.collectionType !== 'curated' && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onRemoveRecipe(drink.id, collection.id);
                        }}
                        className="absolute top-2.5 right-2.5 p-1.5 rounded-lg bg-ink-950/60 backdrop-blur-sm text-ink-400 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-all"
                      >
                        <Icon name="X" className="w-3.5 h-3.5" />
                      </button>
                    )}
                  </div>
                  <div className="p-3 sm:p-4" onClick={() => onNavigateToRecipe(drink)}>
                    <h3 className="font-display text-base sm:text-lg text-cream font-normal leading-tight group-hover:text-copper-light transition-colors">
                      {drink.name}
                    </h3>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };

    const SettingsView = ({ onClose, onExport, onImport, unmatchedIngredients, onImportShared }) => {
      const fileRef = useRef(null);
      const [showDebug, setShowDebug] = useState(false);
      const [importMode, setImportMode] = useState('replace');

      return (
        <div className="animate-fade-in max-w-2xl">
          <div className="flex items-center justify-between mb-6">
            <h2 className="font-display text-2xl text-cream font-light">Settings</h2>
            <button onClick={onClose} className="p-2 text-ink-500 hover:text-ink-300">
              <Icon name="X" className="w-5 h-5" />
            </button>
          </div>

          <div className="space-y-4">
            {/* Backup & Restore */}
            <div className="card rounded-xl p-5">
              <h3 className="font-display text-lg text-cream font-normal mb-4">Backup & Restore</h3>
              <div className="space-y-3">
                <button onClick={onExport} className="w-full p-4 card-elevated rounded-lg text-left hover:border-white/[0.08] transition-colors group">
                  <div className="flex items-center gap-3">
                    <Icon name="Download" className="w-5 h-5 text-copper" />
                    <div>
                      <p className="text-cream font-light group-hover:text-copper-light transition-colors">Export Data</p>
                      <p className="text-2xs text-ink-500 mt-0.5">Download your recipes and settings</p>
                    </div>
                  </div>
                </button>
              <input type="file" ref={fileRef} onChange={(e) => onImport(e, importMode)} accept=".json" className="hidden" />
              <button onClick={() => fileRef.current?.click()} className="w-full p-4 card-elevated rounded-lg text-left hover:border-white/[0.08] transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Upload" className="w-5 h-5 text-copper" />
                  <div className="flex-1">
                    <p className="text-cream font-light group-hover:text-copper-light transition-colors">Import Everything</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Restore from a backup file</p>
                  </div>
                </div>
              </button>
              
              {/* Import mode selection */}
              <div className="mt-3 pt-3 border-t border-white/[0.03]">
                <p className="text-2xs text-ink-600 uppercase tracking-wider mb-2">Import Mode</p>
                <div className="space-y-2">
                  <label className="flex items-center gap-3 p-2 card rounded-lg cursor-pointer">
                    <input
                      type="radio"
                      name="importMode"
                      value="replace"
                      checked={importMode === 'replace'}
                      onChange={(e) => setImportMode(e.target.value)}
                      className="text-copper"
                    />
                    <div>
                      <span className="text-sm text-ink-300">Replace</span>
                      <p className="text-2xs text-ink-600">Overwrite all existing data</p>
                    </div>
                  </label>
                  <label className="flex items-center gap-3 p-2 card rounded-lg cursor-pointer">
                    <input
                      type="radio"
                      name="importMode"
                      value="merge"
                      checked={importMode === 'merge'}
                      onChange={(e) => setImportMode(e.target.value)}
                      className="text-copper"
                    />
                    <div>
                      <span className="text-sm text-ink-300">Merge</span>
                      <p className="text-2xs text-ink-600">Combine with existing data</p>
                    </div>
                  </label>
                </div>
              </div>
              <button onClick={onImportShared} className="w-full p-4 card-elevated rounded-lg text-left hover:border-white/[0.08] transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Share2" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-cream font-light group-hover:text-copper-light transition-colors">Import Shared Recipe</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Paste a shared recipe JSON</p>
                  </div>
                </div>
              </button>
            </div>
          </div>

            {/* Debug (hidden) */}
            {unmatchedIngredients.length > 0 && (
              <div className="card rounded-xl p-5">
                <button
                  onClick={() => setShowDebug(!showDebug)}
                  className="w-full flex items-center justify-between text-left"
                >
                  <h3 className="font-display text-lg text-cream font-normal">Debug: Unmatched Ingredients</h3>
                  <Icon name={showDebug ? 'ChevronUp' : 'ChevronDown'} className="w-5 h-5 text-ink-500" />
                </button>
                {showDebug && (
                  <div className="mt-4 pt-4 border-t border-white/[0.03]">
                    <p className="text-sm text-ink-400 mb-3">Ingredients that couldn't be matched to canonical names:</p>
                    <div className="flex flex-wrap gap-2">
                      {unmatchedIngredients.map((ing, i) => (
                        <span key={i} className="px-2 py-1 rounded bg-white/[0.02] text-xs text-ink-500 font-mono">
                          {ing}
                        </span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      );
    };

    const EmptyState = ({ view, onAction }) => {
      const config = {
        browse: { icon: 'Search', title: 'No recipes found', subtitle: 'Try a different search', action: null },
        saved: { icon: 'Bookmark', title: 'No saved recipes', subtitle: 'Save recipes to find them quickly', action: null },
        favorites: { icon: 'Heart', title: 'No favorites yet', subtitle: 'Heart the recipes you love', action: null },
        canMake: { icon: 'Wine', title: 'Add ingredients to your bar', subtitle: 'See what cocktails you can make', action: 'Stock Your Bar', actionFn: onAction },
        almostMake: { icon: 'Clock', title: 'No almost-ready recipes', subtitle: 'Add more ingredients to unlock', action: null },
        wantToTry: { icon: 'Star', title: 'No recipes to try', subtitle: 'Mark recipes you want to try', action: null },
        custom: { icon: 'FlaskConical', title: 'No custom recipes', subtitle: 'Create your own cocktail specs', action: 'Create Recipe', actionFn: onAction },
      };
      const c = config[view] || config.browse;
      
      return (
        <div className="text-center py-16 animate-fade-in">
          <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-white/[0.02] flex items-center justify-center">
            <Icon name={c.icon} className="w-7 h-7 text-ink-700" />
          </div>
          <p className="text-ink-400 font-light">{c.title}</p>
          <p className="text-ink-600 text-sm mt-1">{c.subtitle}</p>
          {c.action && (
            <button onClick={c.actionFn} className="mt-4 px-4 py-2 btn-copper rounded-lg text-sm font-medium">
              {c.action}
            </button>
          )}
        </div>
      );
    };

    const RecipeCard = ({ drink, rating, isSaved, isFavorite, canMake, missingCount, onClick, onToggleSaved, onToggleFavorite, className }) => (
      <div className={`card rounded-xl overflow-hidden group cursor-pointer transition-all hover:border-white/[0.06] ${className}`} onClick={onClick}>
        <div className="relative h-36 sm:h-44 overflow-hidden bg-ink-900">
          {drink.image ? (
            <img src={drink.image} alt={drink.name} className="w-full h-full object-cover opacity-75 group-hover:opacity-90 group-hover:scale-105 transition-all duration-500" loading="lazy" />
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-ink-850 to-ink-900">
              <span className="font-display text-4xl text-ink-700">{drink.name.charAt(0)}</span>
            </div>
          )}
          <div className="absolute inset-0 bg-gradient-to-t from-ink-950 via-ink-950/30 to-transparent" />
          
          {/* Status badges */}
          <div className="absolute top-2.5 left-2.5 flex gap-1.5">
            {canMake && (
              <span className="text-2xs px-2 py-1 rounded bg-emerald-900/80 text-emerald-300 tracking-wide uppercase font-medium">Ready</span>
            )}
            {!canMake && missingCount > 0 && missingCount <= 2 && (
              <span className="text-2xs px-2 py-1 rounded bg-amber-900/60 text-amber-300 tracking-wide uppercase font-medium">
                {missingCount} away
              </span>
            )}
            {drink.source === 'custom' && (
              <span className="text-2xs px-2 py-1 rounded bg-copper/20 text-copper tracking-wide uppercase font-medium">Custom</span>
            )}
          </div>
          
          {/* Quick actions */}
          <div className="absolute top-2.5 right-2.5 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
            <button
              onClick={(e) => { e.stopPropagation(); onToggleFavorite(); }}
              className={`p-1.5 rounded-lg backdrop-blur-sm transition-colors ${isFavorite ? 'bg-copper/30 text-copper' : 'bg-ink-950/60 text-ink-400 hover:text-copper'}`}
            >
              <Icon name="Heart" className="w-3.5 h-3.5" />
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); onToggleSaved(); }}
              className={`p-1.5 rounded-lg backdrop-blur-sm transition-colors ${isSaved ? 'bg-copper/30 text-copper' : 'bg-ink-950/60 text-ink-400 hover:text-copper'}`}
            >
              <Icon name="Bookmark" className="w-3.5 h-3.5" />
            </button>
          </div>
          
          {/* Ingredient count */}
          <div className="absolute bottom-2.5 right-2.5">
            <span className="text-2xs text-ink-500 bg-ink-950/60 backdrop-blur-sm px-2 py-1 rounded">
              {drink.ingredients?.length || 0} ing.
            </span>
          </div>
        </div>
        
        <div className="p-3 sm:p-4">
          <h3 className="font-display text-base sm:text-lg text-cream font-normal leading-tight group-hover:text-copper-light transition-colors line-clamp-1">
            {drink.name}
          </h3>
          <div className="flex items-center justify-between mt-1.5">
            <p className="text-2xs sm:text-xs text-ink-500 font-light truncate">{drink.glass || drink.category}</p>
            {rating > 0 && <StarRating rating={rating} readonly size="text-2xs sm:text-xs" />}
          </div>
        </div>
      </div>
    );

    const RecipeDetail = ({ drink, onClose, rating, isSaved, isFavorite, isWantToTry, canMake, inventory, ingredientsDb, collections, onToggleSaved, onToggleFavorite, onToggleWantToTry, onRate, onDelete, onShare, onAddToCollection }) => {
      const invCanonical = new Set(inventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
      const [showCollectionPicker, setShowCollectionPicker] = useState(false);
      
      return (
        <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen sm:py-8 sm:px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-2xl mx-auto bg-ink-950 sm:card sm:rounded-2xl animate-slide-up">
              {/* Header */}
              <div className="relative h-56 sm:h-64 sm:rounded-t-2xl overflow-hidden">
                {drink.image ? (
                  <img src={drink.image} alt={drink.name} className="w-full h-full object-cover opacity-60" />
                ) : (
                  <div className="w-full h-full bg-gradient-to-br from-ink-850 to-ink-900 flex items-center justify-center">
                    <span className="font-display text-7xl text-ink-800">{drink.name.charAt(0)}</span>
                  </div>
                )}
                <div className="absolute inset-0 bg-gradient-to-t from-ink-950 via-ink-950/60 to-ink-950/20" />
                
                <button onClick={onClose} className="absolute top-4 right-4 p-2.5 rounded-full bg-ink-950/50 backdrop-blur-sm text-ink-400 hover:text-cream transition-colors">
                  <Icon name="X" className="w-5 h-5" />
                </button>
                
                <div className="absolute bottom-5 left-5 right-5">
                  <div className="flex gap-2 mb-2">
                    {canMake && <span className="text-2xs px-2.5 py-1 rounded bg-emerald-900/80 text-emerald-300 tracking-wide uppercase">Ready to make</span>}
                    {drink.source === 'custom' && <span className="text-2xs px-2.5 py-1 rounded bg-copper/20 text-copper tracking-wide uppercase">Custom</span>}
                  </div>
                  <h2 className="font-display text-2xl sm:text-3xl text-cream font-light leading-tight">{drink.name}</h2>
                  {drink.glass && <p className="text-ink-400 text-sm mt-1 font-light">{drink.glass}</p>}
                </div>
              </div>
              
              <div className="p-5 sm:p-6 space-y-6">
                {/* Rating & Actions */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <span className="text-2xs text-ink-500 uppercase tracking-widest">Rating</span>
                    <StarRating rating={rating || 0} onRate={onRate} size="text-xl" />
                  </div>
                  <div className="flex gap-1.5">
                    {[
                      { active: isFavorite, onClick: onToggleFavorite, icon: 'Heart' },
                      { active: isSaved, onClick: onToggleSaved, icon: 'Bookmark' },
                      { active: isWantToTry, onClick: onToggleWantToTry, icon: 'Clock' },
                      { onClick: () => onShare?.(drink), icon: 'Share2' },
                      { onClick: () => setShowCollectionPicker(true), icon: 'FolderPlus' },
                    ].map((btn, i) => (
                      <button
                        key={i}
                        onClick={btn.onClick}
                        className={`p-2.5 rounded-lg transition-colors ${btn.active ? 'bg-copper/20 text-copper' : 'bg-white/[0.03] text-ink-500 hover:text-copper'}`}
                        title={btn.icon === 'Share2' ? 'Share recipe' : btn.icon === 'FolderPlus' ? 'Add to collection' : ''}
                      >
                        <Icon name={btn.icon} className="w-4 h-4" />
                      </button>
                    ))}
                  </div>
                </div>
                
                {showCollectionPicker && (
                  <CollectionPicker
                    collections={collections || []}
                    recipeId={drink.id}
                    onSelect={(collectionId) => {
                      onAddToCollection?.(drink.id, collectionId);
                      setShowCollectionPicker(false);
                    }}
                    onClose={() => setShowCollectionPicker(false)}
                  />
                )}
                
                <div className="divider" />
                
                {/* Ingredients */}
                <div>
                  <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-4">Ingredients</h3>
                  <ul className="space-y-1">
                    {drink.ingredients?.map((ing, i) => {
                      const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                      const hasIt = invCanonical.has(ingCanonical);
                      return (
                        <li key={i} className="flex items-center gap-3 py-2.5 border-b border-white/[0.02] last:border-0">
                          <span className={`w-1.5 h-1.5 rounded-full flex-shrink-0 ${hasIt ? 'bg-emerald-500' : 'bg-ink-700'}`} />
                          <span className="text-copper-light font-light min-w-[4rem]">{ing.measure}</span>
                          <span className="text-ink-300 font-light capitalize">{ing.name}</span>
                        </li>
                      );
                    })}
                  </ul>
                </div>
                
                <div className="divider" />
                
                {/* Method */}
                <div>
                  <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-4">Method</h3>
                  <p className="text-ink-300 font-light leading-relaxed">{drink.instructions || 'No instructions provided.'}</p>
                </div>
                
                {drink.notes && (
                  <>
                    <div className="divider" />
                    <div>
                      <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-4">Notes</h3>
                      <p className="text-ink-400 font-light leading-relaxed italic">{drink.notes}</p>
                    </div>
                  </>
                )}
                
                {/* Origin section - only shows if origin data exists */}
                {(drink.originTitle || drink.originAuthor || drink.originSourceType || drink.originUrl || drink.originYear || drink.originNotes) && (
                  <>
                    <div className="divider" />
                    <div>
                      <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-4">Origin</h3>
                      <div className="space-y-2 text-sm text-ink-300 font-light">
                        {drink.originTitle && (
                          <div>
                            <span className="text-ink-500">Title:</span> <span className="text-cream">{drink.originTitle}</span>
                          </div>
                        )}
                        {drink.originAuthor && (
                          <div>
                            <span className="text-ink-500">Author:</span> <span className="text-cream">{drink.originAuthor}</span>
                          </div>
                        )}
                        {drink.originSourceType && (
                          <div>
                            <span className="text-ink-500">Source:</span> <span className="text-cream capitalize">{drink.originSourceType}</span>
                          </div>
                        )}
                        {drink.originUrl && (
                          <div>
                            <span className="text-ink-500">URL:</span>{' '}
                            <a href={drink.originUrl} target="_blank" rel="noopener noreferrer" className="text-copper hover:text-copper-light underline">
                              {drink.originUrl}
                            </a>
                          </div>
                        )}
                        {drink.originYear && (
                          <div>
                            <span className="text-ink-500">Year:</span> <span className="text-cream">{drink.originYear}</span>
                          </div>
                        )}
                        {drink.originNotes && (
                          <div className="pt-2 border-t border-white/[0.03]">
                            <p className="text-ink-400 italic">{drink.originNotes}</p>
                          </div>
                        )}
                      </div>
                    </div>
                  </>
                )}
                
                {onDelete && (
                  <>
                    <div className="divider" />
                    <button onClick={onDelete} className="w-full py-3 text-sm text-ink-600 hover:text-red-400 transition-colors">
                      Delete recipe
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };

    const AddRecipeModal = ({ onClose, onAdd, ingredientsDb }) => {
      const [name, setName] = useState('');
      const [category, setCategory] = useState('Cocktail');
      const [glass, setGlass] = useState('');
      const [instructions, setInstructions] = useState('');
      const [notes, setNotes] = useState('');
      const [ingredients, setIngredients] = useState([]);
      const [showIngredientPicker, setShowIngredientPicker] = useState(false);
      const [ingredientSearch, setIngredientSearch] = useState('');
      const [expandedCategory, setExpandedCategory] = useState(null);
      const [editingIngredientIndex, setEditingIngredientIndex] = useState(null);
      const [autocompleteSuggestions, setAutocompleteSuggestions] = useState([]);
      const [showAutocomplete, setShowAutocomplete] = useState(false);
      const [selectedSuggestionIndex, setSelectedSuggestionIndex] = useState(-1);
      const autocompleteRefs = useRef({});

      // Flatten all ingredients for search (including aliases)
      const allIngredients = useMemo(() => {
        if (!ingredientsDb) return [];
        const flat = [];
        ingredientsDb.categories?.forEach(cat => {
          cat.subcategories?.forEach(sub => {
            sub.items?.forEach(item => {
              flat.push({ ...item, category: cat.name, subcategory: sub.name });
              // Add aliases as separate entries for easier matching
              if (item.aliases) {
                item.aliases.forEach(alias => {
                  flat.push({ ...item, name: alias, category: cat.name, subcategory: sub.name, isAlias: true });
                });
              }
            });
          });
        });
        return flat;
      }, [ingredientsDb]);

      // Get canonical name for an ingredient
      const getCanonicalName = (name) => {
        const normalized = normalizeIngredient(name, ingredientsDb);
        const found = allIngredients.find(ing => normalizeIngredient(ing.name, ingredientsDb) === normalized && !ing.isAlias);
        return found ? found.name : null;
      };

      // Filter ingredients by search for autocomplete
      const getAutocompleteSuggestions = (searchTerm) => {
        if (!searchTerm.trim() || searchTerm.length < 2) return [];
        const term = searchTerm.toLowerCase().trim();
        return allIngredients
          .filter(ing => {
            const nameMatch = ing.name.toLowerCase().includes(term);
            const aliasMatch = ing.aliases?.some(a => a.toLowerCase().includes(term));
            return (nameMatch || aliasMatch) && !ing.isAlias;
          })
          .slice(0, 8)
          .map(ing => ing.name);
      };

      const selectAutocompleteSuggestion = (index, suggestion) => {
        const updated = [...ingredients];
        updated[index].name = suggestion;
        setIngredients(updated);
        setShowAutocomplete(false);
        setAutocompleteSuggestions([]);
        setEditingIngredientIndex(null);
        setSelectedSuggestionIndex(-1);
      };

      const addIngredient = (ingredientName = '') => {
        const canonical = getCanonicalName(ingredientName) || ingredientName;
        setIngredients([...ingredients, { name: canonical, amount: '', unit: 'oz' }]);
        setShowIngredientPicker(false);
        setIngredientSearch('');
        setExpandedCategory(null);
        setEditingIngredientIndex(null);
      };

      const updateIngredient = (i, field, value) => {
        const updated = [...ingredients];
        updated[i][field] = value;
        setIngredients(updated);
        
        // If updating name, show autocomplete
        if (field === 'name' && value.length >= 2) {
          const suggestions = getAutocompleteSuggestions(value);
          setAutocompleteSuggestions(suggestions);
          setShowAutocomplete(true);
          setEditingIngredientIndex(i);
          setSelectedSuggestionIndex(-1); // Reset selection when typing
        } else if (field === 'name' && value.length < 2) {
          setShowAutocomplete(false);
          setSelectedSuggestionIndex(-1);
        }
      };

      const quickAddAmount = (index, amount) => {
        const updated = [...ingredients];
        updated[index].amount = amount;
        setIngredients(updated);
      };

      const removeIngredient = (i) => setIngredients(ingredients.filter((_, idx) => idx !== i));

      const handleSubmit = () => {
        if (!name.trim() || ingredients.length === 0) return;
        const formattedIngredients = ingredients.map(ing => ({
          name: ing.name,
          measure: ing.amount ? `${ing.amount} ${ing.unit}` : ing.unit
        }));
        onAdd({ name, category, glass, instructions, notes, ingredients: formattedIngredients });
      };

      const measurements = ingredientsDb?.measurements || [
        { id: 'oz', name: 'oz' }, { id: 'ml', name: 'ml' }, { id: 'dash', name: 'dash' },
        { id: 'dashes', name: 'dashes' }, { id: 'barspoon', name: 'barspoon' }, { id: 'splash', name: 'splash' },
        { id: 'top', name: 'top' }, { id: 'rinse', name: 'rinse' }, { id: 'whole', name: 'whole' },
        { id: 'leaves', name: 'leaves' }, { id: 'drops', name: 'drops' }
      ];

      const amounts = ingredientsDb?.amounts || ['1/4', '1/2', '3/4', '1', '1 1/2', '2', '2 1/2', '3', '4', '6', '8'];
      const glassware = ingredientsDb?.glassware || [
        { id: 'rocks', name: 'Rocks Glass' }, { id: 'coupe', name: 'Coupe' },
        { id: 'martini', name: 'Martini Glass' }, { id: 'highball', name: 'Highball Glass' },
        { id: 'collins', name: 'Collins Glass' }, { id: 'flute', name: 'Champagne Flute' }
      ];

      return (
        <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen sm:py-8 sm:px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-xl mx-auto bg-ink-950 sm:card sm:rounded-2xl animate-slide-up">
              <div className="p-5 sm:p-6">
                <div className="flex items-center justify-between mb-6">
                  <h2 className="font-display text-2xl text-cream font-light">Build Cocktail</h2>
                  <button onClick={onClose} className="p-2 text-ink-500 hover:text-ink-300"><Icon name="X" className="w-5 h-5" /></button>
                </div>

                <div className="space-y-5">
                  {/* Name */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Name *</label>
                    <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Recipe name" className="w-full px-4 py-3 input-field rounded-lg text-cream font-light" autoFocus />
                  </div>

                  {/* Category & Glass */}
                  <div className="grid grid-cols-2 gap-3">
                    <div>
                      <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Category</label>
                      <select value={category} onChange={(e) => setCategory(e.target.value)} className="w-full px-4 py-3 input-field rounded-lg text-cream font-light bg-transparent appearance-none cursor-pointer">
                        {['Cocktail', 'Sour', 'Spirit Forward', 'Highball', 'Tiki', 'Spritz', 'Martini', 'Flip', 'Hot Drink', 'Other'].map(c => (
                          <option key={c} value={c} className="bg-ink-900">{c}</option>
                        ))}
                      </select>
                    </div>
                    <div>
                      <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Glass</label>
                      <select value={glass} onChange={(e) => setGlass(e.target.value)} className="w-full px-4 py-3 input-field rounded-lg text-cream font-light bg-transparent appearance-none cursor-pointer">
                        <option value="" className="bg-ink-900">Select glass...</option>
                        {glassware.map(g => (
                          <option key={g.id} value={g.name} className="bg-ink-900">{g.name}</option>
                        ))}
                      </select>
                    </div>
                  </div>

                  {/* Ingredients */}
                  <div>
                    <div className="flex items-center justify-between mb-3">
                      <label className="text-2xs text-ink-500 uppercase tracking-widest">Ingredients *</label>
                    </div>

                    {/* Added ingredients */}
                    {ingredients.length > 0 && (
                      <div className="space-y-2 mb-3">
                        {ingredients.map((ing, i) => {
                          const canonicalName = getCanonicalName(ing.name);
                          const isUnmatched = ing.name.trim() && ing.name.length >= 2 && !canonicalName && editingIngredientIndex !== i;
                          
                          return (
                            <div key={i} className="relative">
                              <div className={`flex items-center gap-2 p-3 card rounded-lg ${isUnmatched ? 'border border-amber-900/50 bg-amber-950/10' : ''}`}>
                                {/* Quick amount buttons */}
                                <div className="flex gap-1">
                                  {['1/4', '1/2', '3/4', '1'].map(amt => (
                                    <button
                                      key={amt}
                                      onClick={() => quickAddAmount(i, amt)}
                                      className={`px-2 py-1 text-xs rounded transition-colors ${
                                        ing.amount === amt 
                                          ? 'bg-copper/20 text-copper border border-copper/30' 
                                          : 'bg-white/[0.02] text-ink-500 hover:bg-white/[0.05] border border-white/[0.06]'
                                      }`}
                                    >
                                      {amt}
                                    </button>
                                  ))}
                                </div>
                                
                                <select
                                  value={ing.amount}
                                  onChange={(e) => updateIngredient(i, 'amount', e.target.value)}
                                  className="w-20 px-2 py-1.5 bg-white/[0.02] border border-white/[0.06] rounded text-sm text-copper-light font-light appearance-none cursor-pointer"
                                >
                                  <option value="" className="bg-ink-900">—</option>
                                  {amounts.map(a => (
                                    <option key={a} value={a} className="bg-ink-900">{a}</option>
                                  ))}
                                </select>
                                
                                {/* Unit helpers */}
                                <div className="flex gap-1">
                                  {['oz', 'dash', 'tsp', 'barspoon'].map(unit => (
                                    <button
                                      key={unit}
                                      onClick={() => updateIngredient(i, 'unit', unit)}
                                      className={`px-2 py-1 text-xs rounded transition-colors ${
                                        ing.unit === unit
                                          ? 'bg-copper/20 text-copper border border-copper/30'
                                          : 'bg-white/[0.02] text-ink-500 hover:bg-white/[0.05] border border-white/[0.06]'
                                      }`}
                                    >
                                      {unit}
                                    </button>
                                  ))}
                                </div>
                                
                                <select
                                  value={ing.unit}
                                  onChange={(e) => updateIngredient(i, 'unit', e.target.value)}
                                  className="w-24 px-2 py-1.5 bg-white/[0.02] border border-white/[0.06] rounded text-sm text-copper-light font-light appearance-none cursor-pointer"
                                >
                                  {measurements.map(m => (
                                    <option key={m.id} value={m.name} className="bg-ink-900">{m.name}</option>
                                  ))}
                                </select>
                                
                                {/* Ingredient name input with autocomplete */}
                                <div className="flex-1 relative">
                                  <input
                                    type="text"
                                    value={ing.name}
                                    onChange={(e) => updateIngredient(i, 'name', e.target.value)}
                                    onKeyDown={(e) => {
                                      if (e.key === 'ArrowDown' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        setSelectedSuggestionIndex(prev => {
                                          const next = prev < autocompleteSuggestions.length - 1 ? prev + 1 : 0;
                                          return next;
                                        });
                                        setShowAutocomplete(true);
                                      } else if (e.key === 'ArrowUp' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        setSelectedSuggestionIndex(prev => {
                                          const next = prev > 0 ? prev - 1 : autocompleteSuggestions.length - 1;
                                          return next;
                                        });
                                        setShowAutocomplete(true);
                                      } else if (e.key === 'Enter' && showAutocomplete && selectedSuggestionIndex >= 0) {
                                        e.preventDefault();
                                        selectAutocompleteSuggestion(i, autocompleteSuggestions[selectedSuggestionIndex]);
                                      } else if (e.key === 'Enter' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        selectAutocompleteSuggestion(i, autocompleteSuggestions[0]);
                                      } else if (e.key === 'Escape') {
                                        setShowAutocomplete(false);
                                        setSelectedSuggestionIndex(-1);
                                      }
                                    }}
                                    onFocus={() => {
                                      setEditingIngredientIndex(i);
                                      if (ing.name.length >= 2) {
                                        setAutocompleteSuggestions(getAutocompleteSuggestions(ing.name));
                                        setShowAutocomplete(true);
                                        setSelectedSuggestionIndex(-1);
                                      }
                                    }}
                                    onBlur={() => {
                                      setTimeout(() => {
                                        setShowAutocomplete(false);
                                        setEditingIngredientIndex(null);
                                        setSelectedSuggestionIndex(-1);
                                      }, 200);
                                    }}
                                    placeholder="Ingredient name"
                                    className={`w-full px-3 py-1.5 bg-white/[0.02] border rounded text-sm font-light ${
                                      isUnmatched 
                                        ? 'border-amber-900/50 text-amber-300' 
                                        : canonicalName 
                                          ? 'border-emerald-900/30 text-ink-300' 
                                          : 'border-white/[0.06] text-ink-300'
                                    }`}
                                  />
                                  
                                  {/* Autocomplete dropdown */}
                                  {showAutocomplete && editingIngredientIndex === i && autocompleteSuggestions.length > 0 && (
                                    <div className="absolute top-full left-0 right-0 mt-1 bg-ink-900 border border-white/[0.06] rounded-lg shadow-xl z-50 max-h-48 overflow-y-auto">
                                      {autocompleteSuggestions.map((suggestion, idx) => (
                                        <button
                                          key={idx}
                                          onMouseDown={(e) => {
                                            e.preventDefault();
                                            selectAutocompleteSuggestion(i, suggestion);
                                          }}
                                          onMouseEnter={() => setSelectedSuggestionIndex(idx)}
                                          className={`w-full text-left px-3 py-2 text-sm transition-colors ${
                                            selectedSuggestionIndex === idx
                                              ? 'bg-copper/20 text-copper'
                                              : 'text-ink-300 hover:bg-white/[0.05] hover:text-cream'
                                          }`}
                                        >
                                          {suggestion}
                                        </button>
                                      ))}
                                    </div>
                                  )}
                                  
                                  {/* Validation feedback */}
                                  {isUnmatched && ing.name.length >= 2 && (
                                    <div className="absolute top-full left-0 right-0 mt-1 px-2 py-1 text-2xs text-amber-400 bg-amber-950/30 border border-amber-900/50 rounded z-40">
                                      Unmatched ingredient
                                    </div>
                                  )}
                                </div>
                                
                                <button onClick={() => removeIngredient(i)} className="p-1.5 text-ink-600 hover:text-red-400">
                                  <Icon name="X" className="w-4 h-4" />
                                </button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Add ingredient button/picker */}
                    {!showIngredientPicker ? (
                      <button
                        onClick={() => setShowIngredientPicker(true)}
                        className="w-full p-3 border border-dashed border-ink-700 hover:border-copper/50 rounded-lg text-ink-500 hover:text-copper text-sm font-light transition-colors flex items-center justify-center gap-2"
                      >
                        <Icon name="Plus" className="w-4 h-4" />
                        Add Ingredient
                      </button>
                    ) : (
                      <div className="card-elevated rounded-xl p-3 animate-slide-down">
                        {/* Search */}
                        <div className="relative mb-3">
                          <Icon name="Search" className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-ink-600" />
                          <input
                            type="text"
                            value={ingredientSearch}
                            onChange={(e) => setIngredientSearch(e.target.value)}
                            placeholder="Search ingredients..."
                            className="w-full pl-10 pr-4 py-2.5 input-field rounded-lg text-sm text-cream font-light"
                            autoFocus
                          />
                        </div>

                        {/* Search results */}
                        {filteredIngredients && filteredIngredients.length > 0 ? (
                          <div className="max-h-48 overflow-y-auto space-y-1">
                            {filteredIngredients.map((ing, i) => (
                              <button
                                key={i}
                                onClick={() => addIngredient(ing.name)}
                                className="w-full text-left px-3 py-2 rounded hover:bg-white/[0.05] transition-colors"
                              >
                                <span className="text-sm text-cream">{ing.name}</span>
                                <span className="text-2xs text-ink-600 ml-2">{ing.subcategory}</span>
                              </button>
                            ))}
                          </div>
                        ) : ingredientSearch.trim() ? (
                          <div className="text-center py-4">
                            <p className="text-sm text-ink-500 mb-2">No matches found</p>
                            <button
                              onClick={() => addIngredient(ingredientSearch.trim())}
                              className="text-sm text-copper hover:text-copper-light"
                            >
                              Add "{ingredientSearch.trim()}" as custom
                            </button>
                          </div>
                        ) : (
                          /* Browse categories */
                          <div className="max-h-64 overflow-y-auto">
                            {ingredientsDb?.categories?.map(cat => (
                              <div key={cat.id} className="mb-1">
                                <button
                                  onClick={() => setExpandedCategory(expandedCategory === cat.id ? null : cat.id)}
                                  className="w-full flex items-center justify-between px-3 py-2 hover:bg-white/[0.03] rounded transition-colors"
                                >
                                  <span className="text-xs text-ink-400 uppercase tracking-wider">{cat.name}</span>
                                  <Icon name={expandedCategory === cat.id ? 'ChevronDown' : 'ChevronRight'} className="w-4 h-4 text-ink-600" />
                                </button>
                                {expandedCategory === cat.id && (
                                  <div className="ml-2 border-l border-white/[0.03]">
                                    {cat.subcategories?.map(sub => (
                                      <div key={sub.id} className="ml-2">
                                        <p className="text-2xs text-ink-600 px-2 py-1 mt-1">{sub.name}</p>
                                        {sub.items?.map(item => (
                                          <button
                                            key={item.id}
                                            onClick={() => addIngredient(item.name)}
                                            className="w-full text-left px-3 py-1.5 text-sm text-ink-300 hover:text-cream hover:bg-white/[0.03] rounded transition-colors"
                                          >
                                            {item.name}
                                          </button>
                                        ))}
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        )}

                        <button
                          onClick={() => { setShowIngredientPicker(false); setIngredientSearch(''); setExpandedCategory(null); }}
                          className="w-full mt-3 py-2 text-xs text-ink-500 hover:text-ink-300"
                        >
                          Cancel
                        </button>
                      </div>
                    )}
                  </div>

                  {/* Method */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Method</label>
                    <textarea value={instructions} onChange={(e) => setInstructions(e.target.value)} placeholder="Shake, stir, build..." rows="3" className="w-full px-4 py-3 input-field rounded-lg text-cream font-light resize-none" />
                  </div>

                  {/* Notes */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Notes</label>
                    <textarea value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Where you had it, variations, etc..." rows="2" className="w-full px-4 py-3 input-field rounded-lg text-cream font-light resize-none" />
                  </div>

                  <button
                    onClick={handleSubmit}
                    disabled={!name.trim() || ingredients.length === 0}
                    className="w-full py-4 btn-copper rounded-lg text-sm font-medium tracking-wide uppercase disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Save Recipe
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const InventoryView = ({ inventory, onAdd, onRemove, ingredientsDb }) => {
      const [newItem, setNewItem] = useState('');
      const [isAdding, setIsAdding] = useState(false);
      const [showSuggestions, setShowSuggestions] = useState(false);
      const [autocompleteSuggestions, setAutocompleteSuggestions] = useState([]);
      const [selectedIndex, setSelectedIndex] = useState(-1);
      const inputRef = useRef(null);
      const suggestionsRef = useRef(null);

      const handleAdd = (itemName = null) => {
        const item = itemName || newItem.trim();
        if (!item) return;
        onAdd(item);
        setNewItem('');
        setAutocompleteSuggestions([]);
        setShowSuggestions(false);
        setSelectedIndex(-1);
      };

      useEffect(() => {
        if (isAdding && inputRef.current) inputRef.current.focus();
      }, [isAdding]);

      // Close suggestions when clicking outside
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (suggestionsRef.current && !suggestionsRef.current.contains(event.target) && 
              inputRef.current && !inputRef.current.contains(event.target)) {
            setShowSuggestions(false);
          }
        };
        
        if (showSuggestions) {
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }
      }, [showSuggestions]);

      // Flatten all ingredients from ingredients.json for autocomplete
      const allIngredients = useMemo(() => {
        if (!ingredientsDb) return [];
        const flat = [];
        ingredientsDb.categories?.forEach(cat => {
          cat.subcategories?.forEach(sub => {
            sub.items?.forEach(item => {
              flat.push({
                name: item.name,
                id: item.id,
                category: cat.name,
                subcategory: sub.name,
                aliases: item.aliases || []
              });
            });
          });
        });
        return flat;
      }, [ingredientsDb]);

      // Get autocomplete suggestions based on input
      const getAutocompleteSuggestions = useMemo(() => {
        if (!newItem.trim() || newItem.length < 1) {
          // If empty or very short, show common ingredients
          return COMMON_INGREDIENTS.filter(i => {
            const canonical = normalizeIngredient(i, ingredientsDb);
            return !inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical);
          }).slice(0, 20).map(name => ({ name, category: 'Common', subcategory: '' }));
        }

        const searchTerm = newItem.toLowerCase().trim();
        const results = [];
        const seen = new Set();

        // First, find exact matches and close matches
        allIngredients.forEach(ing => {
          const nameLower = ing.name.toLowerCase();
          const aliasesLower = ing.aliases.map(a => a.toLowerCase());
          
          // Check if already in inventory
          const canonical = normalizeIngredient(ing.name, ingredientsDb);
          if (inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical)) {
            return;
          }

          // Exact match
          if (nameLower === searchTerm || aliasesLower.includes(searchTerm)) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'exact' });
              seen.add(ing.name);
            }
            return;
          }

          // Starts with
          if (nameLower.startsWith(searchTerm) || aliasesLower.some(a => a.startsWith(searchTerm))) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'starts' });
              seen.add(ing.name);
            }
            return;
          }

          // Contains (for category searches like "amaro")
          if (nameLower.includes(searchTerm) || 
              aliasesLower.some(a => a.includes(searchTerm)) ||
              ing.subcategory.toLowerCase().includes(searchTerm) ||
              ing.category.toLowerCase().includes(searchTerm)) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'contains' });
              seen.add(ing.name);
            }
          }
        });

        // Sort by match type (exact > starts > contains), then alphabetically
        results.sort((a, b) => {
          const typeOrder = { exact: 0, starts: 1, contains: 2 };
          if (typeOrder[a.matchType] !== typeOrder[b.matchType]) {
            return typeOrder[a.matchType] - typeOrder[b.matchType];
          }
          return a.name.localeCompare(b.name);
        });

        return results.slice(0, 50); // Limit to 50 results
      }, [newItem, allIngredients, inventory, ingredientsDb]);

      // Update suggestions as user types
      useEffect(() => {
        if (newItem.trim().length >= 1) {
          setAutocompleteSuggestions(getAutocompleteSuggestions);
          setShowSuggestions(true);
          setSelectedIndex(-1); // Reset selection when typing
        } else {
          setAutocompleteSuggestions([]);
          setSelectedIndex(-1);
        }
      }, [newItem, getAutocompleteSuggestions]);

      // Group suggestions by category
      const groupedSuggestions = useMemo(() => {
        const groups = {};
        autocompleteSuggestions.forEach(ing => {
          const category = ing.category || 'Other';
          if (!groups[category]) groups[category] = [];
          groups[category].push(ing);
        });
        return groups;
      }, [autocompleteSuggestions]);
      
      // Flatten suggestions for keyboard navigation
      const flatSuggestions = useMemo(() => {
        const flat = [];
        Object.entries(groupedSuggestions).forEach(([category, items]) => {
          items.forEach(item => flat.push(item));
        });
        return flat;
      }, [groupedSuggestions]);

      const quickSuggestions = COMMON_INGREDIENTS.filter(i => {
        const canonical = normalizeIngredient(i, ingredientsDb);
        return !inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical);
      }).slice(0, 12);

      // Categorize inventory items using ingredients.json database
      const categorized = useMemo(() => {
        const result = {};
        const categoryOrder = ['Spirits', 'Liqueurs', 'Fortified Wines', 'Bitters', 'Syrups & Sweeteners', 'Citrus & Juices', 'Mixers & Sodas', 'Other'];
        categoryOrder.forEach(cat => result[cat] = []);

        inventory.forEach(item => {
          let found = false;
          const itemNameLower = item.name.toLowerCase();
          const itemCanonical = normalizeIngredient(item.name, ingredientsDb);

          // Try to find in ingredients.json database
          if (ingredientsDb) {
            for (const category of ingredientsDb.categories || []) {
              for (const subcategory of category.subcategories || []) {
                for (const ing of subcategory.items || []) {
                  const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                  if (ingCanonical === itemCanonical || 
                      ing.aliases?.some(alias => normalizeIngredient(alias, ingredientsDb) === itemCanonical)) {
                    // Map database categories to display categories
                    let displayCategory = 'Other';
                    const catName = category.name.toLowerCase();
                    const subName = subcategory.name.toLowerCase();

                    if (catName.includes('spirit')) {
                      displayCategory = 'Spirits';
                    } else if (catName.includes('liqueur') || subName.includes('amaro') || subName.includes('amari')) {
                      displayCategory = 'Liqueurs';
                    } else if (catName.includes('fortified') || catName.includes('vermouth') || catName.includes('sherry') || catName.includes('port')) {
                      displayCategory = 'Fortified Wines';
                    } else if (catName.includes('bitter')) {
                      displayCategory = 'Bitters';
                    } else if (catName.includes('syrup') || catName.includes('sweetener') || catName.includes('honey') || catName.includes('agave')) {
                      displayCategory = 'Syrups & Sweeteners';
                    } else if (catName.includes('citrus') || catName.includes('juice') || subName.includes('juice')) {
                      displayCategory = 'Citrus & Juices';
                    } else if (catName.includes('mixer') || catName.includes('soda') || catName.includes('tonic')) {
                      displayCategory = 'Mixers & Sodas';
                    }

                    if (!result[displayCategory]) result[displayCategory] = [];
                    result[displayCategory].push(item);
                    found = true;
                    return;
                  }
                }
              }
            }
          }

          // Fallback to keyword matching if not found in database
          if (!found) {
            const keywordCategories = {
              'Spirits': ['vodka', 'gin', 'rum', 'tequila', 'whiskey', 'whisky', 'bourbon', 'scotch', 'brandy', 'cognac', 'mezcal', 'rye', 'pisco'],
              'Liqueurs': ['triple sec', 'cointreau', 'kahlua', 'amaretto', 'campari', 'aperol', 'chartreuse', 'benedictine', 'maraschino', 'st germain', 'drambuie', 'fernet', 'curacao', 'amaro', 'cynar'],
              'Fortified Wines': ['vermouth', 'lillet', 'sherry', 'port', 'madeira'],
              'Bitters': ['angostura', 'orange bitters', 'peychauds', 'bitters'],
              'Syrups & Sweeteners': ['simple syrup', 'honey', 'agave', 'grenadine', 'orgeat', 'sugar', 'syrup'],
              'Citrus & Juices': ['lime', 'lemon', 'orange', 'grapefruit', 'pineapple juice', 'orange juice', 'cranberry', 'juice'],
              'Mixers & Sodas': ['soda', 'tonic', 'ginger beer', 'cola', 'club soda', 'tonic water']
            };

            for (const [cat, keywords] of Object.entries(keywordCategories)) {
              if (keywords.some(k => itemNameLower.includes(k.toLowerCase()))) {
                result[cat].push(item);
                found = true;
                break;
              }
            }
          }

          if (!found) {
            result['Other'].push(item);
          }
        });

        // Sort items within each category alphabetically
        Object.keys(result).forEach(cat => {
          result[cat].sort((a, b) => a.name.localeCompare(b.name));
        });

        return result;
      }, [inventory, ingredientsDb]);

      return (
        <div className="max-w-2xl mx-auto animate-fade-in">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="font-display text-2xl text-cream font-light">Your Bar</h2>
              <p className="text-ink-500 text-sm mt-0.5">{inventory.length} ingredients</p>
            </div>
            {!isAdding && (
              <button onClick={() => setIsAdding(true)} className="px-4 py-2.5 btn-copper rounded-lg text-sm font-medium">
                Add Ingredient
              </button>
            )}
          </div>

          {isAdding && (
            <div className="card-elevated rounded-xl p-4 mb-6 animate-slide-down">
              <div className="flex gap-2 mb-3">
                <div className="flex-1 relative">
                  <input
                    ref={inputRef}
                    type="text"
                    value={newItem}
                    onChange={(e) => setNewItem(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (flatSuggestions.length > 0) {
                          setSelectedIndex(prev => {
                            const next = prev < flatSuggestions.length - 1 ? prev + 1 : 0;
                            // Scroll into view
                            setTimeout(() => {
                              const selectedEl = suggestionsRef.current?.querySelector(`[data-index="${next}"]`);
                              selectedEl?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                            }, 0);
                            return next;
                          });
                          setShowSuggestions(true);
                        }
                      } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (flatSuggestions.length > 0) {
                          setSelectedIndex(prev => {
                            const next = prev > 0 ? prev - 1 : flatSuggestions.length - 1;
                            // Scroll into view
                            setTimeout(() => {
                              const selectedEl = suggestionsRef.current?.querySelector(`[data-index="${next}"]`);
                              selectedEl?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                            }, 0);
                            return next;
                          });
                          setShowSuggestions(true);
                        }
                      } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (selectedIndex >= 0 && selectedIndex < flatSuggestions.length) {
                          handleAdd(flatSuggestions[selectedIndex].name);
                        } else if (autocompleteSuggestions.length > 0 && flatSuggestions.length > 0) {
                          handleAdd(flatSuggestions[0].name);
                        } else if (newItem.trim()) {
                          handleAdd();
                        }
                      } else if (e.key === 'Escape') {
                        setShowSuggestions(false);
                        setSelectedIndex(-1);
                      }
                    }}
                    onFocus={() => setShowSuggestions(true)}
                    placeholder="Type to search ingredients..."
                    className="w-full px-4 py-3 input-field rounded-lg text-cream font-light"
                  />
                  
                  {/* Autocomplete dropdown */}
                  {showSuggestions && autocompleteSuggestions.length > 0 && (
                    <div 
                      ref={suggestionsRef}
                      className="absolute top-full left-0 right-0 mt-2 bg-ink-900 border border-white/[0.06] rounded-lg shadow-xl z-50 max-h-96 overflow-y-auto"
                    >
                      {Object.entries(groupedSuggestions).map(([category, items]) => (
                        <div key={category} className="border-b border-white/[0.03] last:border-0">
                          <div className="px-3 py-2 bg-ink-950/50">
                            <p className="text-2xs text-ink-500 uppercase tracking-wider">{category}</p>
                          </div>
                          {items.map((ing, idx) => {
                            const globalIdx = flatSuggestions.findIndex(s => s.id === ing.id && s.name === ing.name);
                            return (
                              <button
                                key={`${ing.id}-${idx}`}
                                data-index={globalIdx}
                                onClick={() => handleAdd(ing.name)}
                                onMouseEnter={() => setSelectedIndex(globalIdx)}
                                className={`w-full text-left px-4 py-2.5 text-sm transition-colors flex items-center justify-between ${
                                  selectedIndex === globalIdx
                                    ? 'bg-copper/20 text-copper'
                                    : 'text-ink-300 hover:bg-white/[0.05] hover:text-cream'
                                }`}
                              >
                                <span>{ing.name}</span>
                                {ing.subcategory && (
                                  <span className="text-2xs text-ink-600 ml-2">{ing.subcategory}</span>
                                )}
                              </button>
                            );
                          })}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                <button 
                  onClick={() => { 
                    setIsAdding(false); 
                    setNewItem(''); 
                    setShowSuggestions(false);
                    setAutocompleteSuggestions([]);
                  }} 
                  className="px-4 py-3 text-ink-500 hover:text-ink-300 font-light"
                >
                  Done
                </button>
              </div>
              
              {/* Quick add buttons (when input is empty) */}
              {!newItem.trim() && quickSuggestions.length > 0 && (
                <div className="border-t border-white/[0.03] pt-3">
                  <p className="text-2xs text-ink-600 uppercase tracking-widest mb-2">Quick add</p>
                  <div className="flex flex-wrap gap-1.5">
                    {quickSuggestions.map(s => (
                      <button
                        key={s}
                        onClick={() => handleAdd(s)}
                        className="px-2.5 py-1.5 text-xs text-ink-400 bg-white/[0.02] hover:bg-white/[0.05] hover:text-copper rounded-md transition-colors"
                      >
                        {s}
                      </button>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {inventory.length === 0 ? (
            <div className="text-center py-16">
              <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-white/[0.02] flex items-center justify-center">
                <Icon name="Wine" className="w-7 h-7 text-ink-700" />
              </div>
              <p className="text-ink-400 font-light">Your bar is empty</p>
              <p className="text-ink-600 text-sm mt-1">Add ingredients to see what you can make</p>
            </div>
          ) : (
            <div className="space-y-6">
              {Object.entries(categorized).map(([cat, items]) => {
                if (items.length === 0) return null;
                return (
                  <div key={cat}>
                    <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-3">{cat}</h3>
                    <div className="flex flex-wrap gap-2">
                      {items.map(item => (
                        <div key={item.id} className="group flex items-center gap-2 px-3 py-2 card rounded-lg hover:border-white/[0.06] transition-colors">
                          <span className="text-sm text-ink-300 capitalize font-light">{item.name}</span>
                          <button onClick={() => onRemove(item.id)} className="text-ink-700 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-all">
                            <Icon name="X" className="w-3 h-3" />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      );
    };

    const BackupModal = ({ onClose, onExport, onImport }) => {
      const fileRef = useRef(null);
      return (
        <div className="fixed inset-0 z-50 bg-ink-950/95 backdrop-blur-sm animate-fade-in flex items-center justify-center p-4" onClick={onClose}>
          <div className="max-w-sm w-full card rounded-2xl p-5 animate-scale-in" onClick={e => e.stopPropagation()}>
            <h2 className="font-display text-xl text-cream font-light mb-5">Backup & Restore</h2>
            <div className="space-y-3">
              <button onClick={onExport} className="w-full p-4 card-elevated rounded-xl text-left hover:border-white/[0.08] transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Download" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-cream font-light group-hover:text-copper-light transition-colors">Export Data</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Download your recipes and settings</p>
                  </div>
                </div>
              </button>
              <input type="file" ref={fileRef} onChange={onImport} accept=".json" className="hidden" />
              <button onClick={() => fileRef.current?.click()} className="w-full p-4 card-elevated rounded-xl text-left hover:border-white/[0.08] transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Upload" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-cream font-light group-hover:text-copper-light transition-colors">Import Data</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Restore from a backup file</p>
                  </div>
                </div>
              </button>
            </div>
            <button onClick={onClose} className="w-full mt-5 py-3 text-sm text-ink-500 hover:text-ink-300">Cancel</button>
          </div>
        </div>
      );
    };

    const ConfirmDialog = ({ title, message, onConfirm, onCancel }) => (
      <div className="fixed inset-0 z-[60] bg-ink-950/95 backdrop-blur-sm animate-fade-in flex items-center justify-center p-4" onClick={onCancel}>
        <div className="max-w-xs w-full card rounded-2xl p-5 animate-scale-in text-center" onClick={e => e.stopPropagation()}>
          <div className="w-12 h-12 mx-auto mb-4 rounded-full bg-red-900/20 flex items-center justify-center">
            <Icon name="Trash2" className="w-5 h-5 text-red-400" />
          </div>
          <h3 className="font-display text-lg text-cream mb-2">{title}</h3>
          <p className="text-sm text-ink-400 font-light mb-5">{message}</p>
          <div className="flex gap-3">
            <button onClick={onCancel} className="flex-1 py-3 text-sm text-ink-400 hover:text-ink-200 card rounded-lg">Cancel</button>
            <button onClick={onConfirm} className="flex-1 py-3 text-sm bg-red-900/50 text-red-300 hover:bg-red-900/70 rounded-lg transition-colors">Delete</button>
          </div>
        </div>
      </div>
    );

    // ============ RENDER ============
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <ToastProvider>
        <App />
      </ToastProvider>
    );
  </script>
</body>
</html>
