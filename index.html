<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Barkeep">
  <meta name="theme-color" content="#0c0a09">
  <title>Barkeep</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./logo.png">
  <link rel="icon" href="./logo.png" type="image/png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            ink: {
              950: 'var(--bg-primary)',
              900: 'var(--bg-secondary)',
              850: 'var(--bg-tertiary)',
              800: '#374151',
              700: 'var(--border)',
              600: 'var(--text-muted)',
              500: 'var(--text-secondary)',
              400: 'var(--text-secondary)',
              300: 'var(--text-primary)',
              200: 'var(--text-primary)',
              100: 'var(--text-primary)',
            },
            copper: {
              DEFAULT: '#d4a574',
              light: '#e8c9a8',
              dark: '#b8956a',
              muted: '#a08060',
            },
            cream: {
              DEFAULT: '#faf8f5',
              dark: '#f0ebe4',
            }
          },
          fontFamily: {
            'display': ['JetBrains Mono', 'Courier New', 'Monaco', 'Menlo', 'Consolas', 'monospace'],
            'body': ['JetBrains Mono', 'Courier New', 'Monaco', 'Menlo', 'Consolas', 'monospace'],
          },
          fontSize: {
            '2xs': '0.65rem',
          }
        }
      }
    }
  </script>
  <style>
    * { -webkit-tap-highlight-color: transparent; }
    :root {
      --bg-primary: #0c0a09;
      --bg-secondary: #1c1917;
      --bg-tertiary: #292524;
      --text-primary: #d6d3d1;
      --text-secondary: #a8a29e;
      --text-muted: #78716c;
      --border: #374151;
      --accent: #a16207;
    }

    [data-theme="light"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f9fafb;
      --bg-tertiary: #f3f4f6;
      --text-primary: #111827;
      --text-secondary: #6b7280;
      --text-muted: #9ca3af;
      --border: #e5e7eb;
      --accent: #a16207;
    }

    html {
      background-color: var(--bg-primary);
    }
    body {
      font-family: 'JetBrains Mono', 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-weight: 400;
      overscroll-behavior: none;
      margin: 0;
      padding: 0;
    }
    .font-display { font-family: 'JetBrains Mono', 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace; }
    
    /* Subtle texture */
    .paper-texture::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
      opacity: 0.012;
      pointer-events: none;
      z-index: 9999;
    }
    
    /* Minimal styling for any remaining cards */
    .card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }
    .hide-scrollbar::-webkit-scrollbar { display: none; }
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes scaleIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    . { animation: fadeIn 0.2s ease; }
    . { animation: slideUp 0.3s ease; }
    . { animation: slideDown 0.3s ease; }
    . { animation: scaleIn 0.2s ease; }
    .animate-pulse { animation: pulse 2s ease infinite; }
    
    /* Staggered grid animation */
    .stagger-item { opacity: 0; animation: slideUp 0.4s ease forwards; }
    .stagger-item:nth-child(1) { animation-delay: 0ms; }
    .stagger-item:nth-child(2) { animation-delay: 30ms; }
    .stagger-item:nth-child(3) { animation-delay: 60ms; }
    .stagger-item:nth-child(4) { animation-delay: 90ms; }
    .stagger-item:nth-child(5) { animation-delay: 120ms; }
    .stagger-item:nth-child(6) { animation-delay: 150ms; }
    .stagger-item:nth-child(7) { animation-delay: 180ms; }
    .stagger-item:nth-child(8) { animation-delay: 210ms; }
    .stagger-item:nth-child(9) { animation-delay: 240ms; }
    .stagger-item:nth-child(n+10) { animation-delay: 270ms; }
    
    /* Focus & inputs */
    input:focus, textarea:focus, select:focus, button:focus-visible { outline: none; }
    .input-field {
      background: transparent;
      border: 1px solid var(--border);
    }
    .input-field:focus {
      border-color: var(--border);
    }
    .input-field::placeholder { color: #57534e; }
    
    /* Buttons - plain text links only */
    .btn-copper {
      color: var(--accent);
    }
    .btn-copper:hover {
      color: var(--text-primary);
    }
    
    /* Star rating */
    .star-rating { display: inline-flex; gap: 1px; }
    .star { cursor: pointer; transition: all 0.15s ease; }
    .star:hover { transform: scale(1.15); }
    
    /* Toast */
    @keyframes toastIn { from { opacity: 0; transform: translateY(100%); } to { opacity: 1; transform: translateY(0); } }
    @keyframes toastOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(100%); } }
    .toast-enter { animation: toastIn 0.3s ease; }
    .toast-exit { animation: toastOut 0.3s ease forwards; }
    
    /* Bottom nav for mobile */
    @media (max-width: 640px) {
      .mobile-bottom-nav {
        padding-bottom: env(safe-area-inset-bottom, 0);
      }
    }
    
    /* iOS standalone */
    @media all and (display-mode: standalone) {
      body { padding-top: env(safe-area-inset-top); }
      .mobile-bottom-nav { padding-bottom: calc(env(safe-area-inset-bottom) + 0.5rem); }
    }
  </style>
  <script>
    // Set initial theme immediately to avoid flash
    (function() {
      try {
        const saved = localStorage.getItem('theme-preference');
        const theme = saved || 'light';
        document.documentElement.setAttribute('data-theme', theme);
        // Also set a default background color immediately
        document.documentElement.style.backgroundColor = theme === 'light' ? '#ffffff' : '#0c0a09';
        document.body.style.backgroundColor = theme === 'light' ? '#ffffff' : '#0c0a09';
      } catch (e) {
        document.documentElement.setAttribute('data-theme', 'light');
        document.documentElement.style.backgroundColor = '#ffffff';
        if (document.body) {
          document.body.style.backgroundColor = '#ffffff';
        }
      }
    })();
  </script>
</head>
<body class="min-h-screen paper-texture">
  <div id="root"></div>
  
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    // New service worker available
                    window.dispatchEvent(new CustomEvent('sw-update', { detail: newWorker }));
                  }
                });
              }
            });
            
            // Check for updates every hour
            setInterval(() => {
              registration.update();
            }, 3600000);
          })
          .catch(e => console.log('SW failed:', e));
      });
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // ============ UTILITIES ============
    
    // Ingredient normalization utility
    let ingredientAliasMap = null;
    let unmatchedIngredients = new Set();
    
    const buildIngredientAliasMap = (ingredientsDb) => {
      if (ingredientAliasMap) return ingredientAliasMap;
      if (!ingredientsDb) return {};
      
      const map = {};
      ingredientsDb.categories?.forEach(cat => {
        cat.subcategories?.forEach(sub => {
          sub.items?.forEach(item => {
            const canonical = item.name.toLowerCase().trim();
            // Map canonical name to itself
            map[canonical] = canonical;
            // Map aliases to canonical name
            if (item.aliases && Array.isArray(item.aliases)) {
              item.aliases.forEach(alias => {
                map[alias.toLowerCase().trim()] = canonical;
              });
            }
          });
        });
      });
      ingredientAliasMap = map;
      return map;
    };
    
    const normalizeIngredient = (name, ingredientsDb) => {
      if (!name || typeof name !== 'string') return name;
      
      // Build alias map if needed
      const aliasMap = buildIngredientAliasMap(ingredientsDb);
      
      // Normalize: lowercase, trim, remove punctuation
      let normalized = name.toLowerCase().trim();
      // Remove common punctuation but keep spaces
      normalized = normalized.replace(/[.,;:!?'"()]/g, '');
      // Normalize multiple spaces to single space
      normalized = normalized.replace(/\s+/g, ' ');
      
      // Look up in alias map
      if (aliasMap[normalized]) {
        return aliasMap[normalized];
      }
      
      // If not found, track for debugging and return normalized version
      unmatchedIngredients.add(name);
      return normalized;
    };
    
    const Icon = ({ name, className = "w-5 h-5" }) => {
      const ref = useRef(null);
      useEffect(() => {
        if (ref.current && lucide.icons[name]) {
          ref.current.innerHTML = '';
          ref.current.appendChild(lucide.createElement(lucide.icons[name]));
        }
      }, [name]);
      return <span ref={ref} className={`inline-flex items-center justify-center ${className}`} />;
    };

    const StarRating = ({ rating = 0, onRate, size = "text-sm", readonly = false }) => {
      const [hover, setHover] = useState(0);
      return (
        <div className="star-rating">
          {[1, 2, 3, 4, 5].map((star) => (
            <span
              key={star}
              className={`star ${size} ${(hover || rating) >= star ? 'text-copper' : 'text-ink-700'} ${readonly ? 'cursor-default' : ''}`}
              onMouseEnter={() => !readonly && setHover(star)}
              onMouseLeave={() => !readonly && setHover(0)}
              onClick={() => !readonly && onRate?.(star)}
            >★</span>
          ))}
        </div>
      );
    };

    const storage = {
      get: (key) => { try { const v = localStorage.getItem(key); return v ? { value: v } : null; } catch { return null; } },
      set: (key, value) => { try { localStorage.setItem(key, value); } catch (e) { console.error(e); } }
    };

    // ============ TOAST SYSTEM ============
    
    const ToastContext = React.createContext();
    
    const ToastProvider = ({ children }) => {
      const [toasts, setToasts] = useState([]);
      
      const addToast = useCallback((message, type = 'default') => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type, exiting: false }]);
        setTimeout(() => {
          setToasts(prev => prev.map(t => t.id === id ? { ...t, exiting: true } : t));
          setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 300);
        }, 2500);
      }, []);
      
      return (
        <ToastContext.Provider value={addToast}>
          {children}
          <div className="fixed bottom-20 sm:bottom-6 left-4 right-4 sm:left-auto sm:right-6 z-50 flex flex-col gap-2 pointer-events-none">
            {toasts.map(toast => (
              <div
                key={toast.id}
                className={`${toast.exiting ? 'toast-exit' : 'toast-enter'} px-4 py-3 bg-ink-900 border border-ink-700 flex items-center gap-3 pointer-events-auto`}
              >
                {toast.type === 'success' && <Icon name="Check" className="w-4 h-4 text-emerald-400" />}
                {toast.type === 'error' && <Icon name="X" className="w-4 h-4 text-red-400" />}
                <span className="text-sm text-ink-200 font-light">{toast.message}</span>
              </div>
            ))}
          </div>
        </ToastContext.Provider>
      );
    };
    
    const useToast = () => React.useContext(ToastContext);

    // ============ CONSTANTS ============
    
    const SPIRIT_CATEGORIES = ['Gin', 'Vodka', 'Whiskey', 'Rum', 'Tequila', 'Brandy', 'Other'];
    const METHOD_OPTIONS = ['Shake', 'Stir', 'Build', 'Muddle', 'Blend'];
    const SORT_OPTIONS = [
      { value: 'name', label: 'A–Z' },
      { value: 'newest', label: 'Newest' },
      { value: 'rating', label: 'Top Rated' },
      { value: 'most-made', label: 'Most Made' },
      { value: 'ingredients', label: 'Fewest Ingredients' },
    ];
    
    // Detect method from instructions
    const detectMethod = (drink) => {
      const instr = (drink.instructions || '').toLowerCase();
      if (instr.includes('shake')) return 'Shake';
      if (instr.includes('stir')) return 'Stir';
      if (instr.includes('muddle')) return 'Muddle';
      if (instr.includes('blend')) return 'Blend';
      if (instr.includes('build') || instr.includes('pour') || instr.includes('top')) return 'Build';
      return null;
    };
    
    // Detect base spirit from ingredients
    const detectSpirit = (drink) => {
      const ings = drink.ingredients?.map(i => i.name.toLowerCase()).join(' ') || '';
      if (ings.includes('gin')) return 'Gin';
      if (ings.includes('vodka')) return 'Vodka';
      if (ings.match(/whiskey|whisky|bourbon|rye|scotch/)) return 'Whiskey';
      if (ings.includes('rum')) return 'Rum';
      if (ings.match(/tequila|mezcal/)) return 'Tequila';
      if (ings.match(/brandy|cognac/)) return 'Brandy';
      return 'Other';
    };
    
    // Extract 3-5 key modifiers from ingredients (vermouth, amaro, bitters, liqueurs)
    const extractModifiers = (drink, ingredientsDb) => {
      if (!drink.ingredients?.length || !ingredientsDb) return [];
      
      const modifiers = [];
      const modifierKeywords = [
        'vermouth', 'amaro', 'bitters', 'liqueur', 'chartreuse', 'campari', 'aperol',
        'cynar', 'fernet', 'benedictine', 'maraschino', 'cointreau', 'triple sec',
        'st germain', 'elderflower', 'domaine', 'allspice', 'peychaud', 'angostura',
        'orange bitters', 'chocolate bitters', 'aromatic bitters'
      ];
      
      // Get base spirits to exclude
      const spiritKeywords = ['gin', 'vodka', 'whiskey', 'whisky', 'bourbon', 'rye', 'scotch', 'rum', 'tequila', 'mezcal', 'brandy', 'cognac'];
      const citrusKeywords = ['lemon juice', 'lime juice', 'orange juice', 'grapefruit juice', 'citrus'];
      
      for (const ing of drink.ingredients) {
        if (!ing || !ing.name || typeof ing.name !== 'string') continue;
        const ingLower = ing.name.toLowerCase();
        const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
        
        // Skip base spirits and citrus
        const isSpirit = spiritKeywords.some(s => ingLower.includes(s));
        const isCitrus = citrusKeywords.some(c => ingLower.includes(c));
        if (isSpirit || isCitrus) continue;
        
        // Check if it's a modifier
        const isModifier = modifierKeywords.some(keyword => ingLower.includes(keyword));
        if (isModifier) {
          // Get display name from ingredients DB if available, otherwise use original
          let displayName = ing.name;
          if (ingredientsDb) {
            for (const category of ingredientsDb.categories || []) {
              for (const subcategory of category.subcategories || []) {
                for (const item of subcategory.items || []) {
                  const itemCanonical = normalizeIngredient(item.name, ingredientsDb);
                  if (itemCanonical === ingCanonical || 
                      item.aliases?.some(alias => normalizeIngredient(alias, ingredientsDb) === ingCanonical)) {
                    displayName = item.name;
                    break;
                  }
                }
              }
            }
          }
          
          // Avoid duplicates
          if (!modifiers.find(m => normalizeIngredient(m, ingredientsDb) === ingCanonical)) {
            modifiers.push(displayName);
          }
        }
      }
      
      // Prioritize: Vermouth > Amaro > Bitters > Other liqueurs
      const priority = (name) => {
        const n = name.toLowerCase();
        if (n.includes('vermouth')) return 1;
        if (n.includes('amaro') || n.includes('cynar') || n.includes('fernet') || n.includes('campari') || n.includes('aperol')) return 2;
        if (n.includes('bitters')) return 3;
        return 4;
      };
      
      modifiers.sort((a, b) => priority(a) - priority(b));
      
      // Return 3-5 items max
      return modifiers.slice(0, 5);
    };
    
    const COMMON_INGREDIENTS = [
      'Gin', 'Vodka', 'Rum', 'Tequila', 'Bourbon', 'Rye Whiskey', 'Scotch', 'Cognac', 'Mezcal',
      'Sweet Vermouth', 'Dry Vermouth', 'Campari', 'Aperol', 'Cointreau', 'Green Chartreuse',
      'Maraschino Liqueur', 'Simple Syrup', 'Honey Syrup', 'Agave', 'Angostura Bitters',
      'Orange Bitters', 'Lime Juice', 'Lemon Juice', 'Club Soda', 'Tonic Water'
    ];

    // ============ UNIT CONVERSION ============
    
    // Unit conversion utilities with intelligent rounding
    const parseMeasure = (measure) => {
      if (!measure) return { value: 0, unit: '', isFraction: false };
      
      const measureStr = measure.toString().trim();
      
      // Handle common non-numeric measures (dash, dashes, splash, rinse, etc.)
      const nonNumericUnits = ['dash', 'dashes', 'splash', 'rinse', 'drops', 'pinch', 'whole', 'leaves', 'barspoon', 'barspoons'];
      for (const unit of nonNumericUnits) {
        if (measureStr.toLowerCase().includes(unit)) {
          return { value: null, unit: measureStr, isFraction: false };
        }
      }
      
      // Extract number and unit
      const match = measureStr.match(/^([\d\s\/\.]+)\s*(ml|oz|oz\.|fl\s*oz)?$/i);
      if (!match) return { value: 0, unit: measureStr, isFraction: false };
      
      const numPart = match[1].trim();
      const unitPart = (match[2] || '').trim().toLowerCase();
      
      // Parse fractions and decimals
      let value = 0;
      let isFraction = false;
      
      if (numPart.includes('/')) {
        // Handle fractions like "1/2", "1 1/2", "3/4"
        const parts = numPart.split(/\s+/);
        for (const part of parts) {
          if (part.includes('/')) {
            const [num, den] = part.split('/').map(Number);
            value += num / den;
            isFraction = true;
          } else {
            value += Number(part) || 0;
          }
        }
      } else {
        value = Number(numPart) || 0;
      }
      
      // Determine base unit
      const baseUnit = unitPart.includes('ml') ? 'ml' : 'oz';
      
      return { value, unit: baseUnit, isFraction, originalUnit: unitPart };
    };

    const convertMeasure = (measure, targetUnit) => {
      const parsed = parseMeasure(measure);

      // If it's a non-numeric measure, return as-is
      if (parsed.value === null) return measure;

      // If already in target unit or no value, return original
      if (!parsed.value || (targetUnit === 'oz' && parsed.unit === 'oz') || (targetUnit === 'ml' && parsed.unit === 'ml')) {
        return measure;
      }

      // Convert using precise conversion: 1 oz = 29.5735 ml
      const OZ_TO_ML = 29.5735;
      const ML_TO_OZ = 1 / OZ_TO_ML;

      // Convert oz to ml
      if (parsed.unit === 'oz' && targetUnit === 'ml') {
        const mlValue = parsed.value * OZ_TO_ML;
        // Round to nearest 2.5ml or 5ml for readability, never show decimals like 29.57
        if (mlValue < 2.5) {
          return `${Math.round(mlValue * 2) / 2} ml`; // Round to nearest 0.5ml for small amounts
        }
        // Round to nearest 2.5ml for better readability
        const rounded = Math.round(mlValue / 2.5) * 2.5;
        // Format as integer if whole number, otherwise show one decimal
        return `${rounded % 1 === 0 ? rounded : rounded.toFixed(1)} ml`;
      }

      // Convert ml to oz
      if (parsed.unit === 'ml' && targetUnit === 'oz') {
        const ozValue = parsed.value * ML_TO_OZ;
        // Round to common cocktail decimals: 0.25, 0.5, 0.75, 1, 1.5, 2, 2.5, etc.
        const commonValues = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2.75, 3];
        let closest = commonValues[0];
        let minDiff = Math.abs(ozValue - closest);

        for (const val of commonValues) {
          const diff = Math.abs(ozValue - val);
          if (diff < minDiff) {
            minDiff = diff;
            closest = val;
          }
        }

        // If very close to a common value (< 0.05 oz difference), use it
        if (minDiff < 0.05) {
          // Format as fractions for readability
          if (closest === 0.25) return '1/4 oz';
          if (closest === 0.5) return '1/2 oz';
          if (closest === 0.75) return '3/4 oz';
          if (closest === 1.25) return '1 1/4 oz';
          if (closest === 1.5) return '1 1/2 oz';
          if (closest === 1.75) return '1 3/4 oz';
          if (closest === 2.25) return '2 1/4 oz';
          if (closest === 2.5) return '2 1/2 oz';
          if (closest === 2.75) return '2 3/4 oz';
          return `${closest} oz`;
        }

        // Otherwise round to one decimal max
        const rounded = Math.round(ozValue * 4) / 4; // Round to nearest 0.25
        return `${rounded} oz`;
      }

      return measure;
    };

    // ============ MAIN APP ============
    
    const App = () => {
      const [view, setView] = useState('recipesHub');
      const [curatedDrinks, setCuratedDrinks] = useState([]);
      const [customDrinks, setCustomDrinks] = useState([]);
      // Multiple bars support
      const [bars, setBars] = useState([]);
      const [activeBarId, setActiveBarId] = useState(null);
      const [keepers, setKeepers] = useState(new Set()); // Binary flag: recipes that "stood out"
      const [searchTerm, setSearchTerm] = useState('');
      const [loading, setLoading] = useState(true);
      const [selectedDrink, setSelectedDrink] = useState(null);
      const [selectedIngredient, setSelectedIngredient] = useState(null);
      const [showAddDrink, setShowAddDrink] = useState(false);
      const [editingDrink, setEditingDrink] = useState(null);
      const [showImportExport, setShowImportExport] = useState(false);
      const [filters, setFilters] = useState({
        spirits: [],
        methods: [],
        glasses: [],
        tags: [],
        categories: []
      });
      const [filtersExpanded, setFiltersExpanded] = useState(false);
      const [sortBy, setSortBy] = useState('name');
      const [madeCounts, setMadeCounts] = useState({}); // Track how many times each recipe was made
      const [showConfirmDelete, setShowConfirmDelete] = useState(null);
      const [ingredientsDb, setIngredientsDb] = useState(null);
      const [showSettings, setShowSettings] = useState(false);
      const [showImportShared, setShowImportShared] = useState(false);
      const [sharedRecipeData, setSharedRecipeData] = useState(null);
      const [collections, setCollections] = useState([]);
      const [showShoppingList, setShowShoppingList] = useState(null);
      const [updateAvailable, setUpdateAvailable] = useState(false);
      const [waitingWorker, setWaitingWorker] = useState(null);
      const [unitPreference, setUnitPreference] = useState(() => {
        const saved = storage.get('unit-preference');
        return saved?.value === 'ml' ? 'ml' : 'oz';
      });
      const [theme, setTheme] = useState(() => {
        const saved = storage.get('theme-preference');
        if (saved?.value) return saved.value;
        // Default to light mode
        return 'light';
      });
      const mainRef = useRef(null);
      const toast = useToast();

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Escape') {
            if (showConfirmDelete) setShowConfirmDelete(null);
            else if (selectedDrink) setSelectedDrink(null);
            else if (showAddDrink) setShowAddDrink(false);
            else if (showImportExport) setShowImportExport(false);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedDrink, showAddDrink, showImportExport, showConfirmDelete]);

      // Scroll to top on view change
      useEffect(() => {
        mainRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }, [view]);
      
      // Handle service worker updates
      useEffect(() => {
        const handleUpdate = (e) => {
          setWaitingWorker(e.detail);
          setUpdateAvailable(true);
        };
        
        window.addEventListener('sw-update', handleUpdate);
        
        // Check if there's a waiting worker on load
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.ready.then(registration => {
            if (registration.waiting) {
              setWaitingWorker(registration.waiting);
              setUpdateAvailable(true);
            }
          });
        }
        
        return () => window.removeEventListener('sw-update', handleUpdate);
      }, []);
      
      const reloadForUpdate = () => {
        if (waitingWorker) {
          waitingWorker.postMessage({ type: 'SKIP_WAITING' });
          waitingWorker.addEventListener('statechange', () => {
            if (waitingWorker.state === 'activated') {
              window.location.reload();
            }
          });
        } else {
          window.location.reload();
        }
      };

      // Load data
      useEffect(() => {
        // Set a timeout to ensure loading state doesn't stay true forever
        const timeout = setTimeout(() => {
          console.warn('Data loading timeout - rendering app anyway');
          setLoading(false);
        }, 10000); // 10 second timeout
        
        loadCuratedCocktails();
        loadIngredientsDb();
        loadUserData();
        
        return () => clearTimeout(timeout);
      }, []);

      const loadCuratedCocktails = async () => {
        try {
          const response = await fetch('./cocktails.json');
          if (!response.ok) {
            throw new Error(`Failed to load cocktails: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          setCuratedDrinks(data);
        } catch (error) {
          console.error('Failed to load cocktails:', error);
          // Set empty array as fallback
          setCuratedDrinks([]);
        } finally {
          setLoading(false);
        }
      };

      const loadIngredientsDb = async () => {
        try {
          const response = await fetch('./ingredients.json');
          if (!response.ok) {
            throw new Error(`Failed to load ingredients: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          setIngredientsDb(data);
          // Build alias map when ingredients DB loads
          buildIngredientAliasMap(data);
        } catch (error) {
          console.error('Failed to load ingredients:', error);
          // Set empty object as fallback
          setIngredientsDb({ categories: [] });
        }
      };

      // Migration: Convert old favorites/saved/ratings to new system
      const migrateRatingSystem = () => {
        const migrated = storage.get('rating-system-migrated');
        if (migrated?.value === 'true') return; // Already migrated
        
        const saved = storage.get('saved-drinks');
        const fav = storage.get('favorites');
        const tryList = storage.get('want-to-try');
        const coll = storage.get('collections');
        
        const migratedKeepers = new Set();
        let migratedCollections = [];
        const toTryRecipeIds = new Set();
        
        // Migrate favorites → keepers
        if (fav?.value) {
          const favorites = JSON.parse(fav.value);
          favorites.forEach(id => migratedKeepers.add(id));
        }
        
        // Migrate saved/bookmarked → to_try collection
        if (saved?.value) {
          const savedIds = JSON.parse(saved.value);
          savedIds.forEach(id => toTryRecipeIds.add(id));
        }
        
        // Migrate wantToTry → to_try collection (merge)
        if (tryList?.value) {
          const wantToTryIds = JSON.parse(tryList.value);
          wantToTryIds.forEach(id => toTryRecipeIds.add(id));
        }
        
        // Load existing collections
        if (coll?.value) {
          migratedCollections = JSON.parse(coll.value).filter(c => !c.collectionType || c.collectionType === 'personal');
        }
        
        // Ensure to_try system collection exists
        const toTryCollection = migratedCollections.find(c => c.id === 'to_try');
        if (toTryCollection) {
          // Merge migrated IDs into existing to_try collection
          const existingIds = new Set(toTryCollection.recipeIds || []);
          toTryRecipeIds.forEach(id => existingIds.add(id));
          const updated = migratedCollections.map(c => 
            c.id === 'to_try' 
              ? { ...c, recipeIds: Array.from(existingIds) }
              : c
          );
          migratedCollections = updated;
        } else {
          // Create to_try system collection
          migratedCollections.push({
            id: 'to_try',
            name: 'Try',
            description: 'Recipes you want to try',
            collectionType: 'personal',
            recipeIds: Array.from(toTryRecipeIds)
          });
        }
        
        // Save migrated data
        if (migratedKeepers.size > 0) {
          saveData('keepers', Array.from(migratedKeepers));
        }
        if (migratedCollections.length > 0) {
          saveData('collections', migratedCollections);
        }
        
        // Mark as migrated and clean up old data
        storage.set('rating-system-migrated', 'true');
        storage.set('saved-drinks', ''); // Clear old data
        storage.set('favorites', '');
        storage.set('want-to-try', '');
        storage.set('ratings', '');
      };

      const loadUserData = () => {
        try {
          migrateToBars();
          migrateRatingSystem();
          
          const custom = storage.get('custom-drinks');
          const keep = storage.get('keepers');
          const coll = storage.get('collections');
          const made = storage.get('made-counts');
          
          if (custom?.value) setCustomDrinks(JSON.parse(custom.value));
          if (keep?.value) setKeepers(new Set(JSON.parse(keep.value)));
          if (coll?.value) {
            // Only load personal collections (curated are system-defined)
            const loaded = JSON.parse(coll.value);
            setCollections(loaded.filter(c => !c.collectionType || c.collectionType === 'personal'));
          }
          if (made?.value) setMadeCounts(JSON.parse(made.value));
        } catch (err) {
          console.error('Load error:', err);
        }
      };
      
      // Save filters and sort per view
      useEffect(() => {
        if (view && (view === 'browse' || view === 'keepers' || view === 'toTry' || view === 'canMake' || view === 'almostMake' || view === 'custom')) {
          storage.set(`filters-${view}`, JSON.stringify(filters));
          storage.set(`sort-${view}`, sortBy);
        }
      }, [filters, sortBy, view]);

      // Save unit preference
      useEffect(() => {
        storage.set('unit-preference', unitPreference);
      }, [unitPreference]);

      // Save theme preference and apply to document
      useEffect(() => {
        storage.set('theme-preference', theme);
        document.documentElement.setAttribute('data-theme', theme);
      }, [theme]);

      // Lock body scroll when modals are open
      useEffect(() => {
        if (selectedDrink || showAddDrink || showImportExport || showConfirmDelete || showImportShared) {
          document.body.style.overflow = 'hidden';
        } else {
          document.body.style.overflow = '';
        }
        return () => {
          document.body.style.overflow = '';
        };
      }, [selectedDrink, showAddDrink, showImportExport, showConfirmDelete, showImportShared]);

      const saveData = (key, data) => storage.set(key, JSON.stringify(data));

      // Migration: Convert old single inventory to bars system
      const migrateToBars = () => {
        const oldInv = storage.get('bar-inventory');
        const barsData = storage.get('bars');
        const activeBar = storage.get('active-bar-id');
        
        // If bars already exist, we're already migrated
        if (barsData?.value) {
          const loadedBars = JSON.parse(barsData.value);
          setBars(loadedBars);
          const savedActiveId = activeBar?.value;
          // Find main bar or first bar
          const mainBar = loadedBars.find(b => b.isMain) || loadedBars[0];
          setActiveBarId(savedActiveId && loadedBars.find(b => b.id === savedActiveId) ? savedActiveId : (mainBar?.id || null));
          return;
        }
        
        // Migration: Convert old inventory to "Home" bar
        if (oldInv?.value) {
          const oldInventory = JSON.parse(oldInv.value);
          const homeBar = {
            id: `bar-${Date.now()}`,
            name: 'Home',
            isMain: true,
            inventory: oldInventory,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          setBars([homeBar]);
          setActiveBarId(homeBar.id);
          saveData('bars', [homeBar]);
          saveData('active-bar-id', homeBar.id);
        } else {
          // No existing inventory - create default Home bar
          const homeBar = {
            id: `bar-${Date.now()}`,
            name: 'Home',
            isMain: true,
            inventory: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          setBars([homeBar]);
          setActiveBarId(homeBar.id);
          saveData('bars', [homeBar]);
          saveData('active-bar-id', homeBar.id);
        }
      };

      // Automatic daily backup
      const performAutomaticBackup = () => {
        try {
          const backup = {
            schema: 'barkeep-v1',
            version: '1.0.0',
            exportDate: new Date().toISOString(),
            data: {
              customDrinks,
              bars,
              activeBarId,
            keepers: Array.from(keepers),
              collections,
              madeCounts
            }
          };
          
          const backups = JSON.parse(storage.get('auto-backups')?.value || '[]');
          backups.push(backup);
          
          // Keep only last 7 backups
          const trimmed = backups.slice(-7);
          
          storage.set('auto-backups', JSON.stringify(trimmed));
          storage.set('last-backup-date', new Date().toISOString().split('T')[0]);
        } catch (err) {
          console.error('Auto backup failed:', err);
        }
      };
      
      // Check if backup is needed (daily) - run after data loads
      useEffect(() => {
        if (loading) return; // Wait for data to load
        
        const today = new Date().toISOString().split('T')[0];
        const lastBackup = storage.get('last-backup-date')?.value;
        
        if (lastBackup !== today) {
          // Perform backup after a short delay to ensure all data is loaded
          const timer = setTimeout(() => {
            performAutomaticBackup();
          }, 3000);
          return () => clearTimeout(timer);
        }
      }, [loading]); // Run when data finishes loading
      
      // Export everything
      const exportEverything = () => {
        const data = {
          schema: 'barkeep-v1',
          version: '1.1.0',
          exportDate: new Date().toISOString(),
          data: {
            customDrinks,
            bars,
            activeBarId,
            keepers: Array.from(keepers),
            collections,
            madeCounts
          }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `barkeep-full-backup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        toast('Full backup downloaded', 'success');
      };

      const importEverything = (event, mergeMode = false) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            
            // Handle both old format and new format
            const data = imported.data || imported;
            
            if (mergeMode) {
              // Merge mode: combine with existing data
              if (data.customDrinks) {
                const merged = [...customDrinks, ...data.customDrinks.filter(d => !customDrinks.some(existing => existing.id === d.id))];
                setCustomDrinks(merged);
                saveData('custom-drinks', merged);
              }
              // Handle bars (new format) or barInventory (old format)
              if (data.bars) {
                // Merge bars - avoid duplicates by id
                const existingIds = new Set(bars.map(b => b.id));
                const merged = [...bars, ...data.bars.filter(b => !existingIds.has(b.id))];
                saveBars(merged);
                if (data.activeBarId && merged.find(b => b.id === data.activeBarId)) {
                  saveActiveBarId(data.activeBarId);
                }
              } else if (data.barInventory) {
                // Old format: merge into active bar or create new bar
                const activeBar = getActiveBar();
                if (activeBar) {
                  const existingIds = new Set(activeBar.inventory.map(i => i.id));
                  const merged = [...activeBar.inventory, ...data.barInventory.filter(i => !existingIds.has(i.id))];
                  updateActiveBarInventory(merged);
                }
              }
              // Handle keepers (new format) or migrate from old format
              if (data.keepers) {
                const merged = new Set([...keepers, ...data.keepers]);
                setKeepers(merged);
                saveData('keepers', Array.from(merged));
              } else {
                // Migrate old favorites to keepers
                if (data.favorites) {
                  const merged = new Set([...keepers, ...data.favorites]);
                  setKeepers(merged);
                  saveData('keepers', Array.from(merged));
                }
              }
              
              // Handle to_try collection migration from old saved/wantToTry
              if (data.collections) {
                const merged = [...collections, ...data.collections.filter(c => !collections.some(existing => existing.id === c.id))];
                
                // Migrate old saved/wantToTry to to_try collection
                const toTryIds = new Set();
                if (data.savedDrinks) toTryIds.add(...data.savedDrinks);
                if (data.wantToTry) toTryIds.add(...data.wantToTry);
                
                if (toTryIds.size > 0) {
                  let toTryColl = merged.find(c => c.id === 'to_try');
                  if (!toTryColl) {
                    toTryColl = {
                      id: 'to_try',
                      name: 'Try',
                      description: 'Recipes you want to try',
                      collectionType: 'personal',
                      recipeIds: []
                    };
                    merged.push(toTryColl);
                  }
                  const existingIds = new Set(toTryColl.recipeIds || []);
                  toTryIds.forEach(id => existingIds.add(id));
                  const updated = merged.map(c => 
                    c.id === 'to_try' ? { ...c, recipeIds: Array.from(existingIds) } : c
                  );
                  setCollections(updated);
                  saveData('collections', updated);
                } else {
                  setCollections(merged);
                  saveData('collections', merged);
                }
              }
              if (data.collections) {
                const merged = [...collections, ...data.collections.filter(c => !collections.some(existing => existing.id === c.id))];
                setCollections(merged);
                saveData('collections', merged);
              }
              if (data.madeCounts) {
                const merged = { ...madeCounts, ...data.madeCounts };
                setMadeCounts(merged);
                saveData('made-counts', merged);
              }
              toast('Data merged successfully', 'success');
            } else {
              // Replace mode: overwrite existing data
              if (data.customDrinks) { setCustomDrinks(data.customDrinks); saveData('custom-drinks', data.customDrinks); }
              if (data.bars) {
                saveBars(data.bars);
                if (data.activeBarId && data.bars.find(b => b.id === data.activeBarId)) {
                  saveActiveBarId(data.activeBarId);
                } else {
                  const mainBar = data.bars.find(b => b.isMain) || data.bars[0];
                  if (mainBar) saveActiveBarId(mainBar.id);
                }
              } else if (data.barInventory) {
                // Old format: replace active bar inventory or create default bar
                const homeBar = {
                  id: `bar-${Date.now()}`,
                  name: 'Home',
                  isMain: true,
                  inventory: data.barInventory,
                  createdAt: new Date().toISOString(),
                  updatedAt: new Date().toISOString()
                };
                saveBars([homeBar]);
                saveActiveBarId(homeBar.id);
              }
              // Handle keepers (new format) or migrate from old format
              if (data.keepers) {
                setKeepers(new Set(data.keepers));
                saveData('keepers', data.keepers);
              } else if (data.favorites) {
                // Migrate old favorites to keepers
                setKeepers(new Set(data.favorites));
                saveData('keepers', data.favorites);
              }
              
              // Handle collections and migrate old saved/wantToTry to to_try
              if (data.collections) {
                let updatedCollections = data.collections;
                
                // Migrate old saved/wantToTry to to_try collection
                const toTryIds = new Set();
                if (data.savedDrinks) data.savedDrinks.forEach(id => toTryIds.add(id));
                if (data.wantToTry) data.wantToTry.forEach(id => toTryIds.add(id));
                
                if (toTryIds.size > 0) {
                  let toTryColl = updatedCollections.find(c => c.id === 'to_try');
                  if (!toTryColl) {
                    toTryColl = {
                      id: 'to_try',
                      name: 'Try',
                      description: 'Recipes you want to try',
                      collectionType: 'personal',
                      recipeIds: Array.from(toTryIds)
                    };
                    updatedCollections.push(toTryColl);
                  } else {
                    const existingIds = new Set(toTryColl.recipeIds || []);
                    toTryIds.forEach(id => existingIds.add(id));
                    updatedCollections = updatedCollections.map(c => 
                      c.id === 'to_try' ? { ...c, recipeIds: Array.from(existingIds) } : c
                    );
                  }
                }
                
                setCollections(updatedCollections);
                saveData('collections', updatedCollections);
              }
              if (data.madeCounts) { setMadeCounts(data.madeCounts); saveData('made-counts', data.madeCounts); }
              toast('Data replaced successfully', 'success');
            }
            
            // Reload to refresh UI
            loadUserData();
          } catch (err) {
            console.error('Import error:', err);
            toast('Failed to import data', 'error');
          }
        };
        reader.readAsText(file);
      };

      // Helpers
      const getAllDrinks = () => [...curatedDrinks.map(d => ({...d, source: 'curated'})), ...customDrinks.map(d => ({...d, source: 'custom'}))];

      // Bars management helpers
      const getActiveBar = () => bars.find(b => b.id === activeBarId) || bars.find(b => b.isMain) || bars[0] || null;
      const getActiveBarInventory = () => {
        const activeBar = getActiveBar();
        return activeBar?.inventory || [];
      };

      // Save bars to storage
      const saveBars = (updatedBars) => {
        setBars(updatedBars);
        saveData('bars', updatedBars);
      };

      // Save active bar id
      const saveActiveBarId = (id) => {
        setActiveBarId(id);
        saveData('active-bar-id', id);
      };

      // Update active bar inventory
      const updateActiveBarInventory = (inventory) => {
        const updatedBars = bars.map(b => {
          if (b.id === activeBarId) {
            return { ...b, inventory, updatedAt: new Date().toISOString() };
          }
          return b;
        });
        saveBars(updatedBars);
      };

      const canMakeDrink = (drink) => {
        if (!drink.ingredients?.length) return false;
        const barInventory = getActiveBarInventory();
        const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
        return drink.ingredients.every(ing => {
          const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
          return invCanonical.has(ingCanonical);
        });
      };

      const getMissingCount = (drink) => {
        if (!drink.ingredients?.length) return 0;
        const barInventory = getActiveBarInventory();
        const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
        return drink.ingredients.filter(ing => {
          const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
          return !invCanonical.has(ingCanonical);
        }).length;
      };

      const getMakeableDrinks = () => getAllDrinks().filter(canMakeDrink);

      // Actions with toast feedback
      const toggleKeeper = (id) => {
        const newSet = new Set(keepers);
        const wasAdded = !newSet.has(id);
        wasAdded ? newSet.add(id) : newSet.delete(id);
        setKeepers(newSet);
        saveData('keepers', Array.from(newSet));
        toast(wasAdded ? 'Added to Keepers' : 'Removed from Keepers', 'success');
      };

      // Get or create to_try collection
      const getToTryCollection = () => {
        let toTry = collections.find(c => c.id === 'to_try');
        if (!toTry) {
          toTry = {
            id: 'to_try',
            name: 'Try',
            description: 'Recipes you want to try',
            collectionType: 'personal',
            recipeIds: []
          };
          const updated = [...collections, toTry];
          setCollections(updated);
          saveData('collections', updated);
        }
        return toTry;
      };

      // Toggle recipe in to_try collection
      const toggleToTry = (recipeId) => {
        if (!collections || !Array.isArray(collections)) return;
        let toTry = collections.find(c => c.id === 'to_try');
        let currentCollections = [...collections];
        
        // Create to_try collection if it doesn't exist
        if (!toTry) {
          toTry = {
            id: 'to_try',
            name: 'Try',
            description: 'Recipes you want to try',
            collectionType: 'personal',
            recipeIds: []
          };
          currentCollections.push(toTry);
        }
        
        const recipeIds = new Set(toTry.recipeIds || []);
        const wasAdded = !recipeIds.has(recipeId);
        
        if (wasAdded) {
          recipeIds.add(recipeId);
        } else {
          recipeIds.delete(recipeId);
        }
        
        const updatedCollections = currentCollections.map(c => 
          c.id === 'to_try'
            ? { ...c, recipeIds: Array.from(recipeIds) }
            : c
        );
        
        setCollections(updatedCollections);
        saveData('collections', updatedCollections);
        toast(wasAdded ? 'Added to Try' : 'Removed from Try', 'success');
      };

      // Check if recipe is in to_try collection
      const isInToTry = (recipeId) => {
        if (!collections || !Array.isArray(collections)) return false;
        const toTry = collections.find(c => c.id === 'to_try');
        return toTry?.recipeIds?.includes(recipeId) || false;
      };

      const addCustomDrink = (drink) => {
        const newDrink = { id: `custom-${Date.now()}`, ...drink, dateAdded: new Date().toISOString() };
        const updated = [...customDrinks, newDrink];
        setCustomDrinks(updated);
        saveData('custom-drinks', updated);
        setShowAddDrink(false);
        setEditingDrink(null);
        toast('Recipe saved', 'success');
      };

      const updateCustomDrink = (id, drink) => {
        const updated = customDrinks.map(d => 
          d.id === id 
            ? { ...d, ...drink, dateAdded: d.dateAdded || new Date().toISOString() }
            : d
        );
        setCustomDrinks(updated);
        saveData('custom-drinks', updated);
        setShowAddDrink(false);
        setEditingDrink(null);
        toast('Recipe updated', 'success');
      };

      const deleteCustomDrink = (id) => {
        const updated = customDrinks.filter(d => d.id !== id);
        setCustomDrinks(updated);
        saveData('custom-drinks', updated);
        // Remove from collections
        const updatedCollections = collections.map(coll => ({
          ...coll,
          recipeIds: coll.recipeIds.filter(rid => rid !== id)
        }));
        setCollections(updatedCollections);
        saveData('collections', updatedCollections);
        setSelectedDrink(null);
        setShowConfirmDelete(null);
        toast('Recipe deleted', 'success');
      };

      // Share recipe
      const shareRecipe = async (drink) => {
        // Convert ingredients to current unit preference
        const convertedIngredients = drink.ingredients?.map(i => ({
          ...i,
          measure: convertMeasure(i.measure, unitPreference)
        })) || [];
        
        const sharePayload = {
          schema: 'barkeep-recipe-v1',
          createdAt: new Date().toISOString(),
          recipe: {
            id: drink.id,
            name: drink.name,
            category: drink.category,
            glass: drink.glass,
            ingredients: convertedIngredients,
            instructions: drink.instructions,
            notes: drink.notes,
            image: drink.image,
            source: drink.source,
            // Origin fields (optional)
            originTitle: drink.originTitle,
            originAuthor: drink.originAuthor,
            originSourceType: drink.originSourceType,
            originUrl: drink.originUrl,
            originYear: drink.originYear,
            originNotes: drink.originNotes
          }
        };
        
        const shareText = `${drink.name}\n\nIngredients:\n${convertedIngredients.map(i => `• ${i.measure} ${i.name}`).join('\n')}\n\n${drink.instructions || ''}\n\n---\nShared from Barkeep`;
        
        // Try Web Share API first
        if (navigator.share) {
          try {
            await navigator.share({
              title: drink.name,
              text: shareText,
              url: window.location.href
            });
            toast('Recipe shared', 'success');
            return;
          } catch (err) {
            if (err.name !== 'AbortError') {
              // Fall through to clipboard
            }
          }
        }
        
        // Fallback to clipboard
        try {
          await navigator.clipboard.writeText(shareText);
          toast('Recipe copied to clipboard', 'success');
        } catch (err) {
          // Final fallback: show data for manual copy
          setSharedRecipeData(sharePayload);
          toast('Share data prepared', 'success');
        }
      };

      // Import shared recipe
      const importSharedRecipe = (sharedData, dedupeMode = 'new') => {
        try {
          if (!sharedData.recipe) {
            toast('Invalid recipe data', 'error');
            return;
          }
          
          const recipe = sharedData.recipe;
          const existingIndex = customDrinks.findIndex(d => d.id === recipe.id);
          
          // Preserve origin fields if they exist
          const recipeWithOrigin = {
            ...recipe,
            originTitle: recipe.originTitle,
            originAuthor: recipe.originAuthor,
            originSourceType: recipe.originSourceType,
            originUrl: recipe.originUrl,
            originYear: recipe.originYear,
            originNotes: recipe.originNotes
          };
          
          if (existingIndex !== -1 && dedupeMode === 'replace') {
            // Replace existing
            const updated = [...customDrinks];
            updated[existingIndex] = { ...recipeWithOrigin, dateAdded: customDrinks[existingIndex].dateAdded || new Date().toISOString() };
            setCustomDrinks(updated);
            saveData('custom-drinks', updated);
            toast('Recipe replaced', 'success');
          } else {
            // Add as new (or if doesn't exist)
            const newId = existingIndex !== -1 ? `custom-${Date.now()}` : recipe.id;
            const newDrink = { ...recipeWithOrigin, id: newId, dateAdded: new Date().toISOString(), source: 'custom' };
            const updated = [...customDrinks, newDrink];
            setCustomDrinks(updated);
            saveData('custom-drinks', updated);
            toast('Recipe imported', 'success');
          }
          
          setShowImportShared(false);
          setSharedRecipeData(null);
        } catch (err) {
          toast('Failed to import recipe', 'error');
        }
      };

      // Curated collections (rule-based, system collections)
      const CURATED_COLLECTIONS = [
        {
          id: 'curated-classics',
          name: 'Classics',
          description: 'Time-tested cocktails that every bartender should know',
          collectionType: 'curated',
          rules: {
            style: ['spirit-forward', 'sour']
          }
        },
        {
          id: 'curated-no-citrus',
          name: 'No Citrus',
          description: 'Cocktails without lemon, lime, or other citrus',
          collectionType: 'curated',
          rules: {
            hasCitrus: false
          }
        },
        {
          id: 'curated-stirred',
          name: 'Stirred',
          description: 'Cocktails that are stirred, not shaken',
          collectionType: 'curated',
          rules: {
            method: ['Stir']
          }
        },
        {
          id: 'curated-shaken',
          name: 'Shaken',
          description: 'Cocktails that are shaken',
          collectionType: 'curated',
          rules: {
            method: ['Shake']
          }
        },
        {
          id: 'curated-gin',
          name: 'Gin Cocktails',
          description: 'All cocktails featuring gin',
          collectionType: 'curated',
          rules: {
            baseSpirit: ['Gin']
          }
        },
        {
          id: 'curated-whiskey',
          name: 'Whiskey Cocktails',
          description: 'All cocktails featuring whiskey',
          collectionType: 'curated',
          rules: {
            baseSpirit: ['Whiskey']
          }
        },
        {
          id: 'curated-tiki',
          name: 'Tiki',
          description: 'Tropical and tiki-style cocktails',
          collectionType: 'curated',
          rules: {
            category: ['Tiki']
          }
        },
        {
          id: 'curated-spirit-forward',
          name: 'Spirit Forward',
          description: 'Cocktails where the spirit is the star',
          collectionType: 'curated',
          rules: {
            style: ['spirit-forward']
          }
        },
        {
          id: 'curated-coupes',
          name: 'Coupes & Cocktail Glasses',
          description: 'Cocktails served in coupes or cocktail glasses',
          collectionType: 'curated',
          rules: {
            glass: ['Coupe', 'Cocktail glass']
          }
        }
      ];

      // Evaluate if a drink matches curated collection rules
      const matchesCuratedCollection = (drink, collection) => {
        if (!collection.rules) return false;
        const rules = collection.rules;
        
        // Base spirit rule
        if (rules.baseSpirit && rules.baseSpirit.length > 0) {
          const spirit = detectSpirit(drink);
          if (!rules.baseSpirit.includes(spirit)) return false;
        }
        
        // Method rule
        if (rules.method && rules.method.length > 0) {
          const method = detectMethod(drink);
          if (!method || !rules.method.includes(method)) return false;
        }
        
        // Glass rule
        if (rules.glass && rules.glass.length > 0) {
          if (!drink.glass || !rules.glass.includes(drink.glass)) return false;
        }
        
        // Style rule
        if (rules.style && rules.style.length > 0) {
          const drinkStyle = drink.style?.toLowerCase();
          if (!drinkStyle || !rules.style.some(s => drinkStyle.includes(s.toLowerCase()))) return false;
        }
        
        // Category rule
        if (rules.category && rules.category.length > 0) {
          if (!drink.category || !rules.category.includes(drink.category)) return false;
        }
        
        // Has citrus rule
        if (rules.hasCitrus !== undefined) {
          const hasCitrus = drink.ingredients?.some(ing => {
            const name = ing.name.toLowerCase();
            return name.includes('lemon') || name.includes('lime') || name.includes('orange') || 
                   name.includes('grapefruit') || name.includes('citrus') || name.includes('juice');
          });
          if (rules.hasCitrus !== hasCitrus) return false;
        }
        
        // Tags rule (check if drink has any of the specified tags)
        if (rules.tags && rules.tags.length > 0) {
          // For now, tags rule is optional - if drink has tags, check them
          // Otherwise, skip this check (allows drinks without tags to match)
          const drinkTags = drink.tags || [];
          if (drinkTags.length > 0) {
            const hasMatchingTag = rules.tags.some(tag => drinkTags.includes(tag));
            if (!hasMatchingTag) return false;
          }
        }
        
        return true;
      };

      // Get all collections (curated + personal, including system collections)
      const getAllCollections = useMemo(() => {
        const personal = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
        return [...CURATED_COLLECTIONS, ...personal];
      }, [collections]);

      // Get system collections (to_try is a personal collection, keepers is a view)
      const getSystemCollections = () => {
        const toTry = collections.find(c => c.id === 'to_try') || {
          id: 'to_try',
          name: 'To Try',
          description: 'Recipes you want to try',
          collectionType: 'personal',
          recipeIds: []
        };
        return [toTry];
      };

      // Get recipes for a collection (rule-based for curated, recipeIds for personal)
      const getCollectionRecipes = useMemo(() => {
        return (collection) => {
          if (collection.collectionType === 'curated') {
            // Evaluate rules live
            return getAllDrinks().filter(drink => matchesCuratedCollection(drink, collection));
          } else {
            // Personal collection - use recipeIds
            return getAllDrinks().filter(d => collection.recipeIds?.includes(d.id));
          }
        };
      }, [curatedDrinks, customDrinks]);

      // Collections CRUD
      const addCollection = (name, description = '') => {
        const newCollection = {
          id: `collection-${Date.now()}`,
          name,
          description,
          recipeIds: [],
          collectionType: 'personal',
          createdAt: new Date().toISOString()
        };
        const updated = [...collections, newCollection];
        setCollections(updated);
        saveData('collections', updated);
        toast('Collection created', 'success');
      };

      const updateCollection = (id, updates) => {
        const updated = collections.map(c => c.id === id ? { ...c, ...updates } : c);
        setCollections(updated);
        saveData('collections', updated);
      };

      const deleteCollection = (id) => {
        // Don't allow deleting curated collections
        const collection = collections.find(c => c.id === id);
        if (collection?.collectionType === 'curated') {
          toast('Cannot delete curated collections', 'error');
          return;
        }
        const updated = collections.filter(c => c.id !== id);
        setCollections(updated);
        saveData('collections', updated);
        toast('Collection deleted', 'success');
      };

      const addRecipeToCollection = (recipeId, collectionId) => {
        // Don't allow adding to curated collections manually
        const collection = collections.find(c => c.id === collectionId) || CURATED_COLLECTIONS.find(c => c.id === collectionId);
        if (collection?.collectionType === 'curated') {
          toast('Curated collections update automatically', 'error');
          return;
        }
        const updated = collections.map(c => {
          if (c.id === collectionId && !c.recipeIds.includes(recipeId)) {
            return { ...c, recipeIds: [...c.recipeIds, recipeId] };
          }
          return c;
        });
        setCollections(updated);
        saveData('collections', updated);
        toast('Added to collection', 'success');
      };

      const removeRecipeFromCollection = (recipeId, collectionId) => {
        const updated = collections.map(c => {
          if (c.id === collectionId) {
            return { ...c, recipeIds: c.recipeIds.filter(id => id !== recipeId) };
          }
          return c;
        });
        setCollections(updated);
        saveData('collections', updated);
        toast('Removed from collection', 'success');
      };

      const addToInventory = (item) => {
        const barInventory = getActiveBarInventory();
        const canonicalName = normalizeIngredient(item, ingredientsDb);
        if (barInventory.some(i => normalizeIngredient(i.name, ingredientsDb) === canonicalName)) {
          toast('Already in your bar', 'error');
          return;
        }
        // Store with original casing for display, but matching uses canonical name
        const updated = [...barInventory, { id: Date.now(), name: item }];
        updateActiveBarInventory(updated);
        toast(`Added ${item}`, 'success');
      };

      const removeFromInventory = (id) => {
        const barInventory = getActiveBarInventory();
        const updated = barInventory.filter(i => i.id !== id);
        updateActiveBarInventory(updated);
      };

      // Bar management functions
      const createBar = (name) => {
        const newBar = {
          id: `bar-${Date.now()}`,
          name: name.trim(),
          isMain: bars.length === 0, // First bar is main
          inventory: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        const updated = [...bars, newBar];
        saveBars(updated);
        if (bars.length === 0) {
          saveActiveBarId(newBar.id);
        }
        toast('Bar created', 'success');
        return newBar;
      };

      const updateBar = (id, updates) => {
        const updated = bars.map(b => {
          if (b.id === id) {
            return { ...b, ...updates, updatedAt: new Date().toISOString() };
          }
          return b;
        });
        saveBars(updated);
        toast('Bar updated', 'success');
      };

      const deleteBar = (id) => {
        if (bars.length <= 1) {
          toast('Cannot delete the last bar', 'error');
          return;
        }
        const updated = bars.filter(b => b.id !== id);
        saveBars(updated);
        
        // Switch to main bar or first available if deleted bar was active
        if (activeBarId === id) {
          const mainBar = updated.find(b => b.isMain) || updated[0];
          saveActiveBarId(mainBar.id);
        }
        toast('Bar deleted', 'success');
      };

      const setMainBar = (id) => {
        // Only one bar can be main
        const updated = bars.map(b => ({
          ...b,
          isMain: b.id === id,
          updatedAt: b.id === id ? new Date().toISOString() : b.updatedAt
        }));
        saveBars(updated);
        toast('Main bar updated', 'success');
      };

      const duplicateBar = (id) => {
        const barToDuplicate = bars.find(b => b.id === id);
        if (!barToDuplicate) return;
        
        const newBar = {
          id: `bar-${Date.now()}`,
          name: `${barToDuplicate.name} (Copy)`,
          isMain: false,
          inventory: JSON.parse(JSON.stringify(barToDuplicate.inventory)), // Deep copy
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        const updated = [...bars, newBar];
        saveBars(updated);
        toast('Bar duplicated', 'success');
        return newBar;
      };

      // Random cocktail
      const pickRandom = () => {
        const drinks = displayDrinks;
        if (drinks.length === 0) return;
        const random = drinks[Math.floor(Math.random() * drinks.length)];
        setSelectedDrink(random);
      };

      // Filtered & sorted drinks
      const displayDrinks = useMemo(() => {
        if (!getAllDrinks) return [];
        let drinks = getAllDrinks();
        
        // Get to_try collection IDs
        const toTryCollection = (collections || []).find(c => c.id === 'to_try');
        const toTryIds = new Set(toTryCollection?.recipeIds || []);
        
        if (view === 'keepers') {
          drinks = drinks.filter(d => keepers && keepers.has(d.id));
        } else if (view === 'toTry') {
          drinks = drinks.filter(d => toTryIds.has(d.id));
        }
        else if (view === 'canMake') drinks = drinks.filter(d => canMakeDrink(d));
        else if (view === 'almostMake') drinks = drinks.filter(d => {
          const missing = getMissingCount(d);
          return missing > 0 && missing <= 2 && !canMakeDrink(d);
        });
        else if (view === 'custom') drinks = drinks.filter(d => d.source === 'custom');
        
        if (searchTerm.trim()) {
          const term = searchTerm.toLowerCase();
          drinks = drinks.filter(d => d.name.toLowerCase().includes(term) || d.ingredients?.some(i => i.name.toLowerCase().includes(term)));
        }
        
        // Apply multi-filters
        if (filters.spirits.length > 0) {
          drinks = drinks.filter(d => filters.spirits.includes(detectSpirit(d)));
        }
        
        if (filters.methods.length > 0) {
          drinks = drinks.filter(d => {
            const method = detectMethod(d);
            return method && filters.methods.includes(method);
          });
        }
        
        if (filters.glasses.length > 0) {
          drinks = drinks.filter(d => d.glass && filters.glasses.includes(d.glass));
        }
        
        if (filters.categories.length > 0) {
          drinks = drinks.filter(d => {
            const drinkCategory = d.category || d.ibaCategory;
            return drinkCategory && filters.categories.includes(drinkCategory);
          });
        }
        
        if (filters.tags.includes('canMake')) {
          drinks = drinks.filter(d => canMakeDrink(d));
        }
        if (filters.tags.includes('almostMake')) {
          drinks = drinks.filter(d => {
            const missing = getMissingCount(d);
            return missing > 0 && missing <= 2 && !canMakeDrink(d);
          });
        }
        if (filters.tags.includes('keepers')) {
          drinks = drinks.filter(d => keepers && keepers.has(d.id));
        }
        if (filters.tags.includes('toTry')) {
          drinks = drinks.filter(d => toTryIds.has(d.id));
        }
        
        // Sort
        drinks = [...drinks].sort((a, b) => {
          if (sortBy === 'newest') {
            const aDate = a.dateAdded ? new Date(a.dateAdded) : new Date(0);
            const bDate = b.dateAdded ? new Date(b.dateAdded) : new Date(0);
            return bDate - aDate;
          }
          if (sortBy === 'most-made') {
            return (madeCounts[b.id] || 0) - (madeCounts[a.id] || 0);
          }
          if (sortBy === 'ingredients') return (a.ingredients?.length || 0) - (b.ingredients?.length || 0);
          return a.name.localeCompare(b.name);
        });
        
        return drinks;
      }, [view, curatedDrinks, customDrinks, keepers, collections, bars, activeBarId, ingredientsDb, searchTerm, filters, sortBy, madeCounts, canMakeDrink, getMissingCount]);
      
      const toggleFilter = (category, value) => {
        setFilters(prev => {
          const newFilters = { ...prev };
          if (newFilters[category].includes(value)) {
            newFilters[category] = newFilters[category].filter(v => v !== value);
          } else {
            newFilters[category] = [...newFilters[category], value];
          }
          return newFilters;
        });
      };
      
      const clearFilters = () => {
        setFilters({ spirits: [], methods: [], glasses: [], tags: [], categories: [] });
        setSearchTerm('');
      };
      
      const hasActiveFilters = filters.spirits.length > 0 || filters.methods.length > 0 || filters.glasses.length > 0 || filters.tags.length > 0 || filters.categories.length > 0 || searchTerm.trim();
      
      // Get unique glass types from all drinks
      const availableGlasses = useMemo(() => {
        const glassesSet = new Set();
        const allDrinks = [...curatedDrinks.map(d => ({...d, source: 'curated'})), ...customDrinks.map(d => ({...d, source: 'custom'}))];
        allDrinks.forEach(drink => {
          if (drink.glass) glassesSet.add(drink.glass);
        });
        return Array.from(glassesSet).sort();
      }, [curatedDrinks, customDrinks]);

      // Get unique categories from all drinks
      const availableCategories = useMemo(() => {
        const categoriesSet = new Set();
        const allDrinks = [...curatedDrinks.map(d => ({...d, source: 'curated'})), ...customDrinks.map(d => ({...d, source: 'custom'}))];
        allDrinks.forEach(drink => {
          if (drink.category) categoriesSet.add(drink.category);
          if (drink.ibaCategory) categoriesSet.add(drink.ibaCategory);
        });
        return Array.from(categoriesSet).sort();
      }, [curatedDrinks, customDrinks]);

      const getAlmostMakeCount = () => {
        return getAllDrinks().filter(d => {
          const missing = getMissingCount(d);
          return missing > 0 && missing <= 2 && !canMakeDrink(d);
        }).length;
      };

      const navItems = [
        { id: 'recipesHub', label: 'Recipes', icon: 'LayoutGrid' },
        { id: 'inventory', label: 'Bar', icon: 'Wine', count: getActiveBarInventory().length },
        { id: 'browse', label: 'Browse', icon: 'Search' },
        { id: 'settings', label: 'Settings', icon: 'Settings' },
      ];

      return (
        <div className="min-h-screen flex flex-col pb-16 sm:pb-0 bg-ink-950">
          {/* Desktop Header */}
          <header className="hidden sm:block sticky top-0 z-40 bg-ink-950 border-b border-ink-700">
            <div className="max-w-6xl mx-auto px-6">
              <div className="flex items-center justify-between h-16">
                <h1 className="text-2xl font-bold text-ink-100 uppercase">Barkeep</h1>
                <div className="flex items-center gap-1">
                  {/* Theme Toggle */}
                  <button
                    onClick={() => setTheme(prev => prev === 'dark' ? 'light' : 'dark')}
                    className="p-2 text-ink-500 hover:text-ink-300"
                    title={`Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`}
                  >
                    <Icon name={theme === 'dark' ? 'Sun' : 'Moon'} className="w-4 h-4" />
                  </button>
                  {view === 'browse' && (
                    <button onClick={() => setShowAddDrink(true)} className="p-2 text-ink-500 hover:text-ink-300" title="New Recipe">
                      <Icon name="Plus" className="w-4 h-4" />
                    </button>
                  )}
                </div>
              </div>
              {(view !== 'recipesHub' && view !== 'settings' && view !== 'inventory' && view !== 'manageBars' && view !== 'browse') && (
                <nav className="flex gap-1 pb-3">
                  {navItems.map(item => (
                    <button
                      key={item.id}
                      onClick={() => {
                        setView(item.id);
                        if (item.id === 'browse') {
                          setSearchTerm('');
                        }
                      }}
                      className={`flex items-center gap-2 px-3 py-2 text-sm ${
                        view === item.id ? 'text-ink-100 font-bold' : 'text-ink-500 hover:text-ink-300'
                      }`}
                    >
                      <Icon name={item.icon} className="w-4 h-4" />
                      <span>{item.label}</span>
                      {item.count > 0 && (
                        <span className={`text-2xs px-1.5 py-0.5  ${view === item.id ? 'bg-copper/20 text-copper' : 'bg-transparent text-ink-500'}`}>
                          {item.count}
                        </span>
                      )}
                    </button>
                  ))}
                </nav>
              )}
            </div>
          </header>

          {/* Mobile Header */}
          <header className="sm:hidden sticky top-0 z-40 bg-ink-950 border-b border-ink-700">
            <div className="flex items-center justify-between px-4 h-14">
              {(view === 'recipesHub' || view === 'settings' || view === 'inventory' || view === 'manageBars' || view === 'browse') ? (
                <h1 className="text-xl font-bold text-ink-100 uppercase">Barkeep</h1>
              ) : (
                <button onClick={() => {
                  // Go back to Recipes Hub for personalized views, Browse for exploratory
                  if (view === 'keepers' || view === 'toTry' || view === 'canMake' || view === 'almostMake' || view === 'custom' || view === 'collections' || view?.startsWith('collection-')) {
                    setView('recipesHub');
                  } else {
                    setView('browse');
                  }
                }} className="flex items-center gap-2 text-ink-100">
                  ← <span className="text-xl font-bold uppercase">{view === 'keepers' || view === 'toTry' || view === 'canMake' || view === 'almostMake' || view === 'custom' || view === 'collections' || view?.startsWith('collection-') ? 'Recipes' : 'Browse'}</span>
                </button>
              )}
              <div className="flex items-center gap-1">
                {/* Theme Toggle */}
                <button
                  onClick={() => setTheme(prev => prev === 'dark' ? 'light' : 'dark')}
                  className="p-2 text-ink-500 hover:text-ink-300"
                  title={`Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`}
                >
                  <Icon name={theme === 'dark' ? 'Sun' : 'Moon'} className="w-4 h-4" />
                </button>
                {view === 'browse' && (
                  <button onClick={() => setShowAddDrink(true)} className="p-2 text-copper">
                    <Icon name="Plus" className="w-5 h-5" />
                  </button>
                )}
              </div>
            </div>
          </header>

          {/* Main Content */}
          <main ref={mainRef} className="flex-1 max-w-6xl mx-auto w-full px-4 sm:px-6 py-4 sm:py-6">
            {view === 'recipesHub' ? (
              <RecipesHub
                savedCount={keepers.size}
                favoritesCount={keepers.size}
                canMakeCount={getMakeableDrinks().length}
                almostMakeCount={getAlmostMakeCount()}
                wantToTryCount={(collections.find(c => c.id === 'to_try')?.recipeIds || []).length}
                customCount={customDrinks.length}
                allCount={getAllDrinks().length}
                collectionsCount={getAllCollections.length}
                onNavigate={(viewId) => {
                  setView(viewId);
                  setShowRecipesHub(false);
                }}
                getMakeableDrinks={getMakeableDrinks}
                getAlmostMakeableDrinks={() => getAllDrinks().filter(d => {
                  const missing = getMissingCount(d);
                  return missing > 0 && missing <= 2 && !canMakeDrink(d);
                })}
                getAllCollections={getAllCollections}
                getCollectionRecipes={getCollectionRecipes}
                onSelectDrink={setSelectedDrink}
                keepers={keepers}
                collections={collections}
                getMissingCount={getMissingCount}
                canMakeDrink={canMakeDrink}
                ingredientsDb={ingredientsDb}
                toggleKeeper={toggleKeeper}
                toggleToTry={toggleToTry}
                isInToTry={isInToTry}
                onCreateShoppingList={(drinks) => {
                  const ingredientCounts = {};
                  drinks.forEach(drink => {
                    const missing = drink.ingredients?.filter(ing => {
                      const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                      const barInventory = getActiveBarInventory();
                      const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
                      return !invCanonical.has(ingCanonical);
                    }) || [];
                    
                    missing.forEach(ing => {
                      const key = normalizeIngredient(ing.name, ingredientsDb);
                      if (!ingredientCounts[key]) {
                        ingredientCounts[key] = { name: ing.name, count: 0, recipes: [] };
                      }
                      if (!ingredientCounts[key].recipes.find(r => r.id === drink.id)) {
                        ingredientCounts[key].count++;
                        ingredientCounts[key].recipes.push({ id: drink.id, name: drink.name });
                      }
                    });
                  });
                  
                  const shoppingList = Object.values(ingredientCounts)
                    .sort((a, b) => b.count - a.count)
                    .map(item => `${item.name} (unlocks ${item.count} ${item.count === 1 ? 'recipe' : 'recipes'})`)
                    .join('\n');
                  
                  navigator.clipboard.writeText(shoppingList).then(() => {
                    toast('Shopping list copied to clipboard', 'success');
                  }).catch(() => {
                    setShowShoppingList(shoppingList);
                  });
                }}
              />
            ) : view === 'inventory' ? (
              <InventoryView 
                inventory={getActiveBarInventory()} 
                activeBar={getActiveBar()}
                bars={bars}
                onAdd={addToInventory} 
                onRemove={removeFromInventory}
                onSwitchBar={(barId) => saveActiveBarId(barId)}
                onManageBars={() => setView('manageBars')}
                ingredientsDb={ingredientsDb}
                getAllDrinks={getAllDrinks}
                canMakeDrink={canMakeDrink}
                getActiveBarInventory={getActiveBarInventory}
                normalizeIngredient={normalizeIngredient}
              />
            ) : view === 'manageBars' ? (
              <ManageBarsView
                bars={bars}
                activeBarId={activeBarId}
                onCreateBar={createBar}
                onUpdateBar={updateBar}
                onDeleteBar={deleteBar}
                onSetMainBar={setMainBar}
                onDuplicateBar={duplicateBar}
                onSwitchBar={(barId) => {
                  saveActiveBarId(barId);
                  setView('inventory');
                }}
                onClose={() => setView('inventory')}
              />
            ) : view === 'settings' ? (
              <SettingsView
                onClose={() => setView('recipesHub')}
                onExport={exportEverything}
                onImport={importEverything}
                unmatchedIngredients={Array.from(unmatchedIngredients)}
                onImportShared={() => setShowImportShared(true)}
                unitPreference={unitPreference}
                onToggleUnit={() => setUnitPreference(prev => prev === 'oz' ? 'ml' : 'oz')}
              />
            ) : view === 'collections' ? (
              <CollectionsView
                collections={getAllCollections}
                allDrinks={getAllDrinks()}
                getCollectionRecipes={getCollectionRecipes}
                onAddCollection={addCollection}
                onUpdateCollection={updateCollection}
                onDeleteCollection={deleteCollection}
                onRemoveRecipe={removeRecipeFromCollection}
                onNavigate={(collectionId) => {
                  if (collectionId === 'keepers') {
                    setView('keepers');
                  } else {
                    setView(`collection-${collectionId}`);
                  }
                }}
                onNavigateToRecipe={(drink) => setSelectedDrink(drink)}
                keepers={keepers}
              />
            ) : view?.startsWith('collection-') ? (
              <CollectionDetailView
                collection={getAllCollections.find(c => c.id === view.replace('collection-', ''))}
                allDrinks={getAllDrinks()}
                getCollectionRecipes={getCollectionRecipes}
                onNavigateBack={() => setView('collections')}
                onNavigateToRecipe={(drink) => setSelectedDrink(drink)}
                onRemoveRecipe={removeRecipeFromCollection}
                canMakeDrink={canMakeDrink}
                getMissingCount={getMissingCount}
                keepers={keepers}
                isInToTry={isInToTry}
                toggleKeeper={toggleKeeper}
                toggleToTry={toggleToTry}
                ingredientsDb={ingredientsDb}
              />
            ) : (
              <>
                {/* Search & Filters - Sticky Container */}
                <div className="sticky top-0 z-30 bg-ink-950 pb-3 -mx-4 px-4 pt-2 mb-5 border-b border-ink-700">
                  <div className="flex flex-col gap-3">
                    <div className="flex gap-2">
                      <div className="flex-1 relative">
                        <Icon name="Search" className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-ink-600" />
                        <input
                          type="text"
                          value={searchTerm}
                          onChange={(e) => setSearchTerm(e.target.value)}
                          placeholder="Search recipes or ingredients..."
                          className="w-full pl-10 pr-10 py-3 input-field  text-sm text-ink-200 font-light"
                        />
                        {searchTerm && (
                          <button onClick={() => setSearchTerm('')} className="absolute right-3 top-1/2 -translate-y-1/2 text-ink-600 hover:text-ink-400">
                            <Icon name="X" className="w-4 h-4" />
                          </button>
                        )}
                      </div>
                      <button
                        onClick={pickRandom}
                        className="px-3 py-3 input-field  text-ink-500 hover:text-ink-300 transition-colors"
                        title="Random cocktail"
                      >
                        <Icon name="Shuffle" className="w-4 h-4" />
                      </button>
                    </div>
                    
                    {/* Filter Toggle Button */}
                    <div className="flex items-center justify-between">
                      <button
                        onClick={() => setFiltersExpanded(!filtersExpanded)}
                        className="flex items-center gap-2 px-4 py-2 text-sm text-ink-400 hover:text-ink-200 transition-colors"
                      >
                        <Icon name={filtersExpanded ? "ChevronUp" : "ChevronDown"} className="w-4 h-4" />
                        <span>Filters</span>
                        {hasActiveFilters && (
                          <span className="text-xs text-ink-500 ml-1">
                            ({filters.spirits.length + filters.methods.length + filters.glasses.length + filters.tags.length + filters.categories.length} active)
                          </span>
                        )}
                      </button>
                      {/* Sort (always visible) */}
                      <div className="flex items-center gap-2">
                        <span className="text-2xs text-ink-600 uppercase tracking-wider">Sort:</span>
                        <select
                          value={sortBy}
                          onChange={(e) => setSortBy(e.target.value)}
                          className="px-3 py-1.5 input-field  text-xs text-ink-400 font-light bg-transparent appearance-none cursor-pointer"
                        >
                          {SORT_OPTIONS.map(opt => (
                            <option key={opt.value} value={opt.value} className="bg-ink-900">{opt.label}</option>
                          ))}
                        </select>
                      </div>
                    </div>
                    
                    {/* Expandable Filter Drawer */}
                    {filtersExpanded && (
                    <div className="space-y-4 pt-3 border-t border-ink-700">
                      {/* Categories */}
                      {availableCategories.length > 0 && (
                        <div className="flex flex-wrap gap-1.5 items-baseline">
                          <span className="text-2xs text-ink-600 uppercase tracking-wider mr-2 mb-1">Category</span>
                          <div className="flex flex-wrap gap-1.5">
                            {availableCategories.map(category => (
                              <button
                                key={category}
                                onClick={() => toggleFilter('categories', category)}
                                className={`px-2 py-1 text-xs whitespace-nowrap ${
                                  filters.categories.includes(category)
                                    ? 'text-ink-100 font-bold'
                                    : 'text-ink-500 hover:text-ink-300'
                                }`}
                              >
                                {category}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                      
                      {/* Spirits */}
                      <div className="flex flex-wrap gap-1.5 items-baseline">
                        <span className="text-2xs text-ink-600 uppercase tracking-wider mr-2 mb-1">Spirit</span>
                        <div className="flex flex-wrap gap-1.5">
                          {SPIRIT_CATEGORIES.map(spirit => (
                            <button
                              key={spirit}
                              onClick={() => toggleFilter('spirits', spirit)}
                              className={`px-2 py-1 text-xs whitespace-nowrap ${
                                filters.spirits.includes(spirit)
                                  ? 'text-ink-100 font-bold'
                                  : 'text-ink-500 hover:text-ink-300'
                              }`}
                            >
                              {spirit}
                            </button>
                          ))}
                        </div>
                      </div>
                      
                      {/* Methods */}
                      <div className="flex flex-wrap gap-1.5 items-baseline">
                        <span className="text-2xs text-ink-600 uppercase tracking-wider mr-2 mb-1">Method</span>
                        <div className="flex flex-wrap gap-1.5">
                          {METHOD_OPTIONS.map(method => (
                            <button
                              key={method}
                              onClick={() => toggleFilter('methods', method)}
                              className={`px-2 py-1 text-xs whitespace-nowrap ${
                                filters.methods.includes(method)
                                  ? 'text-ink-100 font-bold'
                                  : 'text-ink-500 hover:text-ink-300'
                              }`}
                            >
                              {method}
                            </button>
                          ))}
                        </div>
                      </div>
                      
                      {/* Glasses */}
                      {availableGlasses.length > 0 && (
                        <div className="flex flex-wrap gap-1.5 items-baseline">
                          <span className="text-2xs text-ink-600 uppercase tracking-wider mr-2 mb-1">Glass</span>
                          <div className="flex flex-wrap gap-1.5">
                            {availableGlasses.slice(0, 8).map(glass => (
                              <button
                                key={glass}
                                onClick={() => toggleFilter('glasses', glass)}
                                className={`px-2 py-1 text-xs whitespace-nowrap ${
                                  filters.glasses.includes(glass)
                                    ? 'text-ink-100 font-bold'
                                    : 'text-ink-500 hover:text-ink-300'
                                }`}
                              >
                                {glass}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                      
                      {/* Tags */}
                      {(view === 'browse' || view === 'keepers' || view === 'toTry' || view === 'custom') && (
                        <div className="flex flex-wrap gap-1.5 items-baseline">
                          <span className="text-2xs text-ink-600 uppercase tracking-wider mr-2 mb-1">Tags</span>
                          <div className="flex flex-wrap gap-1.5">
                            <button
                              onClick={() => toggleFilter('tags', 'canMake')}
                              className={`px-2 py-1 text-xs whitespace-nowrap ${
                                filters.tags.includes('canMake')
                                  ? 'text-ink-100 font-bold'
                                  : 'text-ink-500 hover:text-ink-300'
                              }`}
                            >
                              Can Make
                            </button>
                            <button
                              onClick={() => toggleFilter('tags', 'almostMake')}
                              className={`px-2 py-1 text-xs whitespace-nowrap ${
                                filters.tags.includes('almostMake')
                                  ? 'text-ink-100 font-bold'
                                  : 'text-ink-500 hover:text-ink-300'
                              }`}
                            >
                              Almost Make
                            </button>
                            {view === 'browse' && (
                              <>
                                <button
                                  onClick={() => toggleFilter('tags', 'keepers')}
                                  className={`px-2 py-1 text-xs whitespace-nowrap ${
                                    filters.tags.includes('keepers')
                                      ? 'text-ink-100 font-bold'
                                      : 'text-ink-500 hover:text-ink-300'
                                  }`}
                                >
                                  Keepers
                                </button>
                                <button
                                  onClick={() => toggleFilter('tags', 'toTry')}
                                  className={`px-2 py-1 text-xs whitespace-nowrap ${
                                    filters.tags.includes('toTry')
                                      ? 'text-ink-100 font-bold'
                                      : 'text-ink-500 hover:text-ink-300'
                                  }`}
                                >
                                  Try
                                </button>
                              </>
                            )}
                          </div>
                        </div>
                      )}
                      
                      {/* Clear All */}
                      {hasActiveFilters && (
                        <div className="flex justify-end pt-2">
                          <button
                            onClick={clearFilters}
                            className="px-4 py-2 text-xs text-copper hover:text-copper whitespace-nowrap"
                          >
                            Clear all filters
                          </button>
                        </div>
                      )}
                    </div>
                  )}
                  </div>
                </div>

                {/* Results info */}
                <div className="flex items-center justify-between mb-4">
                  <p className="text-xs text-ink-600 tracking-wide">
                    {displayDrinks.length} {displayDrinks.length === 1 ? 'recipe' : 'recipes'}
                    {hasActiveFilters && (
                      <span className="text-copper ml-1">
                        · {filters.spirits.length + filters.methods.length + filters.glasses.length + filters.tags.length + filters.categories.length} filter{filters.spirits.length + filters.methods.length + filters.glasses.length + filters.tags.length + filters.categories.length !== 1 ? 's' : ''}
                      </span>
                    )}
                  </p>
                  {view === 'almostMake' && displayDrinks.length > 0 && (
                    <button
                      onClick={() => {
                        // Create shopping list
                        const ingredientCounts = {};
                        displayDrinks.forEach(drink => {
                          const missing = drink.ingredients?.filter(ing => {
                            const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                            const barInventory = getActiveBarInventory();
                            const invCanonical = new Set(barInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
                            return !invCanonical.has(ingCanonical);
                          }) || [];
                          
                          missing.forEach(ing => {
                            const key = normalizeIngredient(ing.name, ingredientsDb);
                            if (!ingredientCounts[key]) {
                              ingredientCounts[key] = { name: ing.name, count: 0, recipes: [] };
                            }
                            if (!ingredientCounts[key].recipes.find(r => r.id === drink.id)) {
                              ingredientCounts[key].count++;
                              ingredientCounts[key].recipes.push({ id: drink.id, name: drink.name });
                            }
                          });
                        });
                        
                        const shoppingList = Object.values(ingredientCounts)
                          .sort((a, b) => b.count - a.count)
                          .map(item => `${item.name} (unlocks ${item.count} ${item.count === 1 ? 'recipe' : 'recipes'})`)
                          .join('\n');
                        
                        // Try clipboard
                        navigator.clipboard.writeText(shoppingList).then(() => {
                          toast('Shopping list copied to clipboard', 'success');
                        }).catch(() => {
                          setShowShoppingList(shoppingList);
                        });
                      }}
                      className="px-4 py-2 btn-copper text-sm font-medium"
                    >
                      <Icon name="ShoppingCart" className="w-4 h-4 inline mr-2" />
                      <span>Create Shopping List</span>
                    </button>
                  )}
                </div>

                {/* Recipe List */}
                {loading ? (
                  <div>
                    {[...Array(6)].map((_, i) => (
                      <div key={i} className="py-2.5 px-4 border-b border-ink-700 animate-pulse last:border-0">
                        <div className="h-5 bg-ink-800 w-1/3 mb-1.5" />
                        <div className="h-3 bg-ink-800 w-1/4 mb-1" />
                        <div className="h-2.5 bg-ink-800 w-1/2" />
                      </div>
                    ))}
                  </div>
                ) : displayDrinks.length === 0 ? (
                  <EmptyState view={view} onAction={() => {
                    if (view === 'canMake') {
                      setView('inventory');
                    } else if (view === 'browse') {
                      setShowAddDrink(true);
                    } else if (view === 'custom') {
                      setView('browse');
                    } else {
                      setView('browse');
                    }
                  }} />
                ) : (
                  <div className="bg-transparent border border-ink-700 overflow-hidden">
                    {displayDrinks.map((drink, i) => (
                      <RecipeRow
                        key={drink.id}
                        drink={drink}
                        isKeeper={keepers && keepers.has(drink.id)}
                        isToTry={isInToTry(drink.id)}
                        canMake={canMakeDrink(drink)}
                        missingCount={getMissingCount(drink)}
                        onClick={() => setSelectedDrink(drink)}
                        onToggleKeeper={() => toggleKeeper(drink.id)}
                        onToggleToTry={() => toggleToTry(drink.id)}
                        ingredientsDb={ingredientsDb}
                      />
                    ))}
                  </div>
                )}
              </>
            )}
          </main>

          {/* Mobile Bottom Nav */}
          <nav className="sm:hidden fixed bottom-0 left-0 right-0 bg-ink-950 border-t border-ink-700 mobile-bottom-nav z-40">
            <div className="flex justify-around py-2">
              {navItems.map(item => (
                <button
                  key={item.id}
                  onClick={() => {
                    setView(item.id);
                    if (item.id === 'browse') {
                      setSearchTerm('');
                    }
                    setShowRecipesHub(false);
                  }}
                  className={`relative flex flex-col items-center gap-1 px-4 py-2  transition-colors ${
                    view === item.id ? 'text-copper' : 'text-ink-500'
                  }`}
                >
                  <Icon name={item.icon} className="w-5 h-5" />
                  <span className="text-2xs">{item.label}</span>
                  {item.count > 0 && view !== item.id && (
                    <span className="absolute -top-1 right-1 w-1.5 h-1.5 bg-copper " />
                  )}
                </button>
              ))}
            </div>
          </nav>
          
          {/* Update Available Banner */}
          {updateAvailable && (
            <div className="fixed bottom-16 sm:bottom-4 left-4 right-4 sm:left-auto sm:right-4 z-50 bg-ink-900 border border-ink-700 px-4 py-3 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <span className="text-sm">Update available</span>
              </div>
              <div className="flex items-center gap-4 ml-4">
                <button
                  onClick={reloadForUpdate}
                  className="text-sm text-ink-500 hover:text-ink-300"
                >
                  refresh
                </button>
                <button
                  onClick={() => setUpdateAvailable(false)}
                  className="text-ink-500 hover:text-ink-300"
                >
                  ×
                </button>
              </div>
            </div>
          )}

          {/* Ingredient Detail View */}
          {selectedIngredient && (
            <IngredientDetailView
              ingredient={selectedIngredient}
              allDrinks={getAllDrinks()}
              ingredientsDb={ingredientsDb}
              normalizeIngredient={normalizeIngredient}
              onNavigateToRecipe={(drink) => setSelectedDrink(drink)}
              onClose={() => setSelectedIngredient(null)}
            />
          )}

          {/* Modals */}
          {selectedDrink && (
            <RecipeDetail
              drink={selectedDrink}
              onClose={() => setSelectedDrink(null)}
              isKeeper={keepers && keepers.has(selectedDrink.id)}
              isToTry={isInToTry(selectedDrink.id)}
              canMake={canMakeDrink(selectedDrink)}
              inventory={getActiveBarInventory()}
              ingredientsDb={ingredientsDb}
              collections={collections}
              onToggleKeeper={() => toggleKeeper(selectedDrink.id)}
              onToggleToTry={() => toggleToTry(selectedDrink.id)}
              onDelete={selectedDrink.source === 'custom' ? () => setShowConfirmDelete(selectedDrink.id) : null}
              onShare={shareRecipe}
              onAddToCollection={addRecipeToCollection}
              unitPreference={unitPreference}
              onToggleUnit={() => setUnitPreference(prev => prev === 'oz' ? 'ml' : 'oz')}
              onNavigateToIngredient={(ingredient) => {
                setSelectedDrink(null);
                setSelectedIngredient(ingredient);
              }}
              onEdit={selectedDrink.source === 'custom' ? (drink) => {
                setEditingDrink(drink);
                setSelectedDrink(null);
                setShowAddDrink(true);
              } : null}
            />
          )}

          {showAddDrink && <AddRecipeModal onClose={() => { setShowAddDrink(false); setEditingDrink(null); }} onAdd={addCustomDrink} onUpdate={updateCustomDrink} editingDrink={editingDrink} ingredientsDb={ingredientsDb} />}
          
          {showImportShared && (
            <ImportSharedRecipeModal
              sharedData={sharedRecipeData}
              existingRecipes={customDrinks}
              onImport={importSharedRecipe}
              toast={toast}
              onClose={() => {
                setShowImportShared(false);
                setSharedRecipeData(null);
              }}
            />
          )}
          
          {showConfirmDelete && (
            <ConfirmDialog
              title="Delete Recipe"
              message="This will permanently delete this recipe. This cannot be undone."
              onConfirm={() => deleteCustomDrink(showConfirmDelete)}
              onCancel={() => setShowConfirmDelete(null)}
            />
          )}
          
          {showShoppingList && (
            <div className="fixed inset-0 z-50 bg-ink-950 flex items-center justify-center p-4" onClick={() => setShowShoppingList(null)}>
              <div className="max-w-xl w-full bg-ink-900 p-6" onClick={e => e.stopPropagation()}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-bold text-ink-100 uppercase">Shopping List</h2>
                  <button onClick={() => setShowShoppingList(null)} className="text-ink-500 hover:text-ink-300">
                    ×
                  </button>
                </div>
                <textarea
                  value={showShoppingList}
                  readOnly
                  className="w-full h-64 px-4 py-3 input-field text-sm text-ink-100 resize-none mb-4 font-mono"
                />
                <div className="flex gap-4">
                  <button
                    onClick={() => {
                      navigator.clipboard.writeText(showShoppingList);
                      toast('Copied to clipboard', 'success');
                    }}
                    className="text-sm btn-copper"
                  >
                    copy to clipboard
                  </button>
                  <button
                    onClick={() => {
                      const blob = new Blob([showShoppingList], { type: 'text/plain' });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = 'shopping-list.txt';
                      a.click();
                      URL.revokeObjectURL(url);
                      toast('Downloaded', 'success');
                    }}
                    className="text-sm text-ink-500 hover:text-ink-300"
                  >
                    download
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // ============ COMPONENTS ============

    const RecipesHub = ({ 
      savedCount, favoritesCount, canMakeCount, almostMakeCount, wantToTryCount, customCount, allCount, collectionsCount, 
      onNavigate, getMakeableDrinks, getAlmostMakeableDrinks, getAllCollections, getCollectionRecipes,
      onSelectDrink, keepers, collections, getMissingCount, canMakeDrink, ingredientsDb, 
      bars, activeBar, onSwitchBar, onCreateShoppingList, toggleKeeper, toggleToTry, isInToTry
    }) => {
      // Featured collections: prefer curated, rotate by day if needed
      // Simple selection: first 2-3 curated collections (or all if less than 3)
      const allCollections = getAllCollections;
      const curatedCollections = allCollections.filter(c => c.collectionType === 'curated');
      const featuredCollections = curatedCollections.length > 0 
        ? curatedCollections.slice(0, 3)
        : allCollections.slice(0, 3);
      
      const canMakeRecipes = getMakeableDrinks().slice(0, 8);
      const almostMakeRecipes = getAlmostMakeableDrinks().slice(0, 5);
      
      const recipeItems = [
        { id: 'canMake', label: 'Can Make', icon: 'CheckCircle', count: canMakeCount, description: 'Ready to make now' },
        { id: 'almostMake', label: 'Almost Make', icon: 'AlertCircle', count: almostMakeCount, description: '1-2 ingredients away' },
        { id: 'keepers', label: 'Keepers', icon: 'Star', count: favoritesCount, description: 'Recipes that stood out' },
        { id: 'toTry', label: 'Try', icon: 'Bookmark', count: wantToTryCount, description: 'Your queue' },
        { id: 'collections', label: 'Collections', icon: 'Folder', count: collectionsCount, description: 'Organize recipes' },
        { id: 'custom', label: 'Custom', icon: 'FlaskConical', count: customCount, description: 'Your custom recipes' },
      ];

      // Show recipe items even if bar is empty, but with a subtle prompt
      const hasInventory = activeBar?.inventory && activeBar.inventory.length > 0;

      return (
        <div className=" space-y-8">
          {/* Quick Bar Switch (if multiple bars) */}
          {bars.length > 1 && (
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-2 text-sm text-ink-500">
                <Icon name="Wine" className="w-4 h-4" />
                <span>Active bar:</span>
                <span className="text-ink-100 font-medium">{activeBar?.name || 'Bar'}</span>
                {activeBar?.isMain && (
                  <span className="text-2xs px-1.5 py-0.5  bg-copper/10 text-copper border border-copper/20">
                    Main
                  </span>
                )}
              </div>
              <button
                onClick={() => {
                  const nextBar = bars.find(b => b.id !== activeBar?.id) || bars[0];
                  onSwitchBar(nextBar.id);
                }}
                className="text-xs text-copper hover:text-copper flex items-center gap-1"
              >
                <Icon name="RefreshCw" className="w-3.5 h-3.5" />
                Switch
              </button>
            </div>
          )}

          {/* Subtle prompt if bar is empty */}
          {!hasInventory && (
            <div className="border border-ink-700 p-4 bg-ink-900/50">
              <div className="flex items-start justify-between gap-4">
                <div className="flex-1">
                  <p className="text-sm text-ink-400 mb-1">Add ingredients to your bar to see personalized recommendations</p>
                  <p className="text-xs text-ink-600">You can still browse all recipes below</p>
                </div>
                <button
                  onClick={() => onNavigate('inventory')}
                  className="text-xs text-copper hover:text-ink-300 whitespace-nowrap"
                >
                  Go to Bar →
                </button>
              </div>
            </div>
          )}

          {/* You can make section - only show if has inventory */}
          {hasInventory && canMakeRecipes.length > 0 ? (
            <section>
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-ink-100 uppercase">You can make</h2>
                <button
                  onClick={() => onNavigate('canMake')}
                  className="text-sm text-ink-500 hover:text-ink-300"
                >
                  see all →
                </button>
              </div>
              <div>
                {canMakeRecipes.map(drink => (
                      <RecipeRow
                        key={drink.id}
                        drink={drink}
                        isKeeper={keepers && keepers.has(drink.id)}
                        isToTry={isInToTry(drink.id)}
                        canMake={true}
                        missingCount={0}
                        onClick={() => onSelectDrink(drink)}
                        onToggleKeeper={() => toggleKeeper(drink.id)}
                        onToggleToTry={() => toggleToTry(drink.id)}
                        ingredientsDb={ingredientsDb}
                      />
                ))}
              </div>
            </section>
          ) : hasInventory ? (
            <section>
              <h2 className="text-xl font-bold text-ink-100 uppercase mb-4">You can make</h2>
              <div className="py-4">
                <p className="text-sm text-ink-500">No recipes you can make right now</p>
                {almostMakeRecipes.length > 0 && (
                  <p className="text-xs text-ink-500 mt-2">Check out "Almost make" below to see what you're close to making</p>
                )}
              </div>
            </section>
          ) : null}

          {/* Almost make section - only show if has inventory */}
          {hasInventory && almostMakeRecipes.length > 0 && (
            <section>
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-ink-100 uppercase">Almost make</h2>
                <div className="flex items-center gap-4">
                  <button
                    onClick={() => {
                      onCreateShoppingList(almostMakeRecipes);
                    }}
                    className="text-sm text-ink-500 hover:text-ink-300"
                  >
                    create shopping list
                  </button>
                  <button
                    onClick={() => onNavigate('almostMake')}
                    className="text-sm text-ink-500 hover:text-ink-300"
                  >
                    see all →
                  </button>
                </div>
              </div>
              <div>
                {almostMakeRecipes.map(drink => {
                  const missing = getMissingCount(drink);
                  return (
                    <RecipeRow
                      key={drink.id}
                      drink={drink}
                      isKeeper={keepers.has(drink.id)}
                      isToTry={isInToTry(drink.id)}
                      canMake={false}
                      missingCount={missing}
                      onClick={() => onSelectDrink(drink)}
                      onToggleKeeper={() => toggleKeeper(drink.id)}
                      onToggleToTry={() => toggleToTry(drink.id)}
                      ingredientsDb={ingredientsDb}
                    />
                  );
                })}
              </div>
            </section>
          )}

          {/* Featured collections section */}
          {featuredCollections.length > 0 && (
            <section>
              <div className="flex items-center justify-between mb-4">
                <h2 className="font-display text-xl text-ink-100 font-light">Featured collections</h2>
                <button
                  onClick={() => onNavigate('collections')}
                  className="text-sm text-copper hover:text-copper flex items-center gap-1"
                >
                  Browse collections
                  <Icon name="ArrowRight" className="w-4 h-4" />
                </button>
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                {featuredCollections.map(collection => {
                  const recipes = getCollectionRecipes(collection);
                  return (
                    <button
                      key={collection.id}
                      onClick={() => {
                        onNavigate(`collection-${collection.id}`);
                      }}
                      className="border border-ink-700 p-4 text-left  group"
                    >
                      <div className="flex items-start justify-between mb-2">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <h3 className="font-display text-lg text-ink-100 font-normal text-copper transition-colors">
                              {collection.name}
                            </h3>
                            {collection.collectionType === 'curated' && (
                              <span className="text-2xs px-2 py-0.5  bg-copper/10 text-copper border border-copper/20">
                                Curated
                              </span>
                            )}
                          </div>
                          {collection.description && (
                            <p className="text-2xs text-ink-500 mt-0.5">{collection.description}</p>
                          )}
                        </div>
                        <span className="text-2xs px-2 py-1  bg-copper/20 text-copper font-medium">
                          {recipes.length}
                        </span>
                      </div>
                    </button>
                  );
                })}
              </div>
            </section>
          )}

          {/* Navigation list */}
          <section>
            <h2 className="font-display text-2xl text-ink-100 font-light mb-6">Browse</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              {recipeItems.map(item => (
                <button
                  key={item.id}
                  onClick={() => onNavigate(item.id)}
                  className="border border-ink-700 p-4 text-left  group"
                >
                  <div className="flex items-start justify-between mb-2">
                    <div className="flex items-center gap-3">
                      <div className="p-2  bg-transparent group-copper/10 transition-colors">
                        <Icon name={item.icon} className="w-5 h-5 text-copper" />
                      </div>
                      <div>
                        <h3 className="font-display text-lg text-ink-100 font-normal text-copper transition-colors">
                          {item.label}
                        </h3>
                        <p className="text-2xs text-ink-500 mt-0.5">{item.description}</p>
                      </div>
                    </div>
                    {item.count > 0 && (
                      <span className="text-2xs px-2 py-1  bg-copper/20 text-copper font-medium">
                        {item.count}
                      </span>
                    )}
                  </div>
                </button>
              ))}
            </div>
          </section>
        </div>
      );
    };

    const CollectionPicker = ({ collections, recipeId, onSelect, onClose }) => {
      // Only show personal collections (curated are auto-updating)
      const personalCollections = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
      const recipeCollections = personalCollections.filter(c => c.recipeIds?.includes(recipeId));
      
      return (
        <div className="absolute top-full left-0 right-0 mt-2 p-3 bg-ink-800 z-50 ">
          <div className="flex items-center justify-between mb-3">
            <h4 className="text-sm text-ink-100 font-light">Add to Collection</h4>
            <button onClick={onClose} className="p-1 text-ink-500 hover:text-ink-300">
              <Icon name="X" className="w-4 h-4" />
            </button>
          </div>
          <div className="space-y-1 max-h-48 overflow-y-auto">
            {personalCollections.length === 0 ? (
              <p className="text-xs text-ink-500 text-center py-4">No personal collections yet</p>
            ) : (
              personalCollections.map(coll => {
                const isInCollection = coll.recipeIds?.includes(recipeId);
                return (
                  <button
                    key={coll.id}
                    onClick={() => onSelect(coll.id)}
                    className={`w-full text-left px-3 py-2  transition-colors ${
                      isInCollection ? 'bg-copper/20 text-copper' : 'transparent text-ink-300'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <span className="text-sm">{coll.name}</span>
                      {isInCollection && <Icon name="Check" className="w-4 h-4" />}
                    </div>
                    {coll.description && (
                      <p className="text-2xs text-ink-500 mt-0.5">{coll.description}</p>
                    )}
                  </button>
                );
              })
            )}
          </div>
        </div>
      );
    };

    const ImportSharedRecipeModal = ({ sharedData, existingRecipes, onImport, onClose, toast }) => {
      const [dedupeMode, setDedupeMode] = useState('new');
      
      if (!sharedData) {
        // Allow pasting
        const [pasteValue, setPasteValue] = useState('');
        
        const handlePaste = () => {
          try {
            const data = JSON.parse(pasteValue);
            if (data.schema && data.recipe) {
              onImport(data, dedupeMode);
            } else {
              toast?.('Invalid recipe format', 'error');
            }
          } catch {
            toast?.('Invalid JSON', 'error');
          }
        };
        
        return (
          <div className="fixed inset-0 z-50 bg-ink-950 flex items-center justify-center p-4" onClick={onClose}>
            <div className="max-w-xl w-full bg-ink-900 p-6 " onClick={e => e.stopPropagation()}>
              <h2 className="font-display text-xl text-ink-100 font-light mb-4">Import Shared Recipe</h2>
              <textarea
                value={pasteValue}
                onChange={(e) => setPasteValue(e.target.value)}
                placeholder="Paste recipe JSON here..."
                className="w-full h-48 px-4 py-3 input-field  text-sm text-ink-100 font-mono resize-none mb-4"
              />
              <div className="flex gap-3">
                <button onClick={handlePaste} className="flex-1 py-3 btn-copper text-sm font-medium">
                  Import Recipe
                </button>
                <button onClick={onClose} className="px-4 py-3 text-ink-500 hover:text-ink-300">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      }
      
      const recipe = sharedData.recipe;
      const existing = existingRecipes.find(r => r.id === recipe.id);
      
      return (
        <div className="fixed inset-0 z-50 bg-ink-950 overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen sm:py-8 sm:px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-2xl mx-auto bg-ink-950">
              <div className="p-6">
                <h2 className="text-xl font-bold text-ink-100 uppercase mb-6">Import Recipe</h2>
                
                {/* Preview */}
                <div className="mb-6 pb-6 border-b border-ink-700">
                  <h3 className="text-lg font-bold text-ink-100 uppercase mb-2">{recipe.name}</h3>
                  {recipe.glass && <p className="text-sm text-ink-400 mb-4">{recipe.glass}</p>}
                  
                  <div className="mb-4">
                    <h4 className="text-2xs text-ink-500 uppercase tracking-widest mb-2">Ingredients</h4>
                    <ul className="space-y-1">
                      {recipe.ingredients?.map((ing, i) => (
                        <li key={i} className="text-sm text-ink-300">
                          {ing.measure} {ing.name}
                        </li>
                      ))}
                    </ul>
                  </div>
                  
                  {recipe.instructions && (
                    <div>
                      <h4 className="text-2xs text-ink-500 uppercase tracking-widest mb-2">Method</h4>
                      <p className="text-sm text-ink-300">{recipe.instructions}</p>
                    </div>
                  )}
                </div>
                
                {/* Dedupe option */}
                {existing && (
                  <div className="mb-6">
                    <p className="text-sm text-ink-400 mb-3">This recipe already exists in your collection:</p>
                    <div className="space-y-2">
                      <label className="flex items-center gap-3 p-3 border border-ink-700 cursor-pointer">
                        <input
                          type="radio"
                          name="dedupe"
                          value="new"
                          checked={dedupeMode === 'new'}
                          onChange={(e) => setDedupeMode(e.target.value)}
                          className="text-copper"
                        />
                        <span className="text-sm text-ink-300">Save as new recipe</span>
                      </label>
                      <label className="flex items-center gap-3 p-3 border border-ink-700 cursor-pointer">
                        <input
                          type="radio"
                          name="dedupe"
                          value="replace"
                          checked={dedupeMode === 'replace'}
                          onChange={(e) => setDedupeMode(e.target.value)}
                          className="text-copper"
                        />
                        <span className="text-sm text-ink-300">Replace existing recipe</span>
                      </label>
                    </div>
                  </div>
                )}
                
                <div className="flex gap-3">
                  <button
                    onClick={() => onImport(sharedData, dedupeMode)}
                    className="flex-1 py-3 btn-copper text-sm font-medium"
                  >
                    {existing ? (dedupeMode === 'replace' ? 'Replace Recipe' : 'Save as New') : 'Save to My Recipes'}
                  </button>
                  <button onClick={onClose} className="px-4 py-3 text-ink-500 hover:text-ink-300">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const CollectionsView = ({ collections, allDrinks, getCollectionRecipes, onAddCollection, onUpdateCollection, onDeleteCollection, onRemoveRecipe, onNavigate, onNavigateToRecipe, keepers }) => {
      const [showAddCollection, setShowAddCollection] = useState(false);
      const [editingId, setEditingId] = useState(null);
      const [newName, setNewName] = useState('');
      const [newDescription, setNewDescription] = useState('');
      
      const handleSave = () => {
        if (!newName.trim()) return;
        if (editingId) {
          onUpdateCollection(editingId, { name: newName, description: newDescription });
        } else {
          onAddCollection(newName, newDescription);
        }
        setShowAddCollection(false);
        setEditingId(null);
        setNewName('');
        setNewDescription('');
      };
      
      const startEdit = (coll) => {
        // Don't allow editing curated collections
        if (coll.collectionType === 'curated') {
          return;
        }
        setEditingId(coll.id);
        setNewName(coll.name);
        setNewDescription(coll.description || '');
        setShowAddCollection(true);
      };
      
      // Get keepers count for display
      const keepersCount = allDrinks.filter(d => keepers.has(d.id)).length;
      
      const curatedCollections = collections.filter(c => c.collectionType === 'curated');
      const personalCollections = collections.filter(c => !c.collectionType || c.collectionType === 'personal');
      
      // System collections: Keepers (virtual view) and To Try (collection)
      const toTryCollection = personalCollections.find(c => c.id === 'to_try') || {
        id: 'to_try',
        name: 'To Try',
        description: 'Recipes you want to try',
        collectionType: 'personal',
        recipeIds: []
      };
      const systemCollections = [toTryCollection];
      
      // Keepers is a view, not a collection - we'll handle it specially
      const otherPersonalCollections = personalCollections.filter(c => c.id !== 'to_try');
      
      return (
        <div className="">
          <div className="flex items-center justify-between mb-6">
            <h2 className="font-display text-2xl text-ink-100 font-light">Collections</h2>
            <button
              onClick={() => {
                setEditingId(null);
                setNewName('');
                setNewDescription('');
                setShowAddCollection(true);
              }}
              className="px-4 py-2 btn-copper text-sm font-medium"
            >
              New Collection
            </button>
          </div>
          
          {showAddCollection && (
            <div className="mb-6 pb-6 border-b border-ink-700">
              <h3 className="text-lg font-bold text-ink-100 uppercase mb-4">
                {editingId ? 'Edit Collection' : 'New Collection'}
              </h3>
              <div className="space-y-4">
                <div>
                  <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Name *</label>
                  <input
                    type="text"
                    value={newName}
                    onChange={(e) => setNewName(e.target.value)}
                    placeholder="Collection name"
                    className="w-full px-4 py-3 input-field text-ink-100"
                    autoFocus
                  />
                </div>
                <div>
                  <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Description</label>
                  <textarea
                    value={newDescription}
                    onChange={(e) => setNewDescription(e.target.value)}
                    placeholder="Optional description"
                    rows="2"
                    className="w-full px-4 py-3 input-field  text-ink-100 font-light resize-none"
                  />
                </div>
                <div className="flex gap-3">
                  <button onClick={handleSave} className="flex-1 py-3 btn-copper text-sm font-medium">
                    Save
                  </button>
                  <button
                    onClick={() => {
                      setShowAddCollection(false);
                      setEditingId(null);
                      setNewName('');
                      setNewDescription('');
                    }}
                    className="px-4 py-3 text-ink-500 hover:text-ink-300"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* System Collections (Keepers view + To Try) */}
          <div className="mb-8">
            <h3 className="text-base font-bold text-ink-100 uppercase mb-4">System</h3>
            <hr className="border-ink-700 mb-4" />
            <div className="space-y-4">
              {/* Keepers View */}
              <div className="pb-3 border-b border-ink-700 last:border-0">
                <button
                  onClick={() => onNavigate('keepers')}
                  className="text-left hover:text-ink-300 transition-colors"
                >
                  <h3 className="text-base font-bold text-ink-100 mb-1 uppercase">Keepers</h3>
                  <p className="text-ink-500 text-sm">{keepersCount || 0} {keepersCount === 1 ? 'recipe' : 'recipes'}</p>
                </button>
              </div>

              {/* To Try Collection */}
              {toTryCollection && (
                <div className="pb-3 border-b border-ink-700 last:border-0">
                  <button
                    onClick={() => onNavigate(toTryCollection.id)}
                    className="text-left hover:text-ink-300 transition-colors"
                  >
                    <h3 className="text-base font-bold text-ink-100 mb-1 uppercase">{toTryCollection.name}</h3>
                    <p className="text-ink-500 text-sm">{(toTryCollection.recipeIds || []).length} {(toTryCollection.recipeIds || []).length === 1 ? 'recipe' : 'recipes'}</p>
                  </button>
                </div>
              )}
            </div>
          </div>
          
          {/* Curated Collections */}
          {curatedCollections.length > 0 && (
            <div className="mb-8">
              <h3 className="text-base font-bold text-ink-100 uppercase mb-4">Curated</h3>
              <hr className="border-ink-700 mb-4" />
              <div className="space-y-4">
                {curatedCollections.map(coll => {
                  const recipeCount = getCollectionRecipes ? getCollectionRecipes(coll).length : 0;
                  return (
                    <div key={coll.id} className="pb-3 border-b border-ink-700 last:border-0">
                      <button
                        onClick={() => onNavigate(coll.id)}
                        className="text-left hover:text-ink-300 transition-colors w-full"
                      >
                        <h3 className="text-base font-bold text-ink-100 mb-1 uppercase">{coll.name}</h3>
                        <p className="text-ink-500 text-sm">{recipeCount} {recipeCount === 1 ? 'recipe' : 'recipes'}</p>
                      </button>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
          
          {/* Personal Collections */}
          <div>
            {curatedCollections.length > 0 && (
              <>
                <h3 className="text-base font-bold text-ink-100 uppercase mb-4">Yours</h3>
                <hr className="border-ink-700 mb-4" />
              </>
            )}
            {personalCollections.length === 0 && curatedCollections.length === 0 ? (
              <div className="text-center py-16">
                <div className="w-16 h-16 mx-auto mb-4  bg-transparent flex items-center justify-center">
                  <Icon name="Folder" className="w-7 h-7 text-ink-700" />
                </div>
                <p className="text-ink-400 font-light">No collections yet</p>
                <p className="text-ink-600 text-sm mt-1">Create collections to organize your recipes</p>
              </div>
            ) : otherPersonalCollections.length === 0 ? (
              <div className="text-center py-8">
                <p className="text-ink-500 text-sm">No personal collections yet</p>
                <p className="text-ink-600 text-2xs mt-1">Create one to get started</p>
              </div>
            ) : (
              <div className="space-y-4">
                {otherPersonalCollections.map(coll => {
                  const recipeCount = coll.recipeIds?.length || 0;
                  return (
                    <div key={coll.id} className="pb-3 border-b border-ink-700 last:border-0">
                      <div className="flex items-start justify-between">
                        <button
                          onClick={() => onNavigate(coll.id)}
                          className="text-left hover:text-ink-300 transition-colors flex-1"
                        >
                          <h3 className="text-base font-bold text-ink-100 mb-1 uppercase">{coll.name}</h3>
                          <p className="text-ink-500 text-sm">{recipeCount} {recipeCount === 1 ? 'recipe' : 'recipes'}</p>
                        </button>
                        <div className="flex gap-2 ml-4">
                          <button
                            onClick={() => startEdit(coll)}
                            className="text-ink-500 hover:text-ink-300 text-sm"
                            title="Edit"
                          >
                            edit
                          </button>
                          <button
                            onClick={() => {
                              if (confirm(`Delete collection "${coll.name}"?`)) {
                                onDeleteCollection(coll.id);
                              }
                            }}
                            className="text-ink-500 hover:text-ink-300 text-sm"
                            title="Delete"
                          >
                            delete
                          </button>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      );
    };

    const CollectionDetailView = ({ collection, allDrinks, getCollectionRecipes, onNavigateBack, onNavigateToRecipe, onRemoveRecipe, canMakeDrink, getMissingCount, keepers, isInToTry, toggleKeeper, toggleToTry, ingredientsDb }) => {
      if (!collection) {
        return (
          <div className="">
            <button onClick={onNavigateBack} className="mb-6 flex items-center gap-2 text-ink-400 hover:text-ink-100">
              <Icon name="ArrowLeft" className="w-4 h-4" />
              <span>Back to Collections</span>
            </button>
            <p className="text-ink-400">Collection not found</p>
          </div>
        );
      }
      
      // Get recipes: rule-based for curated, recipeIds for personal
      const recipes = collection.collectionType === 'curated' 
        ? (getCollectionRecipes ? getCollectionRecipes(collection) : [])
        : allDrinks.filter(d => collection.recipeIds?.includes(d.id));
      
      return (
        <div className="">
          <div className="flex items-center gap-4 mb-6">
            <button onClick={onNavigateBack} className="p-2 text-ink-400 hover:text-ink-100">
              <Icon name="ArrowLeft" className="w-5 h-5" />
            </button>
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <h2 className="font-display text-2xl text-ink-100 font-light">{collection.name}</h2>
                {collection.collectionType === 'curated' && (
                  <span className="text-2xs px-2 py-0.5 bg-copper/10 text-copper uppercase tracking-wider">Curated</span>
                )}
              </div>
              {collection.description && (
                <p className="text-sm text-ink-500 mt-1">{collection.description}</p>
              )}
              <div className="flex items-center gap-2 mt-1">
                <p className="text-xs text-ink-600">{recipes.length} {recipes.length === 1 ? 'recipe' : 'recipes'}</p>
                {collection.collectionType === 'curated' && (
                  <span className="text-2xs text-ink-600">• Auto-updating</span>
                )}
              </div>
            </div>
          </div>
          
          {recipes.length === 0 ? (
            <div className="text-center py-16">
              <p className="text-ink-400 font-light">No recipes in this collection</p>
              {collection.collectionType === 'curated' ? (
                <p className="text-ink-600 text-sm mt-1">No recipes match the collection rules</p>
              ) : (
                <p className="text-ink-600 text-sm mt-1">Add recipes from recipe detail view</p>
              )}
            </div>
          ) : (
            <div className="bg-transparent border border-ink-700 overflow-hidden">
              {recipes.map(drink => (
                <div key={drink.id} className="relative group">
                  <RecipeRow
                    drink={drink}
                    isKeeper={keepers.has(drink.id)}
                    isToTry={isInToTry(drink.id)}
                    canMake={canMakeDrink(drink)}
                    missingCount={getMissingCount(drink)}
                    onClick={() => onNavigateToRecipe(drink)}
                    onToggleKeeper={() => toggleKeeper(drink.id)}
                    onToggleToTry={() => toggleToTry(drink.id)}
                    ingredientsDb={ingredientsDb}
                  />
                  {collection.collectionType !== 'curated' && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onRemoveRecipe(drink.id, collection.id);
                      }}
                      className="absolute right-16 top-1/2 -translate-y-1/2 p-1.5 text-ink-500 hover:text-red-400 opacity-0 opacity-100 transition-opacity"
                    >
                      <Icon name="X" className="w-3.5 h-3.5" />
                    </button>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };

    const SettingsView = ({ onClose, onExport, onImport, unmatchedIngredients, onImportShared, unitPreference, onToggleUnit }) => {
      const fileRef = useRef(null);
      const [showDebug, setShowDebug] = useState(false);
      const [importMode, setImportMode] = useState('replace');

      return (
        <div className=" max-w-2xl">
          <div className="flex items-center justify-between mb-6">
            <h2 className="font-display text-2xl text-ink-100 font-light">Settings</h2>
            <button onClick={onClose} className="p-2 text-ink-500 hover:text-ink-300">
              <Icon name="X" className="w-5 h-5" />
            </button>
          </div>

          <div className="space-y-4">
            {/* Preferences */}
            <div className="border border-ink-700 p-5">
              <h3 className="font-display text-lg text-ink-100 font-normal mb-4">Preferences</h3>
              <div className="space-y-3">
                <div className="flex items-center justify-between p-3 border border-ink-700 ">
                  <div>
                    <p className="text-sm text-ink-100 font-light">Measurement Units</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Display measurements in ounces or milliliters</p>
                  </div>
                  <button
                    onClick={onToggleUnit}
                    className="px-4 py-2  border border-copper/30 bg-copper/10 text-copper font-medium text-sm transition-colors"
                  >
                    {unitPreference === 'ml' ? 'ml' : 'oz'}
                  </button>
                </div>
              </div>
            </div>

            {/* Backup & Restore */}
            <div className="border border-ink-700 p-5">
              <h3 className="font-display text-lg text-ink-100 font-normal mb-4">Backup & Restore</h3>
              <div className="space-y-3">
                <button onClick={onExport} className="w-full p-4 bg-ink-800 text-left ink-700 transition-colors group">
                  <div className="flex items-center gap-3">
                    <Icon name="Download" className="w-5 h-5 text-copper" />
                    <div>
                      <p className="text-ink-100 font-light text-copper transition-colors">Export Data</p>
                      <p className="text-2xs text-ink-500 mt-0.5">Download your recipes and settings</p>
                    </div>
                  </div>
                </button>
              <input type="file" ref={fileRef} onChange={(e) => onImport(e, importMode)} accept=".json" className="hidden" />
              <button onClick={() => fileRef.current?.click()} className="w-full p-4 bg-ink-800 text-left ink-700 transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Upload" className="w-5 h-5 text-copper" />
                  <div className="flex-1">
                    <p className="text-ink-100 font-light text-copper transition-colors">Import Everything</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Restore from a backup file</p>
                  </div>
                </div>
              </button>
              
              {/* Import mode selection */}
              <div className="mt-3 pt-3 border-t border-ink-700">
                <p className="text-2xs text-ink-600 uppercase tracking-wider mb-2">Import Mode</p>
                <div className="space-y-2">
                  <label className="flex items-center gap-3 p-2 border border-ink-700 cursor-pointer">
                    <input
                      type="radio"
                      name="importMode"
                      value="replace"
                      checked={importMode === 'replace'}
                      onChange={(e) => setImportMode(e.target.value)}
                      className="text-copper"
                    />
                    <div>
                      <span className="text-sm text-ink-300">Replace</span>
                      <p className="text-2xs text-ink-600">Overwrite all existing data</p>
                    </div>
                  </label>
                  <label className="flex items-center gap-3 p-2 border border-ink-700 cursor-pointer">
                    <input
                      type="radio"
                      name="importMode"
                      value="merge"
                      checked={importMode === 'merge'}
                      onChange={(e) => setImportMode(e.target.value)}
                      className="text-copper"
                    />
                    <div>
                      <span className="text-sm text-ink-300">Merge</span>
                      <p className="text-2xs text-ink-600">Combine with existing data</p>
                    </div>
                  </label>
                </div>
              </div>
              <button onClick={onImportShared} className="w-full p-4 bg-ink-800 text-left ink-700 transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Share2" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-ink-100 font-light text-copper transition-colors">Import Shared Recipe</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Paste a shared recipe JSON</p>
                  </div>
                </div>
              </button>
            </div>
          </div>

            {/* Debug (hidden) */}
            {unmatchedIngredients.length > 0 && (
              <div className="border border-ink-700 p-5">
                <button
                  onClick={() => setShowDebug(!showDebug)}
                  className="w-full flex items-center justify-between text-left"
                >
                  <h3 className="font-display text-lg text-ink-100 font-normal">Debug: Unmatched Ingredients</h3>
                  <Icon name={showDebug ? 'ChevronUp' : 'ChevronDown'} className="w-5 h-5 text-ink-500" />
                </button>
                {showDebug && (
                  <div className="mt-4 pt-4 border-t border-ink-700">
                    <p className="text-sm text-ink-400 mb-3">Ingredients that couldn't be matched to canonical names:</p>
                    <div className="flex flex-wrap gap-2">
                      {unmatchedIngredients.map((ing, i) => (
                        <span key={i} className="px-2 py-1 bg-transparent text-xs text-ink-500 font-mono">
                          {ing}
                        </span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      );
    };

    const EmptyState = ({ view, onAction }) => {
      const config = {
        browse: { icon: 'Search', title: 'No recipes found', subtitle: 'Try a different search or create a new recipe', action: 'Create Recipe', actionFn: onAction },
        keepers: { icon: 'Star', title: 'No keepers yet', subtitle: 'Mark recipes that stand out', action: null },
        toTry: { icon: 'Bookmark', title: 'Try list is empty', subtitle: 'Add recipes to your queue', action: null },
        canMake: { icon: 'Wine', title: 'Add ingredients to your bar', subtitle: 'See what cocktails you can make', action: 'Stock Your Bar', actionFn: onAction },
        almostMake: { icon: 'Clock', title: 'No almost-ready recipes', subtitle: 'Add more ingredients to unlock', action: null },
        custom: { icon: 'FlaskConical', title: 'No custom recipes', subtitle: 'Go to Browse to create recipes', action: 'Go to Browse', actionFn: onAction },
      };
      const c = config[view] || config.browse;
      
      return (
        <div className="text-center py-16 ">
          <div className="w-16 h-16 mx-auto mb-4  bg-transparent flex items-center justify-center">
            <Icon name={c.icon} className="w-7 h-7 text-ink-700" />
          </div>
          <p className="text-ink-400 font-light">{c.title}</p>
          <p className="text-ink-600 text-sm mt-1">{c.subtitle}</p>
          {c.action && (
            <button onClick={c.actionFn} className="mt-4 px-4 py-2 btn-copper text-sm font-medium">
              {c.action}
            </button>
          )}
        </div>
      );
    };

    const RecipeCard = ({ drink, rating, isSaved, isFavorite, canMake, missingCount, onClick, onToggleSaved, onToggleFavorite, className }) => (
      <div className={`border border-ink-700 overflow-hidden group cursor-pointer  ${className}`} onClick={onClick}>
        <div className="relative h-36 sm:h-44 overflow-hidden bg-ink-900">
          {drink.image ? (
            <img src={drink.image} alt={drink.name} className="w-full h-full object-cover opacity-75 opacity-90 scale-105  duration-500" loading="lazy" />
          ) : (
            <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-ink-850 to-ink-900">
              <span className="font-display text-4xl text-ink-700">{drink.name.charAt(0)}</span>
            </div>
          )}
          <div className="absolute inset-0 bg-gradient-to-t from-ink-950 via-ink-950/30 to-transparent" />
          
          {/* Status badges */}
          <div className="absolute top-2.5 left-2.5 flex gap-1.5">
            {canMake && (
              <span className="text-2xs px-2 py-1 bg-emerald-900/80 text-emerald-300 tracking-wide uppercase font-medium">Ready</span>
            )}
            {!canMake && missingCount > 0 && missingCount <= 2 && (
              <span className="text-2xs px-2 py-1 bg-amber-900/60 text-amber-300 tracking-wide uppercase font-medium">
                {missingCount} away
              </span>
            )}
            {drink.source === 'custom' && (
              <span className="text-2xs px-2 py-1 bg-copper/20 text-copper tracking-wide uppercase font-medium">Custom</span>
            )}
          </div>
          
          {/* Quick actions */}
          <div className="absolute top-2.5 right-2.5 flex gap-1 opacity-0 opacity-100 transition-opacity">
            <button
              onClick={(e) => { e.stopPropagation(); onToggleFavorite(); }}
              className={`p-1.5   transition-colors ${isFavorite ? 'bg-copper/30 text-copper' : 'bg-ink-900 text-ink-400 hover:text-copper'}`}
            >
              <Icon name="Heart" className="w-3.5 h-3.5" />
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); onToggleSaved(); }}
              className={`p-1.5   transition-colors ${isSaved ? 'bg-copper/30 text-copper' : 'bg-ink-900 text-ink-400 hover:text-copper'}`}
            >
              <Icon name="Bookmark" className="w-3.5 h-3.5" />
            </button>
          </div>
          
          {/* Ingredient count */}
          <div className="absolute bottom-2.5 right-2.5">
            <span className="text-2xs text-ink-500 bg-ink-900  px-2 py-1">
              {drink.ingredients?.length || 0} ing.
            </span>
          </div>
        </div>
        
        <div className="p-3 sm:p-4">
          <h3 className="font-display text-base sm:text-lg text-ink-100 font-normal leading-tight text-copper transition-colors line-clamp-1">
            {drink.name}
          </h3>
          <div className="flex items-center justify-between mt-1.5">
            <p className="text-2xs sm:text-xs text-ink-500 font-light truncate">{drink.glass || drink.category}</p>
            {rating > 0 && <StarRating rating={rating} readonly size="text-2xs sm:text-xs" />}
          </div>
        </div>
      </div>
    );

    const RecipeRow = ({ drink, isKeeper, isToTry, canMake, missingCount, onClick, onToggleKeeper, onToggleToTry, showImage = false, ingredientsDb }) => {
      const spirit = detectSpirit(drink);
      const method = detectMethod(drink);
      const modifiers = extractModifiers(drink, ingredientsDb);
      const category = drink.category || drink.ibaCategory;
      
      // Status indicator - neutral margin language (very subtle gray checkmark for ready)
      const getStatusIndicator = () => {
        if (canMake) {
          // Ready: show tiny neutral gray checkmark
          return (
            <Icon name="Check" className="w-2.5 h-2.5 text-ink-600" />
          );
        } else if (missingCount > 0 && missingCount <= 2) {
          // Missing 1-2: show tiny neutral number
          return (
            <span className="text-ink-600 text-[10px] font-medium leading-none tabular-nums">
              {missingCount}
            </span>
          );
        }
        return null;
      };
      
      // Build secondary line: spirit · method · glass
      const secondaryParts = [];
      if (spirit && spirit !== 'Other') secondaryParts.push(spirit);
      if (method) secondaryParts.push(method);
      if (drink.glass) secondaryParts.push(drink.glass);
      const secondaryLine = secondaryParts.join(' · ');
      
      return (
        <div
          className="py-4 border-b border-ink-700 cursor-pointer last:border-0"
          onClick={onClick}
        >
          <div className="flex items-start gap-4">
            <div className="flex-1 min-w-0">
              {/* Recipe name */}
              <h3 className="text-base font-bold text-ink-100 mb-1 uppercase">
                {drink.name}
                {isKeeper && <span className="ml-2 text-ink-100">★ keeper</span>}
              </h3>

              {/* Ingredients line */}
              {drink.ingredients && drink.ingredients.length > 0 && (
                <div className="text-sm text-ink-500 mb-1">
                  {drink.ingredients.map(ing => ing.name).join(' · ')}
                </div>
              )}

              {/* Secondary info line */}
              {[spirit && spirit !== 'Other' && spirit,
               method].filter(Boolean).length > 0 && (
                <div className="text-xs text-ink-500">
                  {[spirit && spirit !== 'Other' && spirit,
                   method].filter(Boolean).join(' / ')}
                </div>
              )}
            </div>
            {/* Status indicator - moved to right */}
            <div className="flex-shrink-0 mt-1">
              {getStatusIndicator()}
            </div>
          </div>
        </div>
      );
    };

    const RecipeDetail = ({ drink, onClose, isKeeper, isToTry, canMake, inventory, ingredientsDb, collections, onToggleKeeper, onToggleToTry, onDelete, onShare, onAddToCollection, unitPreference, onToggleUnit, onNavigateToIngredient, onEdit }) => {
      const invCanonical = new Set(inventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
      const [showCollectionPicker, setShowCollectionPicker] = useState(false);

      // Lock body scroll when modal is open
      useEffect(() => {
        const previousOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        return () => {
          document.body.style.overflow = previousOverflow;
        };
      }, []);
      
      return (
        <div className="fixed inset-0 z-50 bg-ink-950 overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen py-8 px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-2xl mx-auto">
              {/* Header */}
              <div className="flex items-center justify-between mb-8">
                <button onClick={onClose} className="text-ink-500 hover:text-ink-300">
                  ← Back
                </button>
                <div className="text-center">
                  {canMake && <span className="text-xs text-emerald-400 uppercase tracking-wide">Ready to make</span>}
                  {drink.source === 'custom' && <span className="text-xs text-copper uppercase tracking-wide ml-2">Custom</span>}
                </div>
                <div className="w-12" />
              </div>

              <div className="space-y-6">
                {/* Title */}
                <div>
                  <h1 className="text-2xl font-bold text-ink-100 uppercase mb-2">{drink.name}</h1>
                  <hr className="border-ink-700 mb-4" />
                </div>

                {/* Actions */}
                <div className="text-sm space-x-4">
                  <button
                    onClick={onToggleKeeper}
                    className={`hover:text-ink-100 transition-colors ${isKeeper ? 'text-ink-100' : 'text-ink-500'}`}
                  >
                    {isKeeper ? '★ keeper' : '☆ keeper'}
                  </button>
                  <button
                    onClick={onToggleToTry}
                    className={`hover:text-ink-100 transition-colors ${isToTry ? 'text-ink-100' : 'text-ink-500'}`}
                  >
                    {isToTry ? '— try' : '+ try'}
                  </button>
                  <button
                    onClick={() => setShowCollectionPicker(true)}
                    className="text-ink-500 hover:text-ink-100 transition-colors"
                  >
                    + collection
                  </button>
                  <button
                    onClick={() => onShare?.(drink)}
                    className="text-ink-500 hover:text-ink-100 transition-colors"
                  >
                    ↑ share
                  </button>
                  {drink.source === 'custom' && onEdit && (
                    <button
                      onClick={() => onEdit(drink)}
                      className="text-ink-500 hover:text-ink-100 transition-colors"
                    >
                      edit
                    </button>
                  )}
                </div>

                {showCollectionPicker && (
                  <CollectionPicker
                    collections={collections || []}
                    recipeId={drink.id}
                    onSelect={(collectionId) => {
                      onAddToCollection?.(drink.id, collectionId);
                      setShowCollectionPicker(false);
                    }}
                    onClose={() => setShowCollectionPicker(false)}
                  />
                )}

                <hr className="border-ink-700" />

                {/* Ingredients */}
                <div>
                  <div className="flex items-center justify-between mb-3">
                    <h3 className="text-sm text-ink-500 uppercase tracking-widest">Ingredients</h3>
                    {/* Unit Toggle */}
                    <button
                      onClick={onToggleUnit}
                      className="px-2 py-1 text-xs text-ink-500 hover:text-ink-300 font-mono border border-ink-700"
                      title={`Switch to ${unitPreference === 'oz' ? 'ml' : 'oz'}`}
                    >
                      {unitPreference.toUpperCase()}
                    </button>
                  </div>
                  <div className="space-y-1">
                    {drink.ingredients?.map((ing, i) => {
                      const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                      const hasIt = invCanonical.has(ingCanonical);
                      const displayMeasure = convertMeasure(ing.measure, unitPreference);
                      return (
                        <div key={i} className="text-ink-100 flex items-center gap-2">
                          <span className={`inline-block w-1 h-1 rounded-full flex-shrink-0 ${hasIt ? 'bg-ink-500' : 'border border-ink-600 bg-transparent'}`}></span>
                          <span>{displayMeasure} {ing.name}</span>
                        </div>
                      );
                    })}
                  </div>
                </div>

                <hr className="border-ink-700" />

                {/* Method */}
                <div>
                  {drink.instructions ? (
                    <div className="space-y-1">
                      {drink.instructions.split(/[\.!?]\s+/).filter(Boolean).map((sentence, i) => (
                        <div key={i} className="text-ink-100">
                          {sentence.trim()}{sentence.trim().match(/[\.!?]$/) ? '' : '.'}
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-ink-500">No instructions provided.</div>
                  )}
                </div>

                {drink.notes && (
                  <>
                    <hr className="border-ink-700" />
                    <div>
                      <h2 className="text-lg font-semibold text-ink-200 mb-4">Notes</h2>
                      <p className="text-ink-400 leading-relaxed italic">{drink.notes}</p>
                    </div>
                  </>
                )}

                {/* Origin section - only shows if origin data exists */}
                {(drink.originTitle || drink.originAuthor || drink.originSourceType || drink.originUrl || drink.originYear || drink.originNotes) && (
                  <>
                    <hr className="border-ink-700" />
                    <div>
                      <h2 className="text-lg font-semibold text-ink-200 mb-4">Origin</h2>
                      <div className="space-y-3 text-sm text-ink-300">
                        {drink.originTitle && (
                          <div className="flex gap-2">
                            <span className="font-mono text-ink-500 min-w-[4rem]">Title:</span>
                            <span className="text-ink-200">{drink.originTitle}</span>
                          </div>
                        )}
                        {drink.originAuthor && (
                          <div className="flex gap-2">
                            <span className="font-mono text-ink-500 min-w-[4rem]">Author:</span>
                            <span className="text-ink-200">{drink.originAuthor}</span>
                          </div>
                        )}
                        {drink.originSourceType && (
                          <div className="flex gap-2">
                            <span className="font-mono text-ink-500 min-w-[4rem]">Source:</span>
                            <span className="text-ink-200 capitalize">{drink.originSourceType}</span>
                          </div>
                        )}
                        {drink.originUrl && (
                          <div className="flex gap-2">
                            <span className="font-mono text-ink-500 min-w-[4rem]">URL:</span>
                            <a href={drink.originUrl} target="_blank" rel="noopener noreferrer" className="text-copper hover:text-copper">
                              {drink.originUrl}
                            </a>
                          </div>
                        )}
                        {drink.originYear && (
                          <div className="flex gap-2">
                            <span className="font-mono text-ink-500 min-w-[4rem]">Year:</span>
                            <span className="text-ink-200">{drink.originYear}</span>
                          </div>
                        )}
                        {drink.originNotes && (
                          <div className="mt-4 pt-4 border-t border-ink-700">
                            <p className="text-ink-400 italic">{drink.originNotes}</p>
                          </div>
                        )}
                      </div>
                    </div>
                  </>
                )}

                {onDelete && (
                  <>
                    <hr className="border-ink-700" />
                    <div className="pt-4">
                      <button onClick={onDelete} className="text-sm text-ink-600 hover:text-red-400 transition-colors">
                        delete recipe
                      </button>
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };

    const IngredientDetailView = ({ ingredient, allDrinks, ingredientsDb, normalizeIngredient, onNavigateToRecipe, onClose }) => {
      // Find ingredient details from ingredientsDb
      let ingredientDetails = null;
      let category = '';
      let subcategory = '';

      if (ingredientsDb?.categories) {
        for (const cat of ingredientsDb.categories) {
          for (const sub of cat.subcategories || []) {
            for (const item of sub.items || []) {
              const canonical = normalizeIngredient(item.name, ingredientsDb);
              if (canonical === ingredient ||
                  item.aliases?.some(alias => normalizeIngredient(alias, ingredientsDb) === ingredient)) {
                ingredientDetails = item;
                category = cat.name;
                subcategory = sub.name;
                break;
              }
            }
            if (ingredientDetails) break;
          }
          if (ingredientDetails) break;
        }
      }

      // Find all cocktails that use this ingredient
      const cocktailsUsingIngredient = allDrinks.filter(drink => {
        return drink.ingredients?.some(ing => {
          const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
          return ingCanonical === ingredient;
        });
      });

      return (
        <div className="fixed inset-0 z-50 bg-ink-950 overflow-y-auto">
          <div className="min-h-screen py-8 px-4">
            <div className="max-w-2xl mx-auto">
              {/* Header */}
              <div className="flex items-center justify-between mb-8">
                <button onClick={onClose} className="text-ink-500 hover:text-ink-300 transition-colors">
                  ← Back
                </button>
                <h1 className="text-xl font-bold text-ink-100">Ingredient</h1>
                <div className="w-12" />
              </div>

              <div className="space-y-6">
                {/* Ingredient Info */}
                <div>
                  <h2 className="text-2xl font-bold text-ink-100 mb-2 uppercase">{ingredientDetails?.name || ingredient}</h2>
                  <hr className="border-ink-700 mb-4" />
                </div>

                {ingredientDetails?.aliases && ingredientDetails.aliases.length > 0 && (
                  <>
                    <div>
                      <div className="text-ink-100 text-sm">{ingredientDetails.aliases.join(', ')}</div>
                    </div>
                    <hr className="border-ink-700" />
                  </>
                )}

                <div>
                  <div className="space-y-2">
                    {cocktailsUsingIngredient.map(drink => (
                      <div key={drink.id} className="py-1 border-b border-ink-700 last:border-0">
                        <button
                          onClick={() => onNavigateToRecipe(drink)}
                          className="text-ink-100 hover:text-ink-300 transition-colors text-left uppercase font-bold"
                        >
                          {drink.name}
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const AddRecipeModal = ({ onClose, onAdd, onUpdate, editingDrink, ingredientsDb }) => {
      const [name, setName] = useState(editingDrink?.name || '');
      const [category, setCategory] = useState(editingDrink?.category || 'Cocktail');
      const [glass, setGlass] = useState(editingDrink?.glass || '');
      const [instructions, setInstructions] = useState(editingDrink?.instructions || '');
      const [notes, setNotes] = useState(editingDrink?.notes || '');
      const [ingredients, setIngredients] = useState(() => {
        if (!editingDrink?.ingredients) return [];
        return editingDrink.ingredients.map(ing => {
          // Parse measure like "2 oz" or "1/2 oz" or just "oz"
          const measure = ing.measure || '';
          const parts = measure.trim().split(/\s+/);
          if (parts.length >= 2) {
            return {
              name: ing.name,
              amount: parts.slice(0, -1).join(' '),
              unit: parts[parts.length - 1]
            };
          } else if (parts.length === 1 && parts[0]) {
            // Just a unit, no amount
            return {
              name: ing.name,
              amount: '',
              unit: parts[0]
            };
          }
          return {
            name: ing.name,
            amount: '',
            unit: 'oz'
          };
        });
      });
      const [showIngredientPicker, setShowIngredientPicker] = useState(false);
      const [ingredientSearch, setIngredientSearch] = useState('');
      const [expandedCategory, setExpandedCategory] = useState(null);
      const [editingIngredientIndex, setEditingIngredientIndex] = useState(null);
      const [autocompleteSuggestions, setAutocompleteSuggestions] = useState([]);
      const [showAutocomplete, setShowAutocomplete] = useState(false);
      const [selectedSuggestionIndex, setSelectedSuggestionIndex] = useState(-1);
      const autocompleteRefs = useRef({});

      // Flatten all ingredients for search (including aliases)
      const allIngredients = useMemo(() => {
        if (!ingredientsDb) return [];
        const flat = [];
        ingredientsDb.categories?.forEach(cat => {
          cat.subcategories?.forEach(sub => {
            sub.items?.forEach(item => {
              flat.push({ ...item, category: cat.name, subcategory: sub.name });
              // Add aliases as separate entries for easier matching
              if (item.aliases) {
                item.aliases.forEach(alias => {
                  flat.push({ ...item, name: alias, category: cat.name, subcategory: sub.name, isAlias: true });
                });
              }
            });
          });
        });
        return flat;
      }, [ingredientsDb]);

      // Get canonical name for an ingredient
      const getCanonicalName = (name) => {
        const normalized = normalizeIngredient(name, ingredientsDb);
        const found = allIngredients.find(ing => normalizeIngredient(ing.name, ingredientsDb) === normalized && !ing.isAlias);
        return found ? found.name : null;
      };

      // Filter ingredients by search for autocomplete
      const getAutocompleteSuggestions = (searchTerm) => {
        if (!searchTerm.trim() || searchTerm.length < 2) return [];
        const term = searchTerm.toLowerCase().trim();
        return allIngredients
          .filter(ing => {
            const nameMatch = ing.name.toLowerCase().includes(term);
            const aliasMatch = ing.aliases?.some(a => a.toLowerCase().includes(term));
            return (nameMatch || aliasMatch) && !ing.isAlias;
          })
          .slice(0, 8)
          .map(ing => ing.name);
      };

      // Filter ingredients for the ingredient picker
      const filteredIngredients = useMemo(() => {
        if (!ingredientSearch.trim()) return [];
        const term = ingredientSearch.toLowerCase().trim();
        return allIngredients
          .filter(ing => {
            const nameMatch = ing.name.toLowerCase().includes(term);
            const aliasMatch = ing.aliases?.some(a => a.toLowerCase().includes(term));
            const categoryMatch = ing.category?.toLowerCase().includes(term);
            const subcategoryMatch = ing.subcategory?.toLowerCase().includes(term);
            return (nameMatch || aliasMatch || categoryMatch || subcategoryMatch) && !ing.isAlias;
          })
          .slice(0, 20);
      }, [ingredientSearch, allIngredients]);

      const selectAutocompleteSuggestion = (index, suggestion) => {
        const updated = [...ingredients];
        updated[index].name = suggestion;
        setIngredients(updated);
        setShowAutocomplete(false);
        setAutocompleteSuggestions([]);
        setEditingIngredientIndex(null);
        setSelectedSuggestionIndex(-1);
      };

      const addIngredient = (ingredientName = '') => {
        const canonical = getCanonicalName(ingredientName) || ingredientName;
        setIngredients([...ingredients, { name: canonical, amount: '', unit: 'oz' }]);
        setShowIngredientPicker(false);
        setIngredientSearch('');
        setExpandedCategory(null);
        setEditingIngredientIndex(null);
      };

      const updateIngredient = (i, field, value) => {
        const updated = [...ingredients];
        updated[i][field] = value;
        setIngredients(updated);
        
        // If updating name, show autocomplete
        if (field === 'name' && value.length >= 2) {
          const suggestions = getAutocompleteSuggestions(value);
          setAutocompleteSuggestions(suggestions);
          setShowAutocomplete(true);
          setEditingIngredientIndex(i);
          setSelectedSuggestionIndex(-1); // Reset selection when typing
        } else if (field === 'name' && value.length < 2) {
          setShowAutocomplete(false);
          setSelectedSuggestionIndex(-1);
        }
      };

      const quickAddAmount = (index, amount) => {
        const updated = [...ingredients];
        updated[index].amount = amount;
        setIngredients(updated);
      };

      const removeIngredient = (i) => setIngredients(ingredients.filter((_, idx) => idx !== i));

      const handleSubmit = () => {
        if (!name.trim() || ingredients.length === 0) return;
        
        // Validate that all ingredients have names
        const invalidIngredients = ingredients.filter(ing => !ing.name || !ing.name.trim());
        if (invalidIngredients.length > 0) {
          // Could show a toast here, but for now just return
          return;
        }
        
        const formattedIngredients = ingredients
          .filter(ing => ing.name && ing.name.trim()) // Filter out any empty names
          .map(ing => ({
            name: ing.name.trim(),
            measure: ing.amount && ing.amount.trim() 
              ? `${ing.amount.trim()} ${ing.unit}` 
              : ing.unit || '1'
          }));
        
        if (formattedIngredients.length === 0) return;
        
        const recipeData = { 
          name: name.trim(), 
          category, 
          glass: glass.trim(), 
          instructions: instructions.trim(), 
          notes: notes.trim(), 
          ingredients: formattedIngredients 
        };
        
        if (editingDrink && onUpdate) {
          onUpdate(editingDrink.id, recipeData);
        } else {
          onAdd(recipeData);
        }
      };

      const measurements = ingredientsDb?.measurements || [
        { id: 'oz', name: 'oz' }, { id: 'ml', name: 'ml' }, { id: 'dash', name: 'dash' },
        { id: 'dashes', name: 'dashes' }, { id: 'barspoon', name: 'barspoon' }, { id: 'splash', name: 'splash' },
        { id: 'top', name: 'top' }, { id: 'rinse', name: 'rinse' }, { id: 'whole', name: 'whole' },
        { id: 'leaves', name: 'leaves' }, { id: 'drops', name: 'drops' }
      ];

      const amounts = ingredientsDb?.amounts || ['1/4', '1/2', '3/4', '1', '1 1/2', '2', '2 1/2', '3', '4', '6', '8'];
      const glassware = ingredientsDb?.glassware || [
        { id: 'rocks', name: 'Rocks Glass' }, { id: 'coupe', name: 'Coupe' },
        { id: 'martini', name: 'Martini Glass' }, { id: 'highball', name: 'Highball Glass' },
        { id: 'collins', name: 'Collins Glass' }, { id: 'flute', name: 'Champagne Flute' }
      ];

      return (
        <div className="fixed inset-0 z-50 bg-ink-950 overflow-y-auto" onClick={onClose}>
          <div className="min-h-screen sm:py-8 sm:px-4" onClick={e => e.stopPropagation()}>
            <div className="max-w-xl mx-auto bg-ink-950 sm:card sm:rounded-2xl ">
              <div className="p-5 sm:p-6">
                <div className="flex items-center justify-between mb-6">
                  <h2 className="font-display text-2xl text-ink-100 font-light">{editingDrink ? 'Edit Recipe' : 'Build Cocktail'}</h2>
                  <button onClick={onClose} className="p-2 text-ink-500 hover:text-ink-300"><Icon name="X" className="w-5 h-5" /></button>
                </div>

                <div className="space-y-5">
                  {/* Name */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Name *</label>
                    <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Recipe name" className="w-full px-4 py-3 input-field  text-ink-100 font-light" autoFocus />
                  </div>

                  {/* Category & Glass */}
                  <div className="grid grid-cols-2 gap-3">
                    <div>
                      <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Category</label>
                      <select value={category} onChange={(e) => setCategory(e.target.value)} className="w-full px-4 py-3 input-field  text-ink-100 font-light bg-transparent appearance-none cursor-pointer">
                        {['Cocktail', 'Sour', 'Spirit Forward', 'Highball', 'Tiki', 'Spritz', 'Martini', 'Flip', 'Hot Drink', 'Other'].map(c => (
                          <option key={c} value={c} className="bg-ink-900">{c}</option>
                        ))}
                      </select>
                    </div>
                    <div>
                      <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Glass</label>
                      <select value={glass} onChange={(e) => setGlass(e.target.value)} className="w-full px-4 py-3 input-field  text-ink-100 font-light bg-transparent appearance-none cursor-pointer">
                        <option value="" className="bg-ink-900">Select glass...</option>
                        {glassware.map(g => (
                          <option key={g.id} value={g.name} className="bg-ink-900">{g.name}</option>
                        ))}
                      </select>
                    </div>
                  </div>

                  {/* Ingredients */}
                  <div>
                    <div className="flex items-center justify-between mb-3">
                      <label className="text-2xs text-ink-500 uppercase tracking-widest">Ingredients *</label>
                    </div>

                    {/* Added ingredients */}
                    {ingredients.length > 0 && (
                      <div className="space-y-2 mb-3">
                        {ingredients.map((ing, i) => {
                          const canonicalName = getCanonicalName(ing.name);
                          const isUnmatched = ing.name.trim() && ing.name.length >= 2 && !canonicalName && editingIngredientIndex !== i;
                          
                          return (
                            <div key={i} className="relative">
                              <div className={`flex flex-col sm:flex-row sm:items-center gap-2 p-3 border border-ink-700 ${isUnmatched ? 'border border-amber-900/50 bg-amber-950/10' : ''}`}>
                                {/* Top row: Amount and Unit controls */}
                                <div className="flex items-center gap-2 flex-wrap flex-shrink-0">
                                  {/* Quick amount buttons */}
                                  <div className="flex gap-1">
                                    {['1/4', '1/2', '3/4', '1'].map(amt => (
                                      <button
                                        key={amt}
                                        onClick={() => quickAddAmount(i, amt)}
                                        className={`px-2 py-1 text-xs transition-colors ${
                                          ing.amount === amt 
                                            ? 'bg-copper/20 text-copper border border-copper/30' 
                                            : 'bg-transparent text-ink-500 transparent border border-ink-700'
                                        }`}
                                      >
                                        {amt}
                                      </button>
                                    ))}
                                  </div>
                                  
                                  <select
                                    value={ing.amount}
                                    onChange={(e) => updateIngredient(i, 'amount', e.target.value)}
                                    className="w-20 px-2 py-1.5 bg-transparent border border-ink-700 text-sm text-copper font-light appearance-none cursor-pointer flex-shrink-0"
                                  >
                                    <option value="" className="bg-ink-900">—</option>
                                    {amounts.map(a => (
                                      <option key={a} value={a} className="bg-ink-900">{a}</option>
                                    ))}
                                  </select>
                                  
                                  {/* Unit helpers */}
                                  <div className="flex gap-1">
                                    {['oz', 'dash', 'tsp', 'barspoon'].map(unit => (
                                      <button
                                        key={unit}
                                        onClick={() => updateIngredient(i, 'unit', unit)}
                                        className={`px-2 py-1 text-xs transition-colors ${
                                          ing.unit === unit
                                            ? 'bg-copper/20 text-copper border border-copper/30'
                                            : 'bg-transparent text-ink-500 transparent border border-ink-700'
                                        }`}
                                      >
                                        {unit}
                                      </button>
                                    ))}
                                  </div>
                                  
                                  <select
                                    value={ing.unit}
                                    onChange={(e) => updateIngredient(i, 'unit', e.target.value)}
                                    className="w-24 px-2 py-1.5 bg-transparent border border-ink-700 text-sm text-copper font-light appearance-none cursor-pointer flex-shrink-0"
                                  >
                                    {measurements.map(m => (
                                      <option key={m.id} value={m.name} className="bg-ink-900">{m.name}</option>
                                    ))}
                                  </select>
                                </div>
                                
                                {/* Bottom row: Ingredient name input with autocomplete */}
                                <div className="flex-1 relative min-w-0">
                                  <input
                                    type="text"
                                    value={ing.name}
                                    onChange={(e) => updateIngredient(i, 'name', e.target.value)}
                                    onKeyDown={(e) => {
                                      if (e.key === 'ArrowDown' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        setSelectedSuggestionIndex(prev => {
                                          const next = prev < autocompleteSuggestions.length - 1 ? prev + 1 : 0;
                                          return next;
                                        });
                                        setShowAutocomplete(true);
                                      } else if (e.key === 'ArrowUp' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        setSelectedSuggestionIndex(prev => {
                                          const next = prev > 0 ? prev - 1 : autocompleteSuggestions.length - 1;
                                          return next;
                                        });
                                        setShowAutocomplete(true);
                                      } else if (e.key === 'Enter' && showAutocomplete && selectedSuggestionIndex >= 0) {
                                        e.preventDefault();
                                        selectAutocompleteSuggestion(i, autocompleteSuggestions[selectedSuggestionIndex]);
                                      } else if (e.key === 'Enter' && showAutocomplete && autocompleteSuggestions.length > 0) {
                                        e.preventDefault();
                                        selectAutocompleteSuggestion(i, autocompleteSuggestions[0]);
                                      } else if (e.key === 'Escape') {
                                        setShowAutocomplete(false);
                                        setSelectedSuggestionIndex(-1);
                                      }
                                    }}
                                    onFocus={() => {
                                      setEditingIngredientIndex(i);
                                      if (ing.name.length >= 2) {
                                        setAutocompleteSuggestions(getAutocompleteSuggestions(ing.name));
                                        setShowAutocomplete(true);
                                        setSelectedSuggestionIndex(-1);
                                      }
                                    }}
                                    onBlur={() => {
                                      setTimeout(() => {
                                        setShowAutocomplete(false);
                                        setEditingIngredientIndex(null);
                                        setSelectedSuggestionIndex(-1);
                                      }, 200);
                                    }}
                                    placeholder="Ingredient name (type to search or enter custom)"
                                    className={`w-full px-3 py-1.5 bg-transparent border text-sm font-light ${
                                      isUnmatched 
                                        ? 'border-amber-900/50 text-amber-300' 
                                        : canonicalName 
                                          ? 'border-emerald-900/30 text-ink-300' 
                                          : 'border-ink-700 text-ink-300'
                                    }`}
                                  />
                                  
                                  {/* Autocomplete dropdown */}
                                  {showAutocomplete && editingIngredientIndex === i && autocompleteSuggestions.length > 0 && (
                                    <div className="absolute top-full left-0 right-0 mt-1 bg-ink-900 border border-ink-700   z-50 max-h-48 overflow-y-auto">
                                      {autocompleteSuggestions.map((suggestion, idx) => (
                                        <button
                                          key={idx}
                                          onMouseDown={(e) => {
                                            e.preventDefault();
                                            selectAutocompleteSuggestion(i, suggestion);
                                          }}
                                          onMouseEnter={() => setSelectedSuggestionIndex(idx)}
                                          className={`w-full text-left px-3 py-2 text-sm transition-colors ${
                                            selectedSuggestionIndex === idx
                                              ? 'bg-copper/20 text-copper'
                                              : 'text-ink-300 transparent hover:text-ink-100'
                                          }`}
                                        >
                                          {suggestion}
                                        </button>
                                      ))}
                                    </div>
                                  )}
                                  
                                  {/* Validation feedback - now shows it's OK to use custom */}
                                  {isUnmatched && ing.name.length >= 2 && (
                                    <div className="absolute top-full left-0 right-0 mt-1 px-2 py-1 text-2xs text-amber-400 bg-amber-950/30 border border-amber-900/50 z-40">
                                      Custom ingredient (not in database)
                                    </div>
                                  )}
                                </div>
                                
                                <button onClick={() => removeIngredient(i)} className="p-1.5 text-ink-600 hover:text-red-400 flex-shrink-0 self-start sm:self-center">
                                  <Icon name="X" className="w-4 h-4" />
                                </button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Add ingredient button/picker */}
                    {!showIngredientPicker ? (
                      <button
                        onClick={() => setShowIngredientPicker(true)}
                        className="w-full p-3 border border-dashed border-ink-700 copper/50  text-ink-500 hover:text-copper text-sm font-light transition-colors flex items-center justify-center gap-2"
                      >
                        <Icon name="Plus" className="w-4 h-4" />
                        Add Ingredient
                      </button>
                    ) : (
                      <div className="border border-ink-700 p-3 ">
                        {/* Search */}
                        <div className="relative mb-3">
                          <Icon name="Search" className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-ink-600" />
                          <input
                            type="text"
                            value={ingredientSearch}
                            onChange={(e) => setIngredientSearch(e.target.value)}
                            placeholder="Search ingredients..."
                            className="w-full pl-10 pr-4 py-2.5 input-field  text-sm text-ink-100 font-light"
                            autoFocus
                          />
                        </div>

                        {/* Search results */}
                        {filteredIngredients && filteredIngredients.length > 0 ? (
                          <div className="max-h-48 overflow-y-auto space-y-1">
                            {filteredIngredients.map((ing, i) => (
                              <button
                                key={i}
                                onClick={() => addIngredient(ing.name)}
                                className="w-full text-left px-3 py-2 transparent transition-colors"
                              >
                                <span className="text-sm text-ink-100">{ing.name}</span>
                                <span className="text-2xs text-ink-600 ml-2">{ing.subcategory}</span>
                              </button>
                            ))}
                          </div>
                        ) : ingredientSearch.trim() ? (
                          <div className="text-center py-4">
                            <p className="text-sm text-ink-500 mb-2">No matches found</p>
                            <button
                              onClick={() => addIngredient(ingredientSearch.trim())}
                              className="text-sm text-copper hover:text-copper"
                            >
                              Add "{ingredientSearch.trim()}" as custom
                            </button>
                          </div>
                        ) : (
                          /* Browse categories */
                          <div className="max-h-64 overflow-y-auto">
                            {ingredientsDb?.categories?.map(cat => (
                              <div key={cat.id} className="mb-1">
                                <button
                                  onClick={() => setExpandedCategory(expandedCategory === cat.id ? null : cat.id)}
                                  className="w-full flex items-center justify-between px-3 py-2 transparent transition-colors"
                                >
                                  <span className="text-xs text-ink-400 uppercase tracking-wider">{cat.name}</span>
                                  <Icon name={expandedCategory === cat.id ? 'ChevronDown' : 'ChevronRight'} className="w-4 h-4 text-ink-600" />
                                </button>
                                {expandedCategory === cat.id && (
                                  <div className="ml-2 border-l border-ink-700">
                                    {cat.subcategories?.map(sub => (
                                      <div key={sub.id} className="ml-2">
                                        <p className="text-2xs text-ink-600 px-2 py-1 mt-1">{sub.name}</p>
                                        {sub.items?.map(item => (
                                          <button
                                            key={item.id}
                                            onClick={() => addIngredient(item.name)}
                                            className="w-full text-left px-3 py-1.5 text-sm text-ink-300 hover:text-ink-100 transparent transition-colors"
                                          >
                                            {item.name}
                                          </button>
                                        ))}
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        )}

                        <button
                          onClick={() => { setShowIngredientPicker(false); setIngredientSearch(''); setExpandedCategory(null); }}
                          className="w-full mt-3 py-2 text-xs text-ink-500 hover:text-ink-300"
                        >
                          Cancel
                        </button>
                      </div>
                    )}
                  </div>

                  {/* Method */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Method</label>
                    <textarea value={instructions} onChange={(e) => setInstructions(e.target.value)} placeholder="Shake, stir, build..." rows="3" className="w-full px-4 py-3 input-field  text-ink-100 font-light resize-none" />
                  </div>

                  {/* Notes */}
                  <div>
                    <label className="text-2xs text-ink-500 uppercase tracking-widest mb-2 block">Notes</label>
                    <textarea value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Where you had it, variations, etc..." rows="2" className="w-full px-4 py-3 input-field  text-ink-100 font-light resize-none" />
                  </div>

                  <button
                    onClick={handleSubmit}
                    disabled={!name.trim() || ingredients.length === 0 || ingredients.some(ing => !ing.name || !ing.name.trim())}
                    className="w-full py-4 btn-copper text-sm font-medium tracking-wide uppercase disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {editingDrink ? 'Update Recipe' : 'Save Recipe'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const InventoryView = ({ inventory, activeBar, bars, onAdd, onRemove, onSwitchBar, onManageBars, ingredientsDb, getAllDrinks, canMakeDrink, getActiveBarInventory, normalizeIngredient }) => {
      const [newItem, setNewItem] = useState('');
      const [isAdding, setIsAdding] = useState(false);
      const [showSuggestions, setShowSuggestions] = useState(false);
      const [autocompleteSuggestions, setAutocompleteSuggestions] = useState([]);
      const [selectedIndex, setSelectedIndex] = useState(-1);
      const inputRef = useRef(null);
      const suggestionsRef = useRef(null);

      const handleAdd = (itemName = null) => {
        const item = itemName || newItem.trim();
        if (!item) return;
        onAdd(item);
        setNewItem('');
        setAutocompleteSuggestions([]);
        setShowSuggestions(false);
        setSelectedIndex(-1);
      };

      useEffect(() => {
        if (isAdding && inputRef.current) inputRef.current.focus();
      }, [isAdding]);

      // Close suggestions when clicking outside
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (suggestionsRef.current && !suggestionsRef.current.contains(event.target) && 
              inputRef.current && !inputRef.current.contains(event.target)) {
            setShowSuggestions(false);
          }
        };
        
        if (showSuggestions) {
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }
      }, [showSuggestions]);

      // Flatten all ingredients from ingredients.json for autocomplete
      const allIngredients = useMemo(() => {
        if (!ingredientsDb) return [];
        const flat = [];
        ingredientsDb.categories?.forEach(cat => {
          cat.subcategories?.forEach(sub => {
            sub.items?.forEach(item => {
              flat.push({
                name: item.name,
                id: item.id,
                category: cat.name,
                subcategory: sub.name,
                aliases: item.aliases || []
              });
            });
          });
        });
        return flat;
      }, [ingredientsDb]);

      // Get autocomplete suggestions based on input
      const getAutocompleteSuggestions = useMemo(() => {
        if (!newItem.trim() || newItem.length < 1) {
          // If empty or very short, show common ingredients
          return COMMON_INGREDIENTS.filter(i => {
            const canonical = normalizeIngredient(i, ingredientsDb);
            return !inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical);
          }).slice(0, 20).map(name => ({ name, category: 'Common', subcategory: '' }));
        }

        const searchTerm = newItem.toLowerCase().trim();
        const results = [];
        const seen = new Set();

        // First, find exact matches and close matches
        allIngredients.forEach(ing => {
          const nameLower = ing.name.toLowerCase();
          const aliasesLower = ing.aliases.map(a => a.toLowerCase());
          
          // Check if already in inventory
          const canonical = normalizeIngredient(ing.name, ingredientsDb);
          if (inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical)) {
            return;
          }

          // Exact match
          if (nameLower === searchTerm || aliasesLower.includes(searchTerm)) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'exact' });
              seen.add(ing.name);
            }
            return;
          }

          // Starts with
          if (nameLower.startsWith(searchTerm) || aliasesLower.some(a => a.startsWith(searchTerm))) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'starts' });
              seen.add(ing.name);
            }
            return;
          }

          // Contains (for category searches like "amaro")
          if (nameLower.includes(searchTerm) || 
              aliasesLower.some(a => a.includes(searchTerm)) ||
              ing.subcategory.toLowerCase().includes(searchTerm) ||
              ing.category.toLowerCase().includes(searchTerm)) {
            if (!seen.has(ing.name)) {
              results.push({ ...ing, matchType: 'contains' });
              seen.add(ing.name);
            }
          }
        });

        // Sort by match type (exact > starts > contains), then alphabetically
        results.sort((a, b) => {
          const typeOrder = { exact: 0, starts: 1, contains: 2 };
          if (typeOrder[a.matchType] !== typeOrder[b.matchType]) {
            return typeOrder[a.matchType] - typeOrder[b.matchType];
          }
          return a.name.localeCompare(b.name);
        });

        return results.slice(0, 50); // Limit to 50 results
      }, [newItem, allIngredients, inventory, ingredientsDb]);

      // Update suggestions as user types
      useEffect(() => {
        if (newItem.trim().length >= 1) {
          setAutocompleteSuggestions(getAutocompleteSuggestions);
          setShowSuggestions(true);
          setSelectedIndex(-1); // Reset selection when typing
        } else {
          setAutocompleteSuggestions([]);
          setSelectedIndex(-1);
        }
      }, [newItem, getAutocompleteSuggestions]);

      // Group suggestions by category
      const groupedSuggestions = useMemo(() => {
        const groups = {};
        autocompleteSuggestions.forEach(ing => {
          const category = ing.category || 'Other';
          if (!groups[category]) groups[category] = [];
          groups[category].push(ing);
        });
        return groups;
      }, [autocompleteSuggestions]);
      
      // Flatten suggestions for keyboard navigation
      const flatSuggestions = useMemo(() => {
        const flat = [];
        Object.entries(groupedSuggestions).forEach(([category, items]) => {
          items.forEach(item => flat.push(item));
        });
        return flat;
      }, [groupedSuggestions]);

      const quickSuggestions = COMMON_INGREDIENTS.filter(i => {
        const canonical = normalizeIngredient(i, ingredientsDb);
        return !inventory.some(inv => normalizeIngredient(inv.name, ingredientsDb) === canonical);
      }).slice(0, 12);

      // Categorize inventory items using ingredients.json database
      const categorized = useMemo(() => {
        const result = {};
        const categoryOrder = ['Spirits', 'Liqueurs', 'Fortified Wines', 'Bitters', 'Syrups & Sweeteners', 'Citrus & Juices', 'Mixers & Sodas', 'Other'];
        categoryOrder.forEach(cat => result[cat] = []);

        inventory.forEach(item => {
          let found = false;
          const itemNameLower = item.name.toLowerCase();
          const itemCanonical = normalizeIngredient(item.name, ingredientsDb);

          // Try to find in ingredients.json database
          if (ingredientsDb) {
            for (const category of ingredientsDb.categories || []) {
              for (const subcategory of category.subcategories || []) {
                for (const ing of subcategory.items || []) {
                  const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
                  if (ingCanonical === itemCanonical || 
                      ing.aliases?.some(alias => normalizeIngredient(alias, ingredientsDb) === itemCanonical)) {
                    // Map database categories to display categories
                    let displayCategory = 'Other';
                    const catName = category.name.toLowerCase();
                    const subName = subcategory.name.toLowerCase();

                    if (catName.includes('spirit')) {
                      displayCategory = 'Spirits';
                    } else if (catName.includes('liqueur') || subName.includes('amaro') || subName.includes('amari')) {
                      displayCategory = 'Liqueurs';
                    } else if (catName.includes('fortified') || catName.includes('vermouth') || catName.includes('sherry') || catName.includes('port')) {
                      displayCategory = 'Fortified Wines';
                    } else if (catName.includes('bitter')) {
                      displayCategory = 'Bitters';
                    } else if (catName.includes('syrup') || catName.includes('sweetener') || catName.includes('honey') || catName.includes('agave')) {
                      displayCategory = 'Syrups & Sweeteners';
                    } else if (catName.includes('citrus') || catName.includes('juice') || subName.includes('juice')) {
                      displayCategory = 'Citrus & Juices';
                    } else if (catName.includes('mixer') || catName.includes('soda') || catName.includes('tonic')) {
                      displayCategory = 'Mixers & Sodas';
                    }

                    if (!result[displayCategory]) result[displayCategory] = [];
                    result[displayCategory].push(item);
                    found = true;
                    return;
                  }
                }
              }
            }
          }

          // Fallback to keyword matching if not found in database
          if (!found) {
            const keywordCategories = {
              'Spirits': ['vodka', 'gin', 'rum', 'tequila', 'whiskey', 'whisky', 'bourbon', 'scotch', 'brandy', 'cognac', 'mezcal', 'rye', 'pisco'],
              'Liqueurs': ['triple sec', 'cointreau', 'kahlua', 'amaretto', 'campari', 'aperol', 'chartreuse', 'benedictine', 'maraschino', 'st germain', 'drambuie', 'fernet', 'curacao', 'amaro', 'cynar'],
              'Fortified Wines': ['vermouth', 'lillet', 'sherry', 'port', 'madeira'],
              'Bitters': ['angostura', 'orange bitters', 'peychauds', 'bitters'],
              'Syrups & Sweeteners': ['simple syrup', 'honey', 'agave', 'grenadine', 'orgeat', 'sugar', 'syrup'],
              'Citrus & Juices': ['lime', 'lemon', 'orange', 'grapefruit', 'pineapple juice', 'orange juice', 'cranberry', 'juice'],
              'Mixers & Sodas': ['soda', 'tonic', 'ginger beer', 'cola', 'club soda', 'tonic water']
            };

            for (const [cat, keywords] of Object.entries(keywordCategories)) {
              if (keywords.some(k => itemNameLower.includes(k.toLowerCase()))) {
                result[cat].push(item);
                found = true;
                break;
              }
            }
          }

          if (!found) {
            result['Other'].push(item);
          }
        });

        // Sort items within each category alphabetically
        Object.keys(result).forEach(cat => {
          result[cat].sort((a, b) => a.name.localeCompare(b.name));
        });

        return result;
      }, [inventory, ingredientsDb]);

      // Calculate gateway bottles: ingredients that would unlock recipes
      const gatewayBottles = useMemo(() => {
        if (!getAllDrinks || !canMakeDrink || !ingredientsDb || !inventory) return [];
        
        const allDrinks = getAllDrinks();
        const currentInventory = getActiveBarInventory();
        const invCanonical = new Set(currentInventory.map(i => normalizeIngredient(i.name, ingredientsDb)));
        
        // Collect all ingredients from recipes that aren't in inventory
        const ingredientImpact = {};
        
        allDrinks.forEach(drink => {
          // Check if this drink can't be made currently
          const currentlyCanMake = drink.ingredients?.every(ing => {
            const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
            return invCanonical.has(ingCanonical);
          }) || false;
          
          if (!currentlyCanMake && drink.ingredients) {
            // Find missing ingredients
            drink.ingredients.forEach(ing => {
              const ingCanonical = normalizeIngredient(ing.name, ingredientsDb);
              if (!invCanonical.has(ingCanonical)) {
                // Check if adding this ingredient would make this drink makeable
                const wouldMake = drink.ingredients.every(ing2 => {
                  const ing2Canonical = normalizeIngredient(ing2.name, ingredientsDb);
                  return invCanonical.has(ing2Canonical) || ing2Canonical === ingCanonical;
                });
                
                if (wouldMake) {
                  const key = ingCanonical;
                  if (!ingredientImpact[key]) {
                    ingredientImpact[key] = {
                      name: ing.name,
                      canonical: ingCanonical,
                      recipes: []
                    };
                  }
                  // Avoid duplicate recipes
                  if (!ingredientImpact[key].recipes.find(r => r.id === drink.id)) {
                    ingredientImpact[key].recipes.push({
                      id: drink.id,
                      name: drink.name
                    });
                  }
                }
              }
            });
          }
        });
        
        // Convert to array and sort by recipe count
        return Object.values(ingredientImpact)
          .map(item => ({
            name: item.name,
            count: item.recipes.length,
            recipes: item.recipes
          }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 20); // Top 20 gateway bottles
      }, [getAllDrinks, canMakeDrink, ingredientsDb, inventory, getActiveBarInventory, normalizeIngredient]);

      return (
        <div className="max-w-2xl mx-auto ">
          {/* Bar Selector */}
          <div className="border border-ink-700 p-4 mb-6">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Icon name="Wine" className="w-5 h-5 text-copper" />
                <div>
                  <div className="flex items-center gap-2">
                    <span className="text-sm text-ink-100 font-medium">{activeBar?.name || 'Bar'}</span>
                    {activeBar?.isMain && (
                      <span className="text-2xs px-2 py-0.5  bg-copper/20 text-copper border border-copper/30">
                        Main
                      </span>
                    )}
                  </div>
                  <p className="text-2xs text-ink-500 mt-0.5">{inventory.length} ingredients</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={onManageBars}
                  className="px-3 py-1.5 text-xs text-ink-400 hover:text-ink-100 border border-ink-700  transition-colors"
                >
                  <Icon name="Settings" className="w-3.5 h-3.5 inline mr-1.5" />
                  Manage
                </button>
                {bars.length > 1 && (
                  <button
                    onClick={() => {
                      const nextBar = bars.find(b => b.id !== activeBar?.id) || bars[0];
                      onSwitchBar(nextBar.id);
                    }}
                    className="px-3 py-1.5 text-xs text-copper hover:text-copper border border-copper/30  copper/50 transition-colors"
                  >
                    <Icon name="RefreshCw" className="w-3.5 h-3.5 inline mr-1.5" />
                    Switch
                  </button>
                )}
              </div>
            </div>
          </div>

          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="font-display text-2xl text-ink-100 font-light">Your Bar</h2>
              <p className="text-ink-500 text-sm mt-0.5">{inventory.length} ingredients</p>
            </div>
            {!isAdding && (
              <button onClick={() => setIsAdding(true)} className="px-4 py-2.5 btn-copper text-sm font-medium">
                Add Ingredient
              </button>
            )}
          </div>

          {isAdding && (
            <div className="border border-ink-700 p-4 mb-6 ">
              <div className="flex gap-2 mb-3">
                <div className="flex-1 relative">
                  <input
                    ref={inputRef}
                    type="text"
                    value={newItem}
                    onChange={(e) => setNewItem(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (flatSuggestions.length > 0) {
                          setSelectedIndex(prev => {
                            const next = prev < flatSuggestions.length - 1 ? prev + 1 : 0;
                            // Scroll into view
                            setTimeout(() => {
                              const selectedEl = suggestionsRef.current?.querySelector(`[data-index="${next}"]`);
                              selectedEl?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                            }, 0);
                            return next;
                          });
                          setShowSuggestions(true);
                        }
                      } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (flatSuggestions.length > 0) {
                          setSelectedIndex(prev => {
                            const next = prev > 0 ? prev - 1 : flatSuggestions.length - 1;
                            // Scroll into view
                            setTimeout(() => {
                              const selectedEl = suggestionsRef.current?.querySelector(`[data-index="${next}"]`);
                              selectedEl?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                            }, 0);
                            return next;
                          });
                          setShowSuggestions(true);
                        }
                      } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (selectedIndex >= 0 && selectedIndex < flatSuggestions.length) {
                          handleAdd(flatSuggestions[selectedIndex].name);
                        } else if (autocompleteSuggestions.length > 0 && flatSuggestions.length > 0) {
                          handleAdd(flatSuggestions[0].name);
                        } else if (newItem.trim()) {
                          handleAdd();
                        }
                      } else if (e.key === 'Escape') {
                        setShowSuggestions(false);
                        setSelectedIndex(-1);
                      }
                    }}
                    onFocus={() => setShowSuggestions(true)}
                    placeholder="Type to search ingredients..."
                    className="w-full px-4 py-3 input-field text-ink-100"
                  />
                  
                  {/* Autocomplete dropdown */}
                  {showSuggestions && autocompleteSuggestions.length > 0 && (
                    <div 
                      ref={suggestionsRef}
                      className="absolute top-full left-0 right-0 mt-2 bg-ink-900 border border-ink-700   z-50 max-h-96 overflow-y-auto"
                    >
                      {Object.entries(groupedSuggestions).map(([category, items]) => (
                        <div key={category} className="border-b border-ink-700 last:border-0">
                          <div className="px-3 py-2 bg-ink-900">
                            <p className="text-2xs text-ink-500 uppercase tracking-wider">{category}</p>
                          </div>
                          {items.map((ing, idx) => {
                            const globalIdx = flatSuggestions.findIndex(s => s.id === ing.id && s.name === ing.name);
                            return (
                              <button
                                key={`${ing.id}-${idx}`}
                                data-index={globalIdx}
                                onClick={() => handleAdd(ing.name)}
                                onMouseEnter={() => setSelectedIndex(globalIdx)}
                                className={`w-full text-left px-4 py-2.5 text-sm transition-colors flex items-center justify-between ${
                                  selectedIndex === globalIdx
                                    ? 'bg-copper/20 text-copper'
                                    : 'text-ink-300 transparent hover:text-ink-100'
                                }`}
                              >
                                <span>{ing.name}</span>
                                {ing.subcategory && (
                                  <span className="text-2xs text-ink-600 ml-2">{ing.subcategory}</span>
                                )}
                              </button>
                            );
                          })}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                <button 
                  onClick={() => { 
                    setIsAdding(false); 
                    setNewItem(''); 
                    setShowSuggestions(false);
                    setAutocompleteSuggestions([]);
                  }} 
                  className="px-4 py-3 text-ink-500 hover:text-ink-300 font-light"
                >
                  Done
                </button>
              </div>
              
              {/* Quick add buttons (when input is empty) */}
              {!newItem.trim() && quickSuggestions.length > 0 && (
                <div className="border-t border-ink-700 pt-3">
                  <p className="text-2xs text-ink-600 uppercase tracking-widest mb-2">Quick add</p>
                  <div className="flex flex-wrap gap-1.5">
                    {quickSuggestions.map(s => (
                      <button
                        key={s}
                        onClick={() => handleAdd(s)}
                        className="px-2.5 py-1.5 text-xs text-ink-400 bg-transparent transparent hover:text-copper transition-colors"
                      >
                        {s}
                      </button>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {inventory.length === 0 ? (
            <div className="text-center py-16">
              <div className="w-16 h-16 mx-auto mb-4  bg-transparent flex items-center justify-center">
                <Icon name="Wine" className="w-7 h-7 text-ink-700" />
              </div>
              <p className="text-ink-400 font-light">Your bar is empty</p>
              <p className="text-ink-600 text-sm mt-1">Add ingredients to see what you can make</p>
            </div>
          ) : (
            <div className="space-y-6">
              {Object.entries(categorized).map(([cat, items]) => {
                if (items.length === 0) return null;
                return (
                  <div key={cat}>
                    <h3 className="text-2xs text-ink-500 uppercase tracking-widest mb-3">{cat}</h3>
                    <div className="flex flex-wrap gap-2">
                      {items.map(item => (
                        <div key={item.id} className="group flex items-center gap-2 px-3 py-2 border border-ink-700 transition-colors">
                          <span className="text-sm text-ink-300 capitalize font-light">{item.name}</span>
                          <button onClick={() => onRemove(item.id)} className="text-ink-700 hover:text-red-400 opacity-0 opacity-100 ">
                            <Icon name="X" className="w-3 h-3" />
                          </button>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })}
            </div>
          )}

          {/* Gateway Bottles Section */}
          {gatewayBottles.length > 0 && (
            <div className="mt-8">
              <div className="mb-4">
                <h2 className="font-display text-xl text-ink-100 font-light mb-1">Gateway Bottles</h2>
                <p className="text-ink-500 text-sm">Adding one of these would unlock new recipes</p>
              </div>
              <div className="border border-ink-700 overflow-hidden">
                {gatewayBottles.map((item) => (
                  <div
                    key={item.name}
                    className="py-3 px-4 border-b border-ink-700 transparent transition-colors last:border-0 group"
                  >
                    <div className="flex items-start justify-between gap-3">
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <h3 className="font-display text-base text-ink-100 font-medium text-copper transition-colors">
                            {item.name}
                          </h3>
                          <span className="text-2xs px-2 py-0.5  bg-copper/20 text-copper border border-copper/30 font-medium">
                            {item.count} {item.count === 1 ? 'recipe' : 'recipes'}
                          </span>
                        </div>
                        <p className="text-ink-600 text-2xs font-light line-clamp-1">
                          {item.recipes.slice(0, 5).map(r => r.name).join(' · ')}
                          {item.recipes.length > 5 && ' · ...'}
                        </p>
                      </div>
                      <button
                        onClick={() => onAdd(item.name)}
                        className="px-3 py-1.5 text-xs text-copper hover:text-copper border border-copper/30 copper/50  transition-colors flex-shrink-0 opacity-0 opacity-100"
                        title="Add to bar"
                      >
                        Add
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      );
    };

    const BackupModal = ({ onClose, onExport, onImport }) => {
      const fileRef = useRef(null);
      return (
        <div className="fixed inset-0 z-50 bg-ink-950 flex items-center justify-center p-4" onClick={onClose}>
          <div className="max-w-sm w-full bg-ink-900 p-5 " onClick={e => e.stopPropagation()}>
            <h2 className="font-display text-xl text-ink-100 font-light mb-5">Backup & Restore</h2>
            <div className="space-y-3">
              <button onClick={onExport} className="w-full p-4 border border-ink-700 text-left transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Download" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-ink-100 font-light text-copper transition-colors">Export Data</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Download your recipes and settings</p>
                  </div>
                </div>
              </button>
              <input type="file" ref={fileRef} onChange={onImport} accept=".json" className="hidden" />
              <button onClick={() => fileRef.current?.click()} className="w-full p-4 border border-ink-700 text-left transition-colors group">
                <div className="flex items-center gap-3">
                  <Icon name="Upload" className="w-5 h-5 text-copper" />
                  <div>
                    <p className="text-ink-100 font-light text-copper transition-colors">Import Data</p>
                    <p className="text-2xs text-ink-500 mt-0.5">Restore from a backup file</p>
                  </div>
                </div>
              </button>
            </div>
            <button onClick={onClose} className="w-full mt-5 py-3 text-sm text-ink-500 hover:text-ink-300">Cancel</button>
          </div>
        </div>
      );
    };

    const ManageBarsView = ({ bars, activeBarId, onCreateBar, onUpdateBar, onDeleteBar, onSetMainBar, onDuplicateBar, onSwitchBar, onClose }) => {
      const [editingId, setEditingId] = useState(null);
      const [editName, setEditName] = useState('');
      const [showCreate, setShowCreate] = useState(false);
      const [newBarName, setNewBarName] = useState('');
      const [deletingId, setDeletingId] = useState(null);

      const handleStartEdit = (bar) => {
        setEditingId(bar.id);
        setEditName(bar.name);
      };

      const handleSaveEdit = () => {
        if (editName.trim()) {
          onUpdateBar(editingId, { name: editName.trim() });
          setEditingId(null);
          setEditName('');
        }
      };

      const handleCreate = () => {
        if (newBarName.trim()) {
          onCreateBar(newBarName.trim());
          setNewBarName('');
          setShowCreate(false);
        }
      };

      const handleDelete = (id) => {
        onDeleteBar(id);
        setDeletingId(null);
      };

      return (
        <div className="max-w-3xl mx-auto ">
          <div className="flex items-center justify-between mb-6">
            <div>
              <h2 className="font-display text-2xl text-ink-100 font-light">Manage Bars</h2>
              <p className="text-ink-500 text-sm mt-0.5">Create and organize multiple bar inventories</p>
            </div>
            <button
              onClick={onClose}
              className="px-4 py-2 text-sm text-ink-400 hover:text-ink-100 border border-ink-700  transition-colors"
            >
              <Icon name="X" className="w-4 h-4 inline mr-2" />
              Close
            </button>
          </div>

          {/* Create New Bar */}
          {showCreate ? (
            <div className="border border-ink-700 p-4 mb-4">
              <div className="flex gap-2">
                <input
                  type="text"
                  value={newBarName}
                  onChange={(e) => setNewBarName(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') handleCreate();
                    if (e.key === 'Escape') {
                      setShowCreate(false);
                      setNewBarName('');
                    }
                  }}
                  placeholder="Bar name (e.g., Home, Cabin)"
                  className="flex-1 px-4 py-2 input-field  text-ink-100"
                  autoFocus
                />
                <button
                  onClick={handleCreate}
                  disabled={!newBarName.trim()}
                  className="px-4 py-2 btn-copper text-sm font-medium disabled:opacity-50"
                >
                  Create
                </button>
                <button
                  onClick={() => {
                    setShowCreate(false);
                    setNewBarName('');
                  }}
                  className="px-4 py-2 text-ink-400 hover:text-ink-100 border border-ink-700 "
                >
                  Cancel
                </button>
              </div>
            </div>
          ) : (
            <button
              onClick={() => setShowCreate(true)}
              className="mb-4 px-4 py-2.5 btn-copper text-sm font-medium w-full"
            >
              <Icon name="Plus" className="w-4 h-4 inline mr-2" />
              Create New Bar
            </button>
          )}

          {/* Bars List */}
          <div className="space-y-3">
            {bars.map(bar => (
              <div
                key={bar.id}
                className={`border border-ink-700 p-4 ${bar.id === activeBarId ? 'border-copper/30 bg-copper/5' : ''}`}
              >
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    {editingId === bar.id ? (
                      <div className="flex items-center gap-2">
                        <input
                          type="text"
                          value={editName}
                          onChange={(e) => setEditName(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') handleSaveEdit();
                            if (e.key === 'Escape') {
                              setEditingId(null);
                              setEditName('');
                            }
                          }}
                          className="flex-1 px-3 py-1.5 input-field  text-ink-100 text-sm"
                          autoFocus
                        />
                        <button
                          onClick={handleSaveEdit}
                          className="px-3 py-1.5 text-xs text-copper hover:text-copper"
                        >
                          Save
                        </button>
                        <button
                          onClick={() => {
                            setEditingId(null);
                            setEditName('');
                          }}
                          className="px-3 py-1.5 text-xs text-ink-500 hover:text-ink-300"
                        >
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <div>
                        <div className="flex items-center gap-2 mb-1">
                          <span className="text-ink-100 font-medium">{bar.name}</span>
                          {bar.isMain && (
                            <span className="text-2xs px-2 py-0.5  bg-copper/20 text-copper border border-copper/30">
                              Main
                            </span>
                          )}
                          {bar.id === activeBarId && (
                            <span className="text-2xs px-2 py-0.5  bg-emerald-900/30 text-emerald-300 border border-emerald-900/50">
                              Active
                            </span>
                          )}
                        </div>
                        <p className="text-2xs text-ink-500">
                          {bar.inventory.length} ingredients
                          {bar.updatedAt && ` • Updated ${new Date(bar.updatedAt).toLocaleDateString()}`}
                        </p>
                      </div>
                    )}
                  </div>

                  {editingId !== bar.id && (
                    <div className="flex items-center gap-2 flex-shrink-0">
                      {bar.id !== activeBarId && (
                        <button
                          onClick={() => onSwitchBar(bar.id)}
                          className="px-3 py-1.5 text-xs text-copper hover:text-copper border border-copper/30  copper/50 flex items-center"
                        >
                          Switch
                        </button>
                      )}
                      {!bar.isMain && (
                        <button
                          onClick={() => onSetMainBar(bar.id)}
                          className="px-3 py-1.5 text-xs text-ink-400 hover:text-ink-100 border border-ink-700 flex items-center justify-center"
                          title="Set as main bar"
                        >
                          <Icon name="Star" className="w-3.5 h-3.5" />
                        </button>
                      )}
                      <button
                        onClick={() => onDuplicateBar(bar.id)}
                        className="px-3 py-1.5 text-xs text-ink-400 hover:text-ink-100 border border-ink-700 flex items-center justify-center"
                        title="Duplicate bar"
                      >
                        <Icon name="Copy" className="w-3.5 h-3.5" />
                      </button>
                      <button
                        onClick={() => handleStartEdit(bar)}
                        className="px-3 py-1.5 text-xs text-ink-400 hover:text-ink-100 border border-ink-700 flex items-center justify-center"
                        title="Rename"
                      >
                        <Icon name="Edit" className="w-3.5 h-3.5" />
                      </button>
                      {bars.length > 1 && (
                        <button
                          onClick={() => setDeletingId(bar.id)}
                          className="px-3 py-1.5 text-xs text-red-400 hover:text-red-300 border border-red-900/30 flex items-center justify-center"
                          title="Delete"
                        >
                          <Icon name="Trash2" className="w-3.5 h-3.5" />
                        </button>
                      )}
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>

          {/* Delete Confirmation */}
          {deletingId && (
            <div className="fixed inset-0 z-50 bg-ink-950 flex items-center justify-center p-4">
              <div className="max-w-xs w-full bg-ink-900 p-5  text-center">
                <div className="w-12 h-12 mx-auto mb-4  bg-red-900/20 flex items-center justify-center">
                  <Icon name="Trash2" className="w-5 h-5 text-red-400" />
                </div>
                <h3 className="font-display text-lg text-ink-100 mb-2">Delete Bar</h3>
                <p className="text-sm text-ink-400 font-light mb-5">
                  Are you sure you want to delete "{bars.find(b => b.id === deletingId)?.name}"? This cannot be undone.
                </p>
                <div className="flex gap-3">
                  <button
                    onClick={() => setDeletingId(null)}
                    className="flex-1 py-3 text-sm text-ink-400 hover:text-ink-200 border border-ink-700"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={() => handleDelete(deletingId)}
                    className="flex-1 py-3 text-sm bg-red-900/30 text-red-400 red-900/40 "
                  >
                    Delete
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const ConfirmDialog = ({ title, message, onConfirm, onCancel }) => (
      <div className="fixed inset-0 z-[60] bg-ink-950 flex items-center justify-center p-4" onClick={onCancel}>
        <div className="max-w-xs w-full border border-ink-700 p-5  text-center" onClick={e => e.stopPropagation()}>
          <div className="w-12 h-12 mx-auto mb-4  bg-red-900/20 flex items-center justify-center">
            <Icon name="Trash2" className="w-5 h-5 text-red-400" />
          </div>
          <h3 className="font-display text-lg text-ink-100 mb-2">{title}</h3>
          <p className="text-sm text-ink-400 font-light mb-5">{message}</p>
          <div className="flex gap-3">
            <button onClick={onCancel} className="flex-1 py-3 text-sm text-ink-400 hover:text-ink-200 border border-ink-700">Cancel</button>
            <button onClick={onConfirm} className="flex-1 py-3 text-sm bg-red-900/50 text-red-300 red-900/70  transition-colors">Delete</button>
          </div>
        </div>
      </div>
    );

    // ============ RENDER ============
    
    function renderApp() {
      try {
        // Ensure React and ReactDOM are loaded
        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
          // Retry after a short delay if React isn't loaded yet
          setTimeout(renderApp, 100);
          return;
        }
        
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error('Root element not found');
        }
        
        // Use React 18 createRoot if available, otherwise fall back to React 17 render
        if (ReactDOM.createRoot) {
          const root = ReactDOM.createRoot(rootElement);
          root.render(
            <ToastProvider>
              <App />
            </ToastProvider>
          );
        } else if (ReactDOM.render) {
          // Fallback for React 17
          ReactDOM.render(
            <ToastProvider>
              <App />
            </ToastProvider>,
            rootElement
          );
        } else {
          throw new Error('ReactDOM.createRoot and ReactDOM.render are not available');
        }
      } catch (error) {
        console.error('Failed to render app:', error);
        const rootElement = document.getElementById('root');
        if (rootElement) {
          rootElement.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: #d6d3d1; font-family: 'JetBrains Mono', monospace;">
              <h1 style="color: #d4a574; margin-bottom: 1rem;">Barkeep</h1>
              <p style="color: #a8a29e; margin-bottom: 1rem;">Failed to load application</p>
              <p style="color: #78716c; font-size: 0.875rem;">${error.message}</p>
              <button onclick="window.location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #a16207; color: white; border: none; cursor: pointer;">
                Reload
              </button>
            </div>
          `;
        }
      }
    }
    
    // Wait for all resources to be loaded
    if (document.readyState === 'loading') {
      window.addEventListener('load', renderApp);
    } else {
      // DOM is already ready, try to render immediately
      renderApp();
    }
  </script>
</body>
</html>
